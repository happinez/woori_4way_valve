mlx16-gcc (Melexis Mlx16-GCC v3.1.115.11) 7.5.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


81332-xLW-BMx-202_Woory_4Way_Valve.elf:     file format elf32-mlx16-fx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .fw_vectors   00000240  00005800  00005800  00000194  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_cst_tables_ram 0000005e  00000e80  00005a40  000003d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx4_par_tables_ram 00000088  00000f00  00005a9e  00000432  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .lin_ram_flash 00000012  00001000  00001000  00000194  2**0
                  ALLOC
  4 .dp.data      00000008  00001012  00005b26  000004ba  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000090  0000101a  00005b2e  000004c2  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000003a8  000010aa  00005bbe  00000552  2**1
                  ALLOC
  7 .flash_data   00004a06  00005bbe  00005bbe  00000552  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .flash_fill   00003220  0000a5c4  0000a5c4  00004f58  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .fw_product_id 00000008  0000d7e4  0000d7e4  00008178  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .fw_app_version 00000004  0000d7ec  0000d7ec  00008180  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .fw_pltf_version 00000004  0000d7f0  0000d7f0  00008184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 12 .fw_prot_key  00000008  0000d7f4  0000d7f4  00008188  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .flash_crc    00000004  0000d7fc  0000d7fc  00008190  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 14 .debug_frame  00002314  00000000  00000000  00008194  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_info   0007d116  00000000  00000000  0000a4a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_abbrev 00006577  00000000  00000000  000875be  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000569c  00000000  00000000  0008db35  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_aranges 00000e08  00000000  00000000  000931d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_line   0000d9df  00000000  00000000  00093fd9  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_str    0000f686  00000000  00000000  000a19b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .comment      00000055  00000000  00000000  000b103e  2**0
                  CONTENTS, READONLY

Disassembly of section .fw_vectors:

00005800 <__fw_vectors>:
 * @return  void
 */
void l_ifc_wake_up_sl1 (void)
{
    (void)ml_WakeUp();
}
    5800:	54f0      	mov	UPr, #0
 */
void protection_Start(void)
{
    g_e8ShortOcc = C_ERR_SHORT_NO;
    diagnostic_Start();
}
    5802:	76da 4735 	jmpf	0x8e6a <_fw_start>
    5806:	a255      	add	A, [S-86]
    5808:	54f8      	mov	UPr, #8
    580a:	76da 1b23 	jmpf	0x3646 <__fatal>
    580e:	0000      	nop
    5810:	54f8      	mov	UPr, #8
    5812:	76da 1b23 	jmpf	0x3646 <__fatal>
    5816:	0000      	nop
    5818:	54f8      	mov	UPr, #8
    581a:	76da 1b23 	jmpf	0x3646 <__fatal>
    581e:	0000      	nop
    5820:	54f8      	mov	UPr, #8
    5822:	76da 1b23 	jmpf	0x3646 <__fatal>
    5826:	0100      	jmp	0x5a28 <.LASF1978+0x3>
    5828:	54f8      	mov	UPr, #8
    582a:	76da 1b23 	jmpf	0x3646 <__fatal>
    582e:	0000      	nop
    5830:	54f0      	mov	UPr, #0
    5832:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5836:	0000      	nop
    5838:	54f0      	mov	UPr, #0
    583a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    583e:	0000      	nop
    5840:	54f0      	mov	UPr, #0
    5842:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5846:	0000      	nop
    5848:	54f0      	mov	UPr, #0
    584a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    584e:	0000      	nop
    5850:	54f0      	mov	UPr, #0
    5852:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5856:	0000      	nop
    5858:	54f0      	mov	UPr, #0
    585a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    585e:	0000      	nop
    5860:	54f0      	mov	UPr, #0
    5862:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5866:	0000      	nop
    5868:	54f0      	mov	UPr, #0
    586a:	76da 4424 	jmpf	0x8848 <__UV_VS_INT>
    586e:	0000      	nop
    5870:	54f0      	mov	UPr, #0
    5872:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5876:	0000      	nop
    5878:	54f1      	mov	UPr, #1
    587a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    587e:	0000      	nop
    5880:	54f1      	mov	UPr, #1
    5882:	76da 443e 	jmpf	0x887c <__OVT_INT>
    5886:	0000      	nop
    5888:	54f1      	mov	UPr, #1
    588a:	76da 4447 	jmpf	0x888e <__OVC_INT>
    588e:	0000      	nop
    5890:	54f1      	mov	UPr, #1
    5892:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5896:	0000      	nop
    5898:	54f1      	mov	UPr, #1
    589a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    589e:	0000      	nop
    58a0:	54f1      	mov	UPr, #1
    58a2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58a6:	0000      	nop
    58a8:	54f1      	mov	UPr, #1
    58aa:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58ae:	0000      	nop
    58b0:	54f1      	mov	UPr, #1
    58b2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58b6:	0000      	nop
    58b8:	54f1      	mov	UPr, #1
    58ba:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58be:	0000      	nop
    58c0:	54f1      	mov	UPr, #1
    58c2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58c6:	0000      	nop
    58c8:	54f1      	mov	UPr, #1
    58ca:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58ce:	0000      	nop
    58d0:	54f5      	mov	UPr, #5
    58d2:	76da 4f87 	jmpf	0x9f0e <__STIMER_INT>
    58d6:	0000      	nop
    58d8:	54f2      	mov	UPr, #2
    58da:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58de:	0000      	nop
    58e0:	54f2      	mov	UPr, #2
    58e2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58e6:	0000      	nop
    58e8:	54f2      	mov	UPr, #2
    58ea:	76da 4fcd 	jmpf	0x9f9a <__CTIMER0_3_INT>
    58ee:	0000      	nop
    58f0:	54f2      	mov	UPr, #2
    58f2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58f6:	0000      	nop
    58f8:	54f2      	mov	UPr, #2
    58fa:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    58fe:	0000      	nop
    5900:	54f2      	mov	UPr, #2
    5902:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5906:	0000      	nop
    5908:	54f2      	mov	UPr, #2
    590a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    590e:	0000      	nop
    5910:	54f2      	mov	UPr, #2
    5912:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5916:	0000      	nop
    5918:	54f2      	mov	UPr, #2
    591a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    591e:	0000      	nop
    5920:	54f2      	mov	UPr, #2
    5922:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5926:	0000      	nop
    5928:	54f2      	mov	UPr, #2
    592a:	76da 4ee6 	jmpf	0x9dcc <__PWM_MASTER1_END_INT>
    592e:	0000      	nop
    5930:	54f2      	mov	UPr, #2
    5932:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5936:	0000      	nop
    5938:	54f2      	mov	UPr, #2
    593a:	76da 4efc 	jmpf	0x9df8 <__PWM_SLAVE2_CMP_INT>
    593e:	0000      	nop
    5940:	54f2      	mov	UPr, #2
    5942:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5946:	0000      	nop
    5948:	54f2      	mov	UPr, #2
    594a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    594e:	0000      	nop
    5950:	54f2      	mov	UPr, #2
    5952:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5956:	0000      	nop
    5958:	54f3      	mov	UPr, #3
    595a:	76da 3c95 	jmpf	0x792a <__ADC_SAR_INT>
    595e:	0000      	nop
    5960:	54f2      	mov	UPr, #2
    5962:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5966:	0000      	nop
    5968:	54f2      	mov	UPr, #2
    596a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    596e:	0000      	nop
    5970:	54f2      	mov	UPr, #2
    5972:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5976:	0000      	nop
    5978:	54f4      	mov	UPr, #4
    597a:	76da 45a9 	jmpf	0x8b52 <__COLIN_LIN_INT>
    597e:	0000      	nop
    5980:	54f2      	mov	UPr, #2
    5982:	76da 4435 	jmpf	0x886a <__OV_VS_INT>
    5986:	0000      	nop
    5988:	54f2      	mov	UPr, #2
    598a:	76da 4efe 	jmpf	0x9dfc <__DIAG_INT>
    598e:	0000      	nop
    5990:	54f2      	mov	UPr, #2
    5992:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5996:	0000      	nop
    5998:	54f2      	mov	UPr, #2
    599a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    599e:	0000      	nop
    59a0:	54f2      	mov	UPr, #2
    59a2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59a6:	0000      	nop
    59a8:	54f2      	mov	UPr, #2
    59aa:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59ae:	0000      	nop
    59b0:	54f2      	mov	UPr, #2
    59b2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59b6:	0000      	nop
    59b8:	54f2      	mov	UPr, #2
    59ba:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59be:	0000      	nop
    59c0:	54f2      	mov	UPr, #2
    59c2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59c6:	0000      	nop
    59c8:	54f2      	mov	UPr, #2
    59ca:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59ce:	0000      	nop
    59d0:	54f2      	mov	UPr, #2
    59d2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59d6:	0000      	nop
    59d8:	54f2      	mov	UPr, #2
    59da:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59de:	0000      	nop
    59e0:	54f2      	mov	UPr, #2
    59e2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59e6:	0000      	nop
    59e8:	54f2      	mov	UPr, #2
    59ea:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59ee:	0000      	nop
    59f0:	54f2      	mov	UPr, #2
    59f2:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59f6:	0000      	nop
    59f8:	54f2      	mov	UPr, #2
    59fa:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    59fe:	0000      	nop
    5a00:	54f2      	mov	UPr, #2
    5a02:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5a06:	0000      	nop
    5a08:	54f2      	mov	UPr, #2
    5a0a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5a0e:	0000      	nop
    5a10:	54f2      	mov	UPr, #2
    5a12:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5a16:	0000      	nop
    5a18:	54f2      	mov	UPr, #2
    5a1a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5a1e:	0000      	nop
    5a20:	54f4      	mov	UPr, #4
    5a22:	76da 5014 	jmpf	0xa028 <__UDFR_INT>
    5a26:	0000      	nop
    5a28:	54f4      	mov	UPr, #4
    5a2a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5a2e:	0000      	nop
    5a30:	54f2      	mov	UPr, #2
    5a32:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5a36:	0000      	nop
    5a38:	54f6      	mov	UPr, #6
    5a3a:	76da 4531 	jmpf	0x8a62 <_Generic_INT>
    5a3e:	0000      	nop

Disassembly of section .mlx4_cst_tables_ram:

00000e80 <__mlx4_cst_tables_ram_start>:
 e80:	a55a      	or	A, dp:0x5a <.LLST33>
 e82:	5aa5      	mov	io:0x25 <.LLST1+0x7>, Y
 e84:	0000      	nop
 e86:	0000      	nop
 e88:	0000      	nop
 e8a:	0000      	nop
 e8c:	0000      	nop
 e8e:	0000      	nop
 e90:	0000      	nop
 e92:	0000      	nop
 e94:	0000      	nop
 e96:	0000      	nop
 e98:	4104      	mov	dp:0x4 <_RST_CTRL+0x2>, AL
 e9a:	2000      	add	X, #0
 e9c:	0000      	nop
 e9e:	0000      	nop
 ea0:	01e0      	jmp	0x1262 <.LLST28+0x3>
 ea2:	0003      	jmp	0xeaa <.LASF1693+0x22>
 ea4:	0005      	jmp	0xeb0 <.LLST5+0x3>
 ea6:	0000      	nop
 ea8:	4233      	mov	[S-52], AL
 eaa:	5f50      	mov	ep:0x50 <.LASF1528+0x3>, X
 eac:	7c6d      	lod	X, #109
 eae:	998a      	subc	AL, dp:0x8a <__mlx4_flash_table_size+0x2>
 eb0:	140e      	call	0x6ce <.LASF1731+0x1>
 eb2:	201a      	add	X, #26
 eb4:	2c26      	cmp	X, #38
 eb6:	3832      	subc	X, #50
 eb8:	0248      	jmp	0x134a <_valve_gmr_data>
 eba:	c852      	sub	AH, #82
 ebc:	6f03      	lod	YH, ep:0x3 <_RST_CTRL+0x1>
 ebe:	ff05      	xor	Y, ep:0x5 <_RST_CTRL+0x3>
 ec0:	0000      	nop
 ec2:	e0ac      	add	Y, #-84
 ec4:	0001      	jmp	0xec8 <.Lframe0+0x8>
 ec6:	0200      	jmp	0x12c8 <.LASF1024+0xd>
 ec8:	7da0      	lod	X, dp:0xa0 <.LASF1559>
 eca:	d70a      	and	AH, ep:0xa <_MUPET>
 ecc:	39e4      	subc	X, dp:0xe4 <.LASF897+0x3>
 ece:	934e      	adc	AL, ep:0x4e <.LASF1528+0x1>
 ed0:	d3e0      	adc	AH, ep:0xe0 <.LASF1349+0x7>
 ed2:	a497      	or	A, #-105
 ed4:	2c1f      	cmp	X, #31
 ed6:	5b68      	mov	ep:0x68 <__mlx4_cst_tables_ram_size+0xa>, Y
 ed8:	a81f      	sub	A, #31
 eda:	b47f      	and	A, #127
 edc:	00b2      	jmp	0x1042 <_l_sAdcAvgObject+0xa>

Disassembly of section .mlx4_par_tables_ram:

00000f00 <_INDXtbl>:
 f00:	4040      	jmp	fp2:0x00
 f02:	4040      	jmp	fp2:0x00
 f04:	4040      	jmp	fp2:0x00
 f06:	4040      	jmp	fp2:0x00
 f08:	4040      	jmp	fp2:0x00
 f0a:	4040      	jmp	fp2:0x00
 f0c:	4040      	jmp	fp2:0x00
 f0e:	4040      	jmp	fp2:0x00
 f10:	4040      	jmp	fp2:0x00
 f12:	4040      	jmp	fp2:0x00
 f14:	4040      	jmp	fp2:0x00
 f16:	4040      	jmp	fp2:0x00
 f18:	4040      	jmp	fp2:0x00
 f1a:	4040      	jmp	fp2:0x00
 f1c:	4040      	jmp	fp2:0x00
 f1e:	4040      	jmp	fp2:0x00
 f20:	4040      	jmp	fp2:0x00
 f22:	4040      	jmp	fp2:0x00
 f24:	4040      	jmp	fp2:0x00
 f26:	4040      	jmp	fp2:0x00
 f28:	4040      	jmp	fp2:0x00
 f2a:	4040      	jmp	fp2:0x00
 f2c:	4040      	jmp	fp2:0x00
 f2e:	4040      	jmp	fp2:0x00
 f30:	4040      	jmp	fp2:0x00
 f32:	4040      	jmp	fp2:0x00
 f34:	4040      	jmp	fp2:0x00
 f36:	4040      	jmp	fp2:0x00
 f38:	4040      	jmp	fp2:0x00
 f3a:	4040      	jmp	fp2:0x00
 f3c:	1110      	call	0x115e <_ld_ResponseTransmittedMHBuffer+0x2>
 f3e:	c0c0      	add	AH, #-64

00000f40 <_PARAMtbl>:
 f40:	0f2f      	lod	C, io:0x05.7
 f42:	a02f      	add	A, #47
 f44:	a0a0      	add	A, #-96
 f46:	a0a0      	add	A, #-96
 f48:	a0a0      	add	A, #-96
 f4a:	a0a0      	add	A, #-96
 f4c:	a0a0      	add	A, #-96
 f4e:	a0a0      	add	A, #-96
 f50:	2707      	or	X, ep:0x7 <_FUNC_TEST+0x1>
 f52:	a0a0      	add	A, #-96
 f54:	a0a0      	add	A, #-96
 f56:	a0a0      	add	A, #-96
 f58:	a0a0      	add	A, #-96
 f5a:	a0a0      	add	A, #-96
 f5c:	a0a0      	add	A, #-96
 f5e:	a0a0      	add	A, #-96
 f60:	a0a0      	add	A, #-96
 f62:	a0a0      	add	A, #-96
 f64:	a0a0      	add	A, #-96
 f66:	a0a0      	add	A, #-96
 f68:	a0a0      	add	A, #-96
 f6a:	a0a0      	add	A, #-96
 f6c:	a0a0      	add	A, #-96
 f6e:	a0a0      	add	A, #-96
 f70:	a0a0      	add	A, #-96
 f72:	a0a0      	add	A, #-96
 f74:	a0a0      	add	A, #-96
 f76:	a0a0      	add	A, #-96
 f78:	a0a0      	add	A, #-96
 f7a:	a0a0      	add	A, #-96
 f7c:	a0a0      	add	A, #-96
 f7e:	a0a0      	add	A, #-96

00000f80 <_AUTOADDtbl>:
 f80:	2610      	or	X, [S-17]
 f82:	0626      	jmp	0xbd0 <.LLST11+0xb>
 f84:	0000      	nop
 f86:	0000      	nop

Disassembly of section .flash_data:

00005bbe <.LC0>:
    5bbe:	9201      	adc	AL, [S-2]
    5bc0:	f011      	adc	Y, #17

00005bc2 <___clz_tab>:
    5bc2:	0100 0202 0303 0303 0404 0404 0404 0404     ................
    5bd2:	0505 0505 0505 0505 0505 0505 0505 0505     ................
    5be2:	0606 0606 0606 0606 0606 0606 0606 0606     ................
    5bf2:	0606 0606 0606 0606 0606 0606 0606 0606     ................
    5c02:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c12:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c22:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c32:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c42:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c52:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c62:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c72:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c82:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c92:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5ca2:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5cb2:	0808 0808 0808 0808 0808 0808 0808 0808     ................

00005cc2 <.L28>:
    5cc2:	3262      	adc	X, [S-99]
    5cc4:	3266      	adc	X, [S-103]
    5cc6:	3291      	adc	X, io:0x11 <_ROM_SHELL+0x1>
    5cc8:	326a      	adc	X, [S-107]
    5cca:	326e      	adc	X, [S-111]
    5ccc:	3272      	adc	X, [S-115]
    5cce:	3276      	adc	X, [S-119]
    5cd0:	327a      	adc	X, [S-123]
    5cd2:	3282      	adc	X, io:0x2 <_RST_CTRL>
    5cd4:	3286      	adc	X, io:0x6 <_FUNC_TEST>
    5cd6:	328a      	adc	X, io:0xa <_MUPET>
    5cd8:	328e      	adc	X, io:0xe <_AWD>
    5cda:	327e      	adc	X, [S-127]

00005cdc <.L294>:
    5cdc:	3834      	subc	X, #52
    5cde:	3864      	subc	X, #100
    5ce0:	38cd      	subc	X, #-51
    5ce2:	38db      	subc	X, #-37
    5ce4:	390f      	subc	X, dp:0xf <_AWD+0x1>
    5ce6:	394f      	subc	X, dp:0x4f <.LASF1528+0x2>
    5ce8:	3a9e      	subc	X, io:0x1e <.LLST1>
    5cea:	3b28      	subc	X, ep:0x28 <.LLST1+0xa>
    5cec:	3b57      	subc	X, ep:0x57 <.Lframe0+0x3>
    5cee:	3b65      	subc	X, ep:0x65 <__mlx4_cst_tables_ram_size+0x7>
    5cf0:	3b7d      	subc	X, ep:0x7d <.LASF2136+0x9>

00005cf2 <.L332>:
    5cf2:	3975      	subc	X, dp:0x75 <.LASF2136+0x1>
    5cf4:	397f      	subc	X, dp:0x7f <.LASF2136+0xb>
    5cf6:	39a5      	subc	X, dp:0xa5 <.LASF1559+0x5>
    5cf8:	3a00      	subc	X, [S-1]
    5cfa:	3858      	subc	X, #88
    5cfc:	3a4a      	subc	X, [S-75]
    5cfe:	3858      	subc	X, #88
    5d00:	3a78      	subc	X, [S-121]
    5d02:	3a8b      	subc	X, io:0xb <_MUPET+0x1>
    5d04:	3a9a      	subc	X, io:0x1a <_ROM_BIST+0x6>

00005d06 <.L15>:
    5d06:	3d0c      	xor	X, dp:0xc <_MUPET+0x2>
    5d08:	3d12      	xor	X, dp:0x12 <__lin_ram_flash_size>
    5d0a:	3d23      	xor	X, dp:0x23 <.LLST1+0x5>
    5d0c:	3d29      	xor	X, dp:0x29 <.LLST1+0xb>
    5d0e:	3d2f      	xor	X, dp:0x2f <_IWD+0x3>
    5d10:	3d35      	xor	X, dp:0x35 <_PORT_ADC_CTRL+0x1>
    5d12:	3d3b      	xor	X, dp:0x3b <_MLX16+0x3>
    5d14:	3d41      	xor	X, dp:0x41 <.LLST2+0x5>

00005d16 <_IGNconversionMap>:
    5d16:	0132 0000 028a 0000 015b 0000 0384 0000     2.......[.......
    5d26:	0178 0000 04b0 0000 019b 0000 0708 0000     x...............

00005d36 <.L44>:
    5d36:	400f      	jmp	fp0:0x78
    5d38:	4018      	jmp	fp0:0xC0
    5d3a:	40a7      	jmp	fp5:0x38
    5d3c:	40ec      	jmp	fp7:0x60
    5d3e:	4117      	mov	dp:0x17 <_ROM_BIST+0x3>, AL
    5d40:	415a      	mov	dp:0x5a <.LLST33>, AL
    5d42:	4016      	jmp	fp0:0xB0
    5d44:	4172      	mov	dp:0x72 <__mlx4_cst_tables_ram_size+0x14>, AL

00005d46 <_eeprom_defaults>:
    5d46:	01ab 1192 00f0 0000 00ff 0000 0000 0000     ................
    5d56:	00ff 0000 0000 0000                         ........

00005d5e <.L55>:
    5d5e:	49da      	mov	dp:0xda <.LASF1349+0x1>, AH
    5d60:	49fc      	mov	dp:0xfc <.LASF2089+0x3>, AH
    5d62:	49f2      	mov	dp:0xf2 <.LASF897+0x11>, AH
    5d64:	4a06      	mov	[S-7], AH
    5d66:	4a0e      	mov	[S-15], AH
    5d68:	4a13      	mov	[S-20], AH
    5d6a:	49f0      	mov	dp:0xf0 <.LASF897+0xf>, AH

00005d6c <.L31>:
    5d6c:	4ac2      	mov	[--A], AH
    5d6e:	4ab9      	mov	io:0x39 <_MLX16+0x1>, AH
    5d70:	4ac2      	mov	[--A], AH
    5d72:	4acf      	mov	[--S], AH
    5d74:	4acf      	mov	[--S], AH
    5d76:	4acf      	mov	[--S], AH
    5d78:	4acf      	mov	[--S], AH
    5d7a:	4acf      	mov	[--S], AH
    5d7c:	4ac2      	mov	[--A], AH
    5d7e:	4acf      	mov	[--S], AH
    5d80:	4acf      	mov	[--S], AH
    5d82:	4acf      	mov	[--S], AH
    5d84:	4ab9      	mov	io:0x39 <_MLX16+0x1>, AH

00005d86 <___VPC_Fwv_Resp_flags_mask_3909>:
    5d86:	ffe0 10ff                                   ....

00005d8a <___VPC_Fwv_Ctrl_flags_mask_3985>:
    5d8a:	001f 4000                                   ...@

00005d8e <___Debug_Frame_flags_mask_3952>:
    5d8e:	0000 2f00                                   .../

00005d92 <_frameList>:
    5d92:	0000 5da2 0000 5d9e 0000 5da0               ...]...]...]

00005d9e <_l_sl1_VPC_Fwv_Ctrl_frame>:
    5d9e:	4b30                                        0K

00005da0 <_l_sl1_Debug_Frame_frame>:
    5da0:	4b02                                        .K

00005da2 <_l_sl1_VPC_Fwv_Resp_frame>:
    5da2:	4b5f                                        _K

00005da4 <_ml_ProductID>:
    5da4:	0000 0000 00ff                              ......

00005daa <_ml_InitialNAD>:
    5daa:	0001                                        ..

00005dac <_ATAN_LUT>:
    5dac:	0000 00a3 0146 01e9 028c 032f 03d2 0475     ....F...../...u.
    5dbc:	0517 05ba 065d 0700 07a2 0845 08e7 098a     ....].....E.....
    5dcc:	0a2c 0acf 0b71 0c13 0cb5 0d57 0df9 0e9a     ,...q.....W.....
    5ddc:	0f3c 0fdd 107f 1120 11c1 1262 1303 13a4     <..... ...b.....
    5dec:	1444 14e5 1585 1625 16c5 1765 1804 18a4     D.....%...e.....
    5dfc:	1943 19e2 1a80 1b1f 1bbd 1c5c 1cfa 1d97     C.........\.....
    5e0c:	1e35 1ed2 1f6f 200c 20a9 2145 21e1 227d     5...o.. . E!.!}"
    5e1c:	2319 23b4 2450 24ea 2585 261f 26ba 2753     .#.#P$.$.%.&.&S'
    5e2c:	27ed 2886 291f 29b8 2a50 2ae8 2b80 2c17     .'.(.).)P*.*.+.,
    5e3c:	2caf 2d46 2ddc 2e72 2f08 2f9e 3033 30c8     .,F-.-r.././30.0
    5e4c:	315d 31f1 3285 3319 33ac 343f 34d2 3564     ]1.1.2.3.3?4.4d5
    5e5c:	35f6 3687 3719 37a9 383a 38ca 395a 39e9     .5.6.7.7:8.8Z9.9
    5e6c:	3a78 3b07 3b95 3c23 3cb1 3d3e 3dcb 3e58     x:.;.;#<.<>=.=X>
    5e7c:	3ee4 3f6f 3ffb 4086 4110 419a 4224 42ad     .>o?.?.@.A.A$B.B
    5e8c:	4336 43bf 4447 44cf 4556 45dd 4664 46ea     6C.CGD.DVE.EdF.F
    5e9c:	4770 47f5 487a 48ff 4983 4a07 4a8b 4b0d     pG.GzH.H.I.J.J.K
    5eac:	4b90 4c12 4c94 4d15 4d96 4e17 4e97 4f17     .K.L.L.M.M.N.N.O
    5ebc:	4f96 5015 5093 5111 518f 520c 5289 5306     .O.P.P.Q.Q.R.R.S
    5ecc:	5382 53fd 5478 54f3 556e 55e8 5661 56da     .S.SxT.TnU.UaV.V
    5edc:	5753 57cb 5843 58ba 5932 59a8 5a1e 5a94     SW.WCX.X2Y.Y.Z.Z
    5eec:	5b0a 5b7f 5bf3 5c67 5cdb 5d4e 5dc1 5e34     .[.[.[g\.\N].]4^
    5efc:	5ea6 5f18 5f89 5ffa 606a 60db 614a 61b9     .^._._._j`.`Ja.a
    5f0c:	6228 6297 6305 6373 63e0 644d 64b9 6525     (b.b.csc.cMd.d%e
    5f1c:	6591 65fc 6667 66d1 673b 67a5 680e 6877     .e.egf.f;g.g.hwh
    5f2c:	68e0 6948 69b0 6a17 6a7e 6ae4 6b4b 6bb0     .hHi.i.j~j.jKk.k
    5f3c:	6c16 6c7b 6cdf 6d44 6da8 6e0b 6e6e 6ed1     .l{l.lDm.m.nnn.n
    5f4c:	6f33 6f95 6ff7 7058 70b9 7119 717a 71d9     3o.o.oXp.p.qzq.q
    5f5c:	7239 7298 72f6 7355 73b3 7410 746d 74ca     9r.r.rUs.s.tmt.t
    5f6c:	7527 7583 75df 763a 7695 76f0 774a 77a4     'u.u.u:v.v.vJw.w
    5f7c:	77fe 7857 78b0 7909 7961 79b9 7a10 7a68     .wWx.x.yay.y.zhz
    5f8c:	7abf 7b15 7b6b 7bc1 7c17 7c6c 7cc1 7d16     .z.{k{.{.|l|.|.}
    5f9c:	7d6a 7dbe 7e11 7e65 7eb7 7f0a 7f5c 7fae     j}.}.~e~.~..\...
    5fac:	8000 8051                                   ..Q.

00005fb0 <___gtsf2>:
    5fb0:	581d      	inc	S, #30

00005fb2 <.LCFI0>:
    5fb2:	58a1      	mov	[S-6], YA

00005fb4 <.LM3>:
    5fb4:	7223      	lod	A, [S-36]

00005fb6 <.LVL1>:
    5fb6:	5209      	mov	[S-10], A
    5fb8:	7221      	lod	A, [S-34]
    5fba:	5207      	mov	[S-8], A

00005fbc <.LM4>:
    5fbc:	7eef      	lod	X, S
    5fbe:	20ec      	add	X, #-20
    5fc0:	5edf      	push	X

00005fc2 <.LCFI1>:
    5fc2:	72ef      	lod	A, S
    5fc4:	a0f8      	add	A, #-8
    5fc6:	112d      	call	0x6222 <___unpack_f>

00005fc8 <.LM5>:
    5fc8:	7aef      	lod	Y, S
    5fca:	e0e0      	add	Y, #-32
    5fcc:	5adf      	push	Y

00005fce <.LCFI2>:
    5fce:	72ef      	lod	A, S
    5fd0:	a0f2      	add	A, #-14
    5fd2:	5a05      	mov	[S-6], Y
    5fd4:	1126      	call	0x6222 <___unpack_f>

00005fd6 <.LM6>:
    5fd6:	7217      	lod	A, [S-24]
    5fd8:	5c03      	dec	S, #4

00005fda <.LCFI3>:
    5fda:	7a01      	lod	Y, [S-2]
    5fdc:	ac01      	cmp	A, #1
    5fde:	1a08      	jule	0x5ff0 <.L4>

00005fe0 <.LM7>:
    5fe0:	721d      	lod	A, [S-30]
    5fe2:	ac01      	cmp	A, #1
    5fe4:	1a05      	jule	0x5ff0 <.L4>

00005fe6 <.LM8>:
    5fe6:	5adf      	push	Y

00005fe8 <.LCFI4>:
    5fe8:	72ef      	lod	A, S
    5fea:	a0ea      	add	A, #-22
    5fec:	1178      	call	0x62de <___fpcmp_parts_f>

00005fee <.LCFI5>:
    5fee:	5421      	ret	#34

00005ff0 <.L4>:
    5ff0:	70ff      	lod	A, #-1

00005ff2 <.LM10>:
    5ff2:	541f      	ret	#32

00005ff4 <___floatsisf>:
    5ff4:	580d      	inc	S, #14

00005ff6 <.LCFI0>:
    5ff6:	58a0      	mov	[S-4], YA

00005ff8 <.LM2>:
    5ff8:	7c03      	lod	X, #3
    5ffa:	5e0d      	mov	[S-14], X

00005ffc <.LM3>:
    5ffc:	7e01      	lod	X, [S-2]
    5ffe:	5c8f      	sn	X
    6000:	5e0b      	mov	[S-12], X

00006002 <.LM4>:
    6002:	4cc0      	mov	D, YA
    6004:	4caa 0000 	cmpu	D, #0
    6008:	1d06      	jne	0x6016 <.L2>

0000600a <.LM5>:
    600a:	7002      	lod	A, #2

0000600c <.LVL1>:
    600c:	520d      	mov	[S-14], A

0000600e <.L3>:
    600e:	72ef      	lod	A, S
    6010:	a0f2      	add	A, #-14
    6012:	1057      	call	0x60c2 <___pack_f>
    6014:	540f      	ret	#16

00006016 <.L2>:
    6016:	7c1e      	lod	X, #30
    6018:	5e09      	mov	[S-10], X

0000601a <.LM8>:
    601a:	58c0      	mov	D, [S-4]
    601c:	4caa 0000 	cmpu	D, #0
    6020:	1e87      	jsge	0x6030 <.L6>

00006022 <.LM9>:
    6022:	4c92 0000 	cmp	D, #-2147483648
    6026:	8000 
    6028:	1918      	je	0x605a <.L8>

0000602a <.LM10>:
    602a:	4c80      	mov	YA, D

0000602c <.LVL5>:
    602c:	4cf0      	neg	YA
    602e:	58a0      	mov	[S-4], YA

00006030 <.L6>:
    6030:	58e0      	mov	YA, [S-4]
    6032:	1017      	call	0x6062 <___clzsi2>

00006034 <.LBE6>:
    6034:	7ee2      	lod	X, A
    6036:	20ff      	add	X, #-1

00006038 <.LVL8>:
    6038:	ac01      	cmp	A, #1
    603a:	1d03      	jne	0x6042 <.L7>

0000603c <.LM13>:
    603c:	58e0      	mov	YA, [S-4]
    603e:	58a2      	mov	[S-8], YA
    6040:	07e6      	jmp	0x600e <.L3>

00006042 <.L7>:
    6042:	58e0      	mov	YA, [S-4]
    6044:	2c00      	cmp	X, #0
    6046:	1b04      	jsle	0x6050 <.L9>
    6048:	5edf      	push	X

0000604a <.L10>:
    604a:	48e0      	asl	YA, #1
    604c:	1bfe      	djnz	X, 0x604a <.L10>
    604e:	7ecf      	pop	X

00006050 <.L9>:
    6050:	58a2      	mov	[S-8], YA

00006052 <.LM15>:
    6052:	701e      	lod	A, #30
    6054:	aaee      	sub	A, X
    6056:	5209      	mov	[S-10], A
    6058:	07da      	jmp	0x600e <.L3>

0000605a <.L8>:
    605a:	4ce2 0000 	mov	YA, #-822083584
    605e:	cf00 

00006060 <.LBE5>:
    6060:	540f      	ret	#16

00006062 <___clzsi2>:
    6062:	580b      	inc	S, #12

00006064 <.LCFI0>:
    6064:	58a0      	mov	[S-4], YA

00006066 <.LBB2>:
    6066:	4cc0      	mov	D, YA
    6068:	4c92 ffff 	cmp	D, #65535
    606c:	0000 
    606e:	1e1b      	jug	0x60a6 <.L2>

00006070 <.LM3>:
    6070:	4caa 00ff 	cmpu	D, #255
    6074:	1a20      	jule	0x60b6 <.L4>

00006076 <.LM4>:
    6076:	4cfa 0008 	movs	YA, #8

0000607a <.L6>:
    607a:	58a2      	mov	[S-8], YA

0000607c <.LVL3>:
    607c:	4cda 0020 	movs	D, #32
    6080:	4c80      	mov	YA, D

00006082 <.LVL4>:
    6082:	aa07      	sub	A, [S-8]
    6084:	fa05      	subc	Y, [S-6]
    6086:	58a4      	mov	[S-12], YA
    6088:	7e07      	lod	X, [S-8]
    608a:	58e0      	mov	YA, [S-4]
    608c:	2c00      	cmp	X, #0
    608e:	1b02      	jsle	0x6094 <.L7>

00006090 <.L8>:
    6090:	48a0      	lsr	YA, #1
    6092:	1bfe      	djnz	X, 0x6090 <.L8>

00006094 <.L7>:
    6094:	a2da 5bc2 	add	A, #23490
    6098:	7ae2      	lod	Y, A
    609a:	62f0      	lod	AL, [Y]
    609c:	5cf2      	usex	A

0000609e <.LBE2>:
    609e:	7e0b      	lod	X, [S-12]
    60a0:	2ae2      	sub	X, A
    60a2:	72ee      	lod	A, X

000060a4 <.LM6>:
    60a4:	540d      	ret	#14

000060a6 <.L2>:
    60a6:	58c0      	mov	D, [S-4]
    60a8:	4c92 ffff 	cmp	D, #16777215
    60ac:	00ff 
    60ae:	1a06      	jule	0x60bc <.L5>

000060b0 <.LM8>:
    60b0:	4cfa 0018 	movs	YA, #24

000060b4 <.LVL6>:
    60b4:	07e2      	jmp	0x607a <.L6>

000060b6 <.L4>:
    60b6:	4cfa 0000 	movs	YA, #0

000060ba <.LVL8>:
    60ba:	07df      	jmp	0x607a <.L6>

000060bc <.L5>:
    60bc:	4cfa 0010 	movs	YA, #16

000060c0 <.LVL10>:
    60c0:	07dc      	jmp	0x607a <.L6>

000060c2 <___pack_f>:
    60c2:	580d      	inc	S, #14

000060c4 <.LCFI0>:
    60c4:	7ee2      	lod	X, A

000060c6 <.LM2>:
    60c6:	7ae2      	lod	Y, A
    60c8:	e006      	add	Y, #6
    60ca:	72f0      	lod	A, [Y]

000060cc <.LVL1>:
    60cc:	5207      	mov	[S-8], A
    60ce:	72f2      	lod	A, [Y+2]
    60d0:	5205      	mov	[S-6], A

000060d2 <.LM3>:
    60d2:	72fa      	lod	A, [X+2]
    60d4:	520d      	mov	[S-14], A

000060d6 <.LM4>:
    60d6:	72f8      	lod	A, [X]

000060d8 <.LVL4>:
    60d8:	ac01      	cmp	A, #1
    60da:	1e29      	jug	0x612e <.L2>

000060dc <.LM5>:
    60dc:	58c2      	mov	D, [S-8]
    60de:	4886      	lsr	D, #7

000060e0 <.LM6>:
    60e0:	4c80      	mov	YA, D
    60e2:	f43f      	and	Y, #63

000060e4 <.LM7>:
    60e4:	e440      	or	Y, #64
    60e6:	58a2      	mov	[S-8], YA

000060e8 <.LM8>:
    60e8:	7ada 00ff 	lod	Y, #255
    60ec:	5a0b      	mov	[S-12], Y

000060ee <.L3>:
    60ee:	4cfa 0000 	movs	YA, #0
    60f2:	58a0      	mov	[S-4], YA
    60f4:	7a07      	lod	Y, [S-8]
    60f6:	5a03      	mov	[S-4], Y
    60f8:	7205      	lod	A, [S-6]
    60fa:	b47f      	and	A, #127
    60fc:	7e01      	lod	X, [S-2]
    60fe:	3480      	and	X, #-128
    6100:	a6ee      	or	A, X
    6102:	5201      	mov	[S-2], A

00006104 <.LM10>:
    6104:	620b      	lod	AL, [S-12]
    6106:	5cf2      	usex	A
    6108:	4862 0080 	mulu	A, A, #128
    610c:	7ae2      	lod	Y, A
    610e:	7e01      	lod	X, [S-2]
    6110:	36da 807f 	and	X, #32895
    6114:	e6ee      	or	Y, X
    6116:	5a01      	mov	[S-2], Y

00006118 <.LM11>:
    6118:	720d      	lod	A, [S-14]
    611a:	b401      	and	A, #1
    611c:	4452      	rr	A
    611e:	7ae2      	lod	Y, A
    6120:	7e01      	lod	X, [S-2]
    6122:	36da 7fff 	and	X, #32767
    6126:	e6ee      	or	Y, X
    6128:	5a01      	mov	[S-2], Y

0000612a <.LM12>:
    612a:	58e0      	mov	YA, [S-4]

0000612c <.LM13>:
    612c:	540f      	ret	#16

0000612e <.L2>:
    612e:	ac04      	cmp	A, #4
    6130:	1d01      	jne	0x6134 <.LM15>
    6132:	0073      	jmp	0x621a <.L16>

00006134 <.LM15>:
    6134:	ac02      	cmp	A, #2
    6136:	1d01      	jne	0x613a <.LM16>
    6138:	0067      	jmp	0x6208 <.L13>

0000613a <.LM16>:
    613a:	58c2      	mov	D, [S-8]
    613c:	4caa 0000 	cmpu	D, #0
    6140:	1d01      	jne	0x6144 <.LM17>
    6142:	0068      	jmp	0x6214 <.L14>

00006144 <.LM17>:
    6144:	7efc      	lod	X, [X+4]

00006146 <.LVL12>:
    6146:	2c82      	cmp	X, #-126
    6148:	1a81      	jsl	0x614c <.LBB10>
    614a:	0039      	jmp	0x61be <.L4>

0000614c <.LBB10>:
    614c:	7082      	lod	A, #-126
    614e:	aaee      	sub	A, X
    6150:	7ee2      	lod	X, A

00006152 <.LM19>:
    6152:	ac19      	cmp	A, #25
    6154:	1f2e      	jsg	0x61b2 <.L15>

00006156 <.LBB11>:
    6156:	4c80      	mov	YA, D

00006158 <.LVL15>:
    6158:	2c00      	cmp	X, #0
    615a:	1b04      	jsle	0x6164 <.L26>
    615c:	5edf      	push	X

0000615e <.L27>:
    615e:	48a0      	lsr	YA, #1
    6160:	1bfe      	djnz	X, 0x615e <.L27>
    6162:	7ecf      	pop	X

00006164 <.L26>:
    6164:	58a4      	mov	[S-12], YA

00006166 <.LM21>:
    6166:	4cfa ffff 	movs	YA, #65535
    616a:	2c00      	cmp	X, #0
    616c:	1b02      	jsle	0x6172 <.L28>

0000616e <.L29>:
    616e:	48e0      	asl	YA, #1
    6170:	1bfe      	djnz	X, 0x616e <.L29>

00006172 <.L28>:
    6172:	bcff      	xor	A, #-1
    6174:	fcff      	xor	Y, #-1
    6176:	b607      	and	A, [S-8]
    6178:	f605      	and	Y, [S-6]
    617a:	a6e6      	or	A, Y
    617c:	5ca2      	sne	A
    617e:	4cc8      	movu	D, A

00006180 <.LM22>:
    6180:	4c80      	mov	YA, D
    6182:	a60b      	or	A, [S-12]
    6184:	e609      	or	Y, [S-10]
    6186:	4cc0      	mov	D, YA

00006188 <.L5>:
    6188:	4c80      	mov	YA, D
    618a:	b47f      	and	A, #127
    618c:	7800      	lod	Y, #0
    618e:	4cb2 0040 	cmp	YA, #64
    6192:	0000 
    6194:	1d11      	jne	0x61b8 <.L6>

00006196 <.LM24>:
    6196:	4c80      	mov	YA, D
    6198:	9480      	and	AL, #-128
    619a:	1902      	je	0x61a0 <.L7>

0000619c <.LM25>:
    619c:	4c0a 0040 	addu	D, #64

000061a0 <.L7>:
    61a0:	4c92 ffff 	cmp	D, #1073741823
    61a4:	3fff 
    61a6:	5cb4      	sug	Y
    61a8:	5a0b      	mov	[S-12], Y

000061aa <.LM27>:
    61aa:	4c80      	mov	YA, D

000061ac <.L25>:
    61ac:	48a6      	lsr	YA, #7

000061ae <.LVL25>:
    61ae:	58a2      	mov	[S-8], YA

000061b0 <.LVL26>:
    61b0:	079e      	jmp	0x60ee <.L3>

000061b2 <.L15>:
    61b2:	4cda 0000 	movs	D, #0
    61b6:	07e8      	jmp	0x6188 <.L5>

000061b8 <.L6>:
    61b8:	4c0a 003f 	addu	D, #63
    61bc:	07f1      	jmp	0x61a0 <.L7>

000061be <.L4>:
    61be:	2c7f      	cmp	X, #127
    61c0:	1f2c      	jsg	0x621a <.L16>

000061c2 <.LM32>:
    61c2:	58e2      	mov	YA, [S-8]
    61c4:	b47f      	and	A, #127
    61c6:	7800      	lod	Y, #0
    61c8:	4cb2 0040 	cmp	YA, #64
    61cc:	0000 
    61ce:	1d10      	jne	0x61f0 <.L8>

000061d0 <.LM33>:
    61d0:	58e2      	mov	YA, [S-8]
    61d2:	9480      	and	AL, #-128
    61d4:	1904      	je	0x61de <.L9>

000061d6 <.LM34>:
    61d6:	58c2      	mov	D, [S-8]
    61d8:	4c0a 0040 	addu	D, #64

000061dc <.L23>:
    61dc:	5882      	mov	[S-8], D

000061de <.L9>:
    61de:	58c2      	mov	D, [S-8]
    61e0:	4caa 0000 	cmpu	D, #0
    61e4:	1a89      	jsl	0x61f8 <.L10>

000061e6 <.LM37>:
    61e6:	72ee      	lod	A, X
    61e8:	a07f      	add	A, #127
    61ea:	520b      	mov	[S-12], A

000061ec <.L11>:
    61ec:	58e2      	mov	YA, [S-8]
    61ee:	07de      	jmp	0x61ac <.L25>

000061f0 <.L8>:
    61f0:	58c2      	mov	D, [S-8]
    61f2:	4c0a 003f 	addu	D, #63
    61f6:	07f2      	jmp	0x61dc <.L23>

000061f8 <.L10>:
    61f8:	58e2      	mov	YA, [S-8]
    61fa:	48a0      	lsr	YA, #1
    61fc:	58a2      	mov	[S-8], YA

000061fe <.LM41>:
    61fe:	7aee      	lod	Y, X
    6200:	e2da 0080 	add	Y, #128
    6204:	5a0b      	mov	[S-12], Y

00006206 <.LVL37>:
    6206:	07f2      	jmp	0x61ec <.L11>

00006208 <.L13>:
    6208:	7000      	lod	A, #0
    620a:	520b      	mov	[S-12], A

0000620c <.L24>:
    620c:	4cda 0000 	movs	D, #0
    6210:	5882      	mov	[S-8], D

00006212 <.LVL40>:
    6212:	076d      	jmp	0x60ee <.L3>

00006214 <.L14>:
    6214:	7000      	lod	A, #0
    6216:	520b      	mov	[S-12], A
    6218:	076a      	jmp	0x60ee <.L3>

0000621a <.L16>:
    621a:	7ada 00ff 	lod	Y, #255
    621e:	5a0b      	mov	[S-12], Y
    6220:	07f5      	jmp	0x620c <.L24>

00006222 <___unpack_f>:
    6222:	5807      	inc	S, #8

00006224 <.LCFI0>:
    6224:	5201      	mov	[S-2], A

00006226 <.LM2>:
    6226:	7ee2      	lod	X, A
    6228:	72de      	lod	A, [X++]

0000622a <.LVL1>:
    622a:	5207      	mov	[S-8], A
    622c:	66f8      	lod	YL, [X]
    622e:	4603      	mov	[S-4], YL
    6230:	f47f      	and	Y, #127
    6232:	5a05      	mov	[S-6], Y

00006234 <.LM3>:
    6234:	7af8      	lod	Y, [X]

00006236 <.LM4>:
    6236:	7e01      	lod	X, [S-2]
    6238:	62fb      	lod	AL, [X+3]

0000623a <.LM5>:
    623a:	4440      	rl	AL
    623c:	9401      	and	AL, #1
    623e:	5cf2      	usex	A

00006240 <.LM6>:
    6240:	7e0b      	lod	X, [S-12]

00006242 <.LM7>:
    6242:	52fa      	mov	[X+2], A

00006244 <.LM8>:
    6244:	72e6      	lod	A, Y
    6246:	44b2      	lsr	A, #2
    6248:	44b2      	lsr	A, #2
    624a:	44b2      	lsr	A, #2
    624c:	4432      	lsr	A
    624e:	b6da 00ff 	and	A, #255

00006252 <.LVL4>:
    6252:	f6da 7f80 	and	Y, #32640
    6256:	1d19      	jne	0x628a <.L2>

00006258 <.LM9>:
    6258:	58c2      	mov	D, [S-8]
    625a:	4caa 0000 	cmpu	D, #0
    625e:	1d03      	jne	0x6266 <.L3>

00006260 <.LM10>:
    6260:	7002      	lod	A, #2

00006262 <.L12>:
    6262:	52f8      	mov	[X], A
    6264:	5409      	ret	#10

00006266 <.L3>:
    6266:	58c2      	mov	D, [S-8]

00006268 <.LVL7>:
    6268:	48c6      	asl	D, #7

0000626a <.LM13>:
    626a:	7e0b      	lod	X, [S-12]
    626c:	7803      	lod	Y, #3
    626e:	5af8      	mov	[X], Y
    6270:	7c81      	lod	X, #-127

00006272 <.L5>:
    6272:	48c0      	asl	D, #1

00006274 <.LM15>:
    6274:	7aee      	lod	Y, X
    6276:	20ff      	add	X, #-1

00006278 <.LM16>:
    6278:	4c92 ffff 	cmp	D, #1073741823
    627c:	3fff 
    627e:	1a79      	jule	0x6272 <.L5>
    6280:	7e0b      	lod	X, [S-12]
    6282:	5afc      	mov	[X+4], Y

00006284 <.LM17>:
    6284:	2006      	add	X, #6
    6286:	4c87      	mov	[X], D
    6288:	5409      	ret	#10

0000628a <.L2>:
    628a:	aeda 00ff 	cmp	A, #255
    628e:	1d1c      	jne	0x62c8 <.L6>

00006290 <.LM19>:
    6290:	58c2      	mov	D, [S-8]
    6292:	4caa 0000 	cmpu	D, #0
    6296:	1d03      	jne	0x629e <.L7>

00006298 <.LM20>:
    6298:	7e0b      	lod	X, [S-12]
    629a:	7004      	lod	A, #4

0000629c <.LVL11>:
    629c:	07e2      	jmp	0x6262 <.L12>

0000629e <.L7>:
    629e:	58e2      	mov	YA, [S-8]

000062a0 <.LVL13>:
    62a0:	7000      	lod	A, #0
    62a2:	f440      	and	Y, #64

000062a4 <.LM22>:
    62a4:	7e0b      	lod	X, [S-12]

000062a6 <.LM23>:
    62a6:	4cb2 0000 	cmp	YA, #0
    62aa:	0000 
    62ac:	190b      	je	0x62c4 <.L8>

000062ae <.LM24>:
    62ae:	7001      	lod	A, #1

000062b0 <.L11>:
    62b0:	52f8      	mov	[X], A

000062b2 <.LM26>:
    62b2:	7e0b      	lod	X, [S-12]
    62b4:	2006      	add	X, #6
    62b6:	58e2      	mov	YA, [S-8]
    62b8:	48e6      	asl	YA, #7
    62ba:	9480      	and	AL, #-128
    62bc:	f6da dfff 	and	Y, #57343

000062c0 <.L13>:
    62c0:	4ca7      	mov	[X], YA

000062c2 <.LM28>:
    62c2:	5409      	ret	#10

000062c4 <.L8>:
    62c4:	7000      	lod	A, #0
    62c6:	07f4      	jmp	0x62b0 <.L11>

000062c8 <.L6>:
    62c8:	a081      	add	A, #-127

000062ca <.LVL18>:
    62ca:	7e0b      	lod	X, [S-12]
    62cc:	52fc      	mov	[X+4], A

000062ce <.LM31>:
    62ce:	7003      	lod	A, #3
    62d0:	52f8      	mov	[X], A

000062d2 <.LM32>:
    62d2:	2006      	add	X, #6
    62d4:	58e2      	mov	YA, [S-8]
    62d6:	48e6      	asl	YA, #7
    62d8:	e6da 4000 	or	Y, #16384
    62dc:	07f1      	jmp	0x62c0 <.L13>

000062de <___fpcmp_parts_f>:
    62de:	5803      	inc	S, #4

000062e0 <.LCFI0>:
    62e0:	5201      	mov	[S-2], A

000062e2 <.LM2>:
    62e2:	7ee2      	lod	X, A
    62e4:	72f8      	lod	A, [X]

000062e6 <.LVL1>:
    62e6:	ac01      	cmp	A, #1
    62e8:	1a14      	jule	0x6312 <.L22>

000062ea <.LM3>:
    62ea:	7e07      	lod	X, [S-8]

000062ec <.LM4>:
    62ec:	7af8      	lod	Y, [X]
    62ee:	ec01      	cmp	Y, #1
    62f0:	1a10      	jule	0x6312 <.L22>

000062f2 <.LM5>:
    62f2:	ac04      	cmp	A, #4
    62f4:	1d09      	jne	0x6308 <.L3>
    62f6:	7e01      	lod	X, [S-2]
    62f8:	72fa      	lod	A, [X+2]

000062fa <.LM6>:
    62fa:	ec04      	cmp	Y, #4
    62fc:	1d16      	jne	0x632a <.L33>

000062fe <.LM7>:
    62fe:	7e07      	lod	X, [S-8]
    6300:	7efa      	lod	X, [X+2]
    6302:	2ae2      	sub	X, A
    6304:	72ee      	lod	A, X
    6306:	5405      	ret	#6

00006308 <.L3>:
    6308:	ec04      	cmp	Y, #4
    630a:	1d05      	jne	0x6316 <.L5>

0000630c <.L7>:
    630c:	7e07      	lod	X, [S-8]
    630e:	72fa      	lod	A, [X+2]
    6310:	190e      	je	0x632e <.L24>

00006312 <.L22>:
    6312:	7001      	lod	A, #1
    6314:	5405      	ret	#6

00006316 <.L5>:
    6316:	ac02      	cmp	A, #2
    6318:	1d04      	jne	0x6322 <.L6>

0000631a <.LM12>:
    631a:	ec02      	cmp	Y, #2
    631c:	1d77      	jne	0x630c <.L7>

0000631e <.L23>:
    631e:	7000      	lod	A, #0
    6320:	5405      	ret	#6

00006322 <.L6>:
    6322:	7e01      	lod	X, [S-2]
    6324:	72fa      	lod	A, [X+2]

00006326 <.LM14>:
    6326:	ec02      	cmp	Y, #2
    6328:	1d04      	jne	0x6332 <.L8>

0000632a <.L33>:
    632a:	ac00      	cmp	A, #0
    632c:	1972      	je	0x6312 <.L22>

0000632e <.L24>:
    632e:	70ff      	lod	A, #-1

00006330 <.LM17>:
    6330:	5405      	ret	#6

00006332 <.L8>:
    6332:	7e07      	lod	X, [S-8]
    6334:	7efa      	lod	X, [X+2]
    6336:	5e03      	mov	[S-4], X
    6338:	2ee2      	cmp	X, A
    633a:	1d77      	jne	0x632a <.L33>

0000633c <.LM19>:
    633c:	7e01      	lod	X, [S-2]
    633e:	7afc      	lod	Y, [X+4]
    6340:	7e07      	lod	X, [S-8]
    6342:	72fc      	lod	A, [X+4]
    6344:	eee2      	cmp	Y, A
    6346:	1b02      	jsle	0x634c <.L10>

00006348 <.L35>:
    6348:	7203      	lod	A, [S-4]
    634a:	07ef      	jmp	0x632a <.L33>

0000634c <.L10>:
    634c:	eee2      	cmp	Y, A
    634e:	1e83      	jsge	0x6356 <.L11>

00006350 <.L27>:
    6350:	7e03      	lod	X, [S-4]
    6352:	1d5f      	jne	0x6312 <.L22>
    6354:	07ec      	jmp	0x632e <.L24>

00006356 <.L11>:
    6356:	7e01      	lod	X, [S-2]
    6358:	2006      	add	X, #6
    635a:	4cc7      	mov	D, [X]
    635c:	7e07      	lod	X, [S-8]
    635e:	2006      	add	X, #6
    6360:	4ce7      	mov	YA, [X]
    6362:	4c90      	cmp	D, YA
    6364:	1e71      	jug	0x6348 <.L35>

00006366 <.LM24>:
    6366:	1874      	jc	0x6350 <.L27>
    6368:	07da      	jmp	0x631e <.L23>

0000636a <_AppLinInit>:
    636a:	6000      	lod	AL, #0
    636c:	42d8 10ad 	mov	0x10ad <_Fwv_lin_sleep_enable>, AL

00006370 <.LM3>:
    6370:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

00006374 <.LM4>:
    6374:	5401      	ret

00006376 <_AppLinTask>:
}

void AppLinTask(void)
{

	if (g_u8LinErrorCnt > (uint8_t)3u)
    6376:	62d8 1187 	lod	AL, 0x1187 <_g_u8LinErrorCnt>
    637a:	8c03      	cmp	AL, #3
    637c:	1a03      	jule	0x6384 <.L3>

0000637e <.LM7>:
	{
		Fwv_lin_frame_Error = 1;
    637e:	6001      	lod	AL, #1
    6380:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

00006384 <.L3>:
L_FLAGS(l_sl1_flags.mapped, s_d_debug_1, signal, d_debug_1)
L_FLAGS(l_sl1_flags.mapped, s_d_debug_2, signal, d_debug_2)

L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Resp, frame, VPC_Fwv_Resp)
L_FLAGS(l_sl1_flags.mapped, f_Debug_Frame, frame, Debug_Frame)
L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Ctrl, frame, VPC_Fwv_Ctrl)
    6384:	62d8 13fd 	lod	AL, 0x13fd <_l_sl1_flags+0x3>

00006388 <.LBE36>:
	}

	/* VPC_Fwv_Master Frame handling */
	if (l_flg_tst_f_VPC_Fwv_Ctrl() != 0u)
    6388:	9440      	and	AL, #64
    638a:	1915      	je	0x63b6 <.L4>

0000638c <.LBB38>:
    638c:	82db 48c5 	callf	0x918a <_l_sys_irq_disable>
    6390:	7ee2      	lod	X, A

00006392 <.LVL1>:
    6392:	62d8 13fd 	lod	AL, 0x13fd <_l_sl1_flags+0x3>

00006396 <.LVL2>:
    6396:	94bf      	and	AL, #-65
    6398:	42d8 13fd 	mov	0x13fd <_l_sl1_flags+0x3>, AL
    639c:	72ee      	lod	A, X
    639e:	82db 48cd 	callf	0x919a <_l_sys_irq_restore>

000063a2 <.LBE38>:
	{
		l_flg_clr_f_VPC_Fwv_Ctrl();
		ValveLinGetCommand();
    63a2:	1278      	call	0x6894 <_ValveLinGetCommand>

000063a4 <.LM12>:
		Fwv_Request_Event = 1;
    63a4:	6001      	lod	AL, #1
    63a6:	42d8 10ab 	mov	0x10ab <_Fwv_Request_Event>, AL

000063aa <.LM13>:
		g_u8LinErrorCnt = 0;
    63aa:	6000      	lod	AL, #0
    63ac:	0ea7      	lod	C, ML.7
    63ae:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

000063b2 <.LM14>:
		Fwv_lin_frame_Error = 0;
    63b2:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

000063b6 <.L4>:
L_FLAGS(l_sl1_flags.mapped, s_d_valve_status, signal, d_valve_status)
L_FLAGS(l_sl1_flags.mapped, s_d_motor_status, signal, d_motor_status)
L_FLAGS(l_sl1_flags.mapped, s_d_debug_1, signal, d_debug_1)
L_FLAGS(l_sl1_flags.mapped, s_d_debug_2, signal, d_debug_2)

L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Resp, frame, VPC_Fwv_Resp)
    63b6:	62d8 13fd 	lod	AL, 0x13fd <_l_sl1_flags+0x3>

000063ba <.LBE40>:
	}

	/* VPC_Fwv_Slave Frame handling */
	if (l_flg_tst_f_VPC_Fwv_Resp() != 0u)
    63ba:	9410      	and	AL, #16
    63bc:	1915      	je	0x63e8 <.L5>

000063be <.LBB42>:
    63be:	82db 48c5 	callf	0x918a <_l_sys_irq_disable>
    63c2:	7ee2      	lod	X, A

000063c4 <.LVL6>:
    63c4:	62d8 13fd 	lod	AL, 0x13fd <_l_sl1_flags+0x3>

000063c8 <.LVL7>:
    63c8:	94ef      	and	AL, #-17
    63ca:	42d8 13fd 	mov	0x13fd <_l_sl1_flags+0x3>, AL
    63ce:	72ee      	lod	A, X
    63d0:	82db 48cd 	callf	0x919a <_l_sys_irq_restore>

000063d4 <.LBE42>:
	{
		l_flg_clr_f_VPC_Fwv_Resp();
		ValveLinUpdateSignals();
    63d4:	128d      	call	0x68f0 <_ValveLinUpdateSignals>

000063d6 <.LM19>:
		Fwv_Response_Event = 1;
    63d6:	6001      	lod	AL, #1
    63d8:	42d8 10aa 	mov	0x10aa <__data_end>, AL

000063dc <.LM20>:
		g_u8LinErrorCnt = 0;
    63dc:	6000      	lod	AL, #0
    63de:	0ea7      	lod	C, ML.7
    63e0:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

000063e4 <.LM21>:
		Fwv_lin_frame_Error = 0;
    63e4:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

000063e8 <.L5>:
L_FLAGS(l_sl1_flags.mapped, f_Debug_Frame, frame, Debug_Frame)
    63e8:	62d8 13fd 	lod	AL, 0x13fd <_l_sl1_flags+0x3>

000063ec <.LBE44>:
	}
#if LIN_DEBUG_ENABLE
	/* DEBUG1_FRAME handling */
	if (l_flg_tst_f_Debug_Frame() != 0u)
    63ec:	9420      	and	AL, #32
    63ee:	191d      	je	0x642a <.L6>

000063f0 <.LBB46>:
    63f0:	82db 48c5 	callf	0x918a <_l_sys_irq_disable>
    63f4:	7ee2      	lod	X, A

000063f6 <.LVL11>:
    63f6:	62d8 13fd 	lod	AL, 0x13fd <_l_sl1_flags+0x3>

000063fa <.LVL12>:
    63fa:	94df      	and	AL, #-33
    63fc:	42d8 13fd 	mov	0x13fd <_l_sl1_flags+0x3>, AL
    6400:	72ee      	lod	A, X
    6402:	82db 48cd 	callf	0x919a <_l_sys_irq_restore>

00006406 <.LBB48>:
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
L_SIGNAL(l_u16, Fwv_SW_Version)
L_SIGNAL(l_u8, Fwv_Stall_State)
L_SIGNAL(l_u8, d_valve_status)
    6406:	62d8 11ba 	lod	AL, 0x11ba <_g_u16DebugData>
    640a:	42d8 11ad 	mov	0x11ad <_l_signals+0x19>, AL

0000640e <.LBB50>:
L_SIGNAL(l_u8, d_motor_status)
    640e:	62d8 11bc 	lod	AL, 0x11bc <_g_u16DebugData+0x2>
    6412:	0ea7      	lod	C, ML.7
    6414:	42d8 11ae 	mov	0x11ae <_l_signals+0x1a>, AL

00006418 <.LBB52>:
L_SIGNAL(l_u16, d_debug_1)
    6418:	72d8 11be 	lod	A, 0x11be <_g_u16DebugData+0x4>
    641c:	52d8 11b0 	mov	0x11b0 <_l_signals+0x1c>, A

00006420 <.LBB54>:
L_SIGNAL(l_u8, d_debug_2)
    6420:	0ea7      	lod	C, ML.7
    6422:	62d8 11c0 	lod	AL, 0x11c0 <.LASF1797>
    6426:	42d8 11b2 	mov	0x11b2 <.LASF0>, AL

0000642a <.L6>:
		l_u8_wr_DEBUG1_U8_8((uint8_t)(g_u16DebugData[3] >> 8));
		*/
	}
#endif
	/* do lin period (non time critical) stuff */
	lin22_BackgroundHandler();
    642a:	76da 47c8 	jmpf	0x8f90 <_lin22_BackgroundHandler>

0000642e <_AppLinSleepEnter>:
}

void AppLinSleepEnter(void)
{
	Fwv_lin_sleep_enable = 1;
    642e:	6001      	lod	AL, #1
    6430:	42d8 10ad 	mov	0x10ad <_Fwv_lin_sleep_enable>, AL

00006434 <.LM33>:
	lin22_GotoSleep(); /* switch to sleep mode */
    6434:	76da 47fa 	jmpf	0x8ff4 <_lin22_GotoSleep>

00006438 <_check_protect_mode>:
	return status;
}
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
    6438:	72d8 1256 	lod	A, 0x1256 <.LASF1692+0xb>
    643c:	a0ff      	add	A, #-1
    643e:	ac01      	cmp	A, #1
    6440:	1a1e      	jule	0x647e <.L8>

00006442 <.LM3>:
    6442:	72d8 1268 	lod	A, 0x1268 <.LLST28+0x9>

00006446 <.LM4>:
	}
	return status;
}
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
    6446:	ac02      	cmp	A, #2
    6448:	5c8e      	se	X

0000644a <.L2>:
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
	{
		status = 1;
	}
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    644a:	62d8 1287 	lod	AL, 0x1287 <.LASF1443+0xb>
    644e:	9401      	and	AL, #1
    6450:	1901      	je	0x6454 <.L3>

00006452 <.LM6>:
	{
		status = 1;
    6452:	7c01      	lod	X, #1

00006454 <.L3>:
	}
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    6454:	62d8 1286 	lod	AL, 0x1286 <.LASF1443+0xa>
    6458:	9440      	and	AL, #64
    645a:	1901      	je	0x645e <.L4>

0000645c <.LM8>:
	{
		status = 1;
    645c:	7c01      	lod	X, #1

0000645e <.L4>:
	}
	if (valve.diag.McuFault != 0)
    645e:	62d8 1281 	lod	AL, 0x1281 <.LASF1443+0x5>
    6462:	1901      	je	0x6466 <.L5>

00006464 <.LM10>:
	{
		status = 1;
    6464:	7c01      	lod	X, #1

00006466 <.L5>:
	}
#if 1
	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
    6466:	62d8 1276 	lod	AL, 0x1276 <.LLST29+0x4>
    646a:	1d0b      	jne	0x6482 <.L10>

0000646c <.LM12>:
    646c:	62d8 122c 	lod	AL, 0x122c <.LLST5>
    6470:	1d08      	jne	0x6482 <.L10>

00006472 <.L6>:
	{
		status = 1;
	}
#endif
	if (valve.linLiveTimeOut == 0)
    6472:	72d8 121a 	lod	A, 0x121a <.LASF1421+0x1>
    6476:	1d01      	jne	0x647a <.L1>

00006478 <.LM14>:
	{
		status = 1;
    6478:	7c01      	lod	X, #1

0000647a <.L1>:
	}
	return status;
}
    647a:	72ee      	lod	A, X
    647c:	5401      	ret

0000647e <.L8>:
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
	{
		status = 1;
    647e:	7c01      	lod	X, #1
    6480:	07e4      	jmp	0x644a <.L2>

00006482 <.L10>:
		status = 1;
	}
#if 1
	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
	{
		status = 1;
    6482:	7c01      	lod	X, #1

00006484 <.LVL9>:
    6484:	07f6      	jmp	0x6472 <.L6>

00006486 <_check_fault_mode>:
	return nextState;
}
static uint16_t check_fault_mode(void)
{
	uint16_t status = 0;
	if (valve.motorMotion == MOTION_FAULT)
    6486:	72d8 1222 	lod	A, 0x1222 <.LASF1421+0x9>
    648a:	ac07      	cmp	A, #7
    648c:	1d05      	jne	0x6498 <.L21>

0000648e <.LM20>:

		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0)
		{
			status = 1;
		}
		else if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0)
    648e:	62d8 1286 	lod	AL, 0x1286 <.LASF1443+0xa>
    6492:	9411      	and	AL, #17

00006494 <.LM21>:
		{
			status = 1;
    6494:	5ca2      	sne	A
    6496:	5401      	ret

00006498 <.L21>:
		else
		{
			status = 0;
		}
	}
	else if (valve.motorMotion == MOTION_STALL)
    6498:	ac06      	cmp	A, #6
    649a:	1d0a      	jne	0x64b0 <.L24>

0000649c <.LM23>:
	{

		if (valve.state != VALVE_CALIBRATION)
    649c:	72d8 1216 	lod	A, 0x1216 <_valve>
    64a0:	ac05      	cmp	A, #5
    64a2:	1906      	je	0x64b0 <.L24>

000064a4 <.LBB163>:
		{
			if ((valve.diag.stallFault & STALL_MASK_PERMENT) != 0)
    64a4:	62d8 1287 	lod	AL, 0x1287 <.LASF1443+0xb>
    64a8:	4430      	lsr	AL
    64aa:	9401      	and	AL, #1
    64ac:	5cf2      	usex	A
    64ae:	5401      	ret

000064b0 <.L24>:
			status = 0;
		}
	}
	else
	{
		status = 0;
    64b0:	7000      	lod	A, #0

000064b2 <.LM26>:
	}
	return status;
}
    64b2:	5401      	ret

000064b4 <_clear_fail_safe_retry_cnt>:
 *
 * @param event_state The protection condition event (tProtectCondition) for which the counter should be cleared.
 */
void clear_fail_safe_retry_cnt(tProtectCondition event_state)
{
	switch(event_state)
    64b4:	a0ff      	add	A, #-1

000064b6 <.LVL12>:
    64b6:	ac0c      	cmp	A, #12
    64b8:	1e34      	jug	0x6522 <.L25>
    64ba:	4422      	asl	A
    64bc:	7ee2      	lod	X, A
    64be:	22da 5cc2 	add	X, #23746
    64c2:	76f8      	jmp	[X]

000064c4 <.L27>:
	{
		/* --- Protection state Errors --- */
		case VS_LOW_ERROR :
			valve.diag.vs.UVretryCnt = CLEAR;	// Clear Under Voltage retry count
    64c4:	7000      	lod	A, #0
    64c6:	52d8 125e 	mov	0x125e <.LASF1692+0x13>, A

000064ca <.LM30>:
			break;
    64ca:	5401      	ret

000064cc <.L29>:
		case VS_HIGH_ERROR : 
			valve.diag.vs.OVretryCnt = CLEAR;	// Clear Over Voltage retry count
    64cc:	7000      	lod	A, #0
    64ce:	52d8 1260 	mov	0x1260 <.LLST28+0x1>, A

000064d2 <.LM32>:
			break;
    64d2:	5401      	ret

000064d4 <.L30>:
		case MOT_OC_ERROR : 
			valve.diag.motOcRetryCnt = CLEAR;	// Clear Motor Over Current retry count
    64d4:	6000      	lod	AL, #0
    64d6:	42d8 128a 	mov	0x128a <.LASF1443+0xe>, AL

000064da <.LM34>:
			break;
    64da:	5401      	ret

000064dc <.L31>:
		case MOT_ABSTALL_ERROR : 
			valve.diag.ObstructionRetryCnt = CLEAR;	// Clear Motor  Obstruction stall retry count
    64dc:	6000      	lod	AL, #0
    64de:	42d8 1284 	mov	0x1284 <.LASF1443+0x8>, AL

000064e2 <.LM36>:
			break;
    64e2:	5401      	ret

000064e4 <.L32>:
		case SENSOR_POS_ERROR : 
			valve.pos.retryCnt = CLEAR;	// Clear Valve Position Sensor retry count (Angle deviation/Out of tolerance)
    64e4:	6000      	lod	AL, #0
    64e6:	42d8 122d 	mov	0x122d <.LLST5+0x1>, AL

000064ea <.LM38>:
			break;
    64ea:	5401      	ret

000064ec <.L33>:
		case SENSOR_OUT_ERROR : 
			valve.diag.gmr.retryCnt = CLEAR;	// Clear GMR Sensor Out-of-range retry count (No valid signal/Value not received)
    64ec:	7000      	lod	A, #0
    64ee:	52d8 1278 	mov	0x1278 <.LLST29+0x6>, A

000064f2 <.LM40>:
			break;
    64f2:	5401      	ret

000064f4 <.L34>:
		case MCU_ERROR : 
			valve.diag.mcuRetryCnt = CLEAR;	// Clear Microcontroller internal error retry count
    64f4:	7000      	lod	A, #0
    64f6:	52d8 1282 	mov	0x1282 <.LASF1443+0x6>, A

000064fa <.LM42>:
			break;
    64fa:	5401      	ret

000064fc <.L39>:
		case VALVE_LIN_COMM_FAULT : 
			valve.diag.comm.linErrRetryCnt = CLEAR;	// Clear LIN Communication Error retry count
    64fc:	7000      	lod	A, #0
    64fe:	52d8 1264 	mov	0x1264 <.LLST28+0x5>, A

00006502 <.LM44>:
			break;
    6502:	5401      	ret

00006504 <.L35>:

		/* --- Fault state Errors --- */
		case VALVE_CAL_FAULT : 
			valve.diag.calRetryCnt = CLEAR;	// Clear Valve Calibration failure retry count
    6504:	6000      	lod	AL, #0
    6506:	42d8 1289 	mov	0x1289 <.LASF1443+0xd>, AL

0000650a <.LM46>:
			break;
    650a:	5401      	ret

0000650c <.L36>:
		case MOT_STALL_FAULT : 
			valve.diag.stallRetryCnt = CLEAR;	// Clear Motor Stall Fault retry count
    650c:	6000      	lod	AL, #0
    650e:	42d8 1288 	mov	0x1288 <.LASF1443+0xc>, AL

00006512 <.LM48>:
			break;
    6512:	5401      	ret

00006514 <.L37>:
		case MOT_SHORT_FAULT : 
			valve.diag.motShortRetryCnt = CLEAR;	// Clear Motor Short Circuit Fault retry count
    6514:	6000      	lod	AL, #0
    6516:	42d8 128c 	mov	0x128c <.LASF1443+0x10>, AL

0000651a <.LM50>:
			break;
    651a:	5401      	ret

0000651c <.L38>:
		case MOT_OPEN_FAULT : 
			valve.diag.motOpenRetryCnt  = CLEAR;	// Clear Motor Open Circuit Fault retry count
    651c:	6000      	lod	AL, #0
    651e:	42d8 128b 	mov	0x128b <.LASF1443+0xf>, AL

00006522 <.L25>:
			break;

		default:
			break;
	}
}
    6522:	5401      	ret

00006524 <_ValveFaultReset>:

static void ValveFaultReset(void)
{
    6524:	5801      	inc	S, #2

00006526 <.LCFI0>:
	uint8_t i = 0;

	u16EventState = NONE_ERROR;
    6526:	7800      	lod	Y, #0
    6528:	5ad8 10b6 	mov	0x10b6 <_u16EventState>, Y

0000652c <.LM55>:
	valve.comm.faultMode = 0;
    652c:	46d8 1245 	mov	0x1245 <.LLST27+0x6>, YL

00006530 <.LM56>:
	MotClearFaultFlag(0);
    6530:	72e6      	lod	A, Y
    6532:	5a01      	mov	[S-2], Y
    6534:	82db 3f4d 	callf	0x7e9a <_MotClearFaultFlag>

00006538 <.LM57>:
	MotClearStallFlag(0);
    6538:	7a01      	lod	Y, [S-2]
    653a:	72e6      	lod	A, Y
    653c:	82db 3f3e 	callf	0x7e7c <_MotClearStallFlag>

00006540 <.LM58>:
	valve.pos.fault = 0;
    6540:	7a01      	lod	Y, [S-2]
    6542:	46d8 122c 	mov	0x122c <.LLST5>, YL

00006546 <.LM59>:
	valve.diag.gmr.state = 0;
    6546:	46d8 1276 	mov	0x1276 <.LLST29+0x4>, YL

0000654a <.LM60>:
	valve.diag.McuFault = 0;
    654a:	46d8 1281 	mov	0x1281 <.LASF1443+0x5>, YL
    654e:	0ea7      	lod	C, ML.7
    6550:	7801      	lod	Y, #1

00006552 <.L41>:


	for(i=1; i<14; i++)
	{
		clear_fail_safe_retry_cnt(i);
    6552:	72e6      	lod	A, Y
    6554:	5a01      	mov	[S-2], Y
    6556:	17ae      	call	0x64b4 <_clear_fail_safe_retry_cnt>

00006558 <.LM62>:
	valve.pos.fault = 0;
	valve.diag.gmr.state = 0;
	valve.diag.McuFault = 0;


	for(i=1; i<14; i++)
    6558:	7a01      	lod	Y, [S-2]
    655a:	e001      	add	Y, #1
    655c:	ec0e      	cmp	Y, #14
    655e:	1d79      	jne	0x6552 <.L41>

00006560 <.LM63>:
	valve.diag.mcuRetryCnt = 0;
	valve.diag.vs.UVretryCnt = 0;
	valve.diag.vs.OVretryCnt = 0;
	valve.diag.temp.retryCnt = 0;
	*/
}
    6560:	5403      	ret	#4

00006562 <_check_retry_cnt_protection_uv>:
 * @param void No input parameters are used for this function.
 * @retval void This function does not return a value.
 */
void check_retry_cnt_protection_uv(void)
{
	if (valve.diag.vs.state == VS_UNDERVOLTAGE)
    6562:	72d8 1256 	lod	A, 0x1256 <.LASF1692+0xb>
    6566:	ac01      	cmp	A, #1
    6568:	1d0b      	jne	0x6580 <.L43>

0000656a <.LBB170>:
	return result_data;
}

void event_memry_save(tProtectCondition event_state, uint16_t event_value)
{
	u16EventState = event_state;
    656a:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000656e <.LM67>:
	u16EventValue = event_value;
    656e:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00006572 <.LBE170>:
{
	if (valve.diag.vs.state == VS_UNDERVOLTAGE)
	{
		event_memry_save(VS_LOW_ERROR, valve.diag.vs.state);

		if (valve.diag.vs.UVretryCnt < MAX_VALUE_2BYTE)
    6572:	72d8 125e 	lod	A, 0x125e <.LASF1692+0x13>
    6576:	acff      	cmp	A, #-1
    6578:	1903      	je	0x6580 <.L43>

0000657a <.LM69>:
		{
			valve.diag.vs.UVretryCnt++;
    657a:	a001      	add	A, #1
    657c:	52d8 125e 	mov	0x125e <.LASF1692+0x13>, A

00006580 <.L43>:
		}
	}
}
    6580:	5401      	ret

00006582 <_check_retry_cnt_protection_ov>:
 * @param void No input parameters are used for this function.
 * @retval void This function does not return a value.
 */
void check_retry_cnt_protection_ov(void)
{
	if (valve.diag.vs.state == VS_OVERVOLTAGE)
    6582:	72d8 1256 	lod	A, 0x1256 <.LASF1692+0xb>
    6586:	ac02      	cmp	A, #2
    6588:	1d0b      	jne	0x65a0 <.L50>

0000658a <.LBB178>:
	return result_data;
}

void event_memry_save(tProtectCondition event_state, uint16_t event_value)
{
	u16EventState = event_state;
    658a:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000658e <.LM74>:
	u16EventValue = event_value;
    658e:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00006592 <.LBE178>:
{
	if (valve.diag.vs.state == VS_OVERVOLTAGE)
	{
		event_memry_save(VS_HIGH_ERROR, valve.diag.vs.state);

		if (valve.diag.vs.OVretryCnt < MAX_VALUE_2BYTE)
    6592:	72d8 1260 	lod	A, 0x1260 <.LLST28+0x1>
    6596:	acff      	cmp	A, #-1
    6598:	1903      	je	0x65a0 <.L50>

0000659a <.LM76>:
		{
			valve.diag.vs.OVretryCnt++;
    659a:	a001      	add	A, #1
    659c:	52d8 1260 	mov	0x1260 <.LLST28+0x1>, A

000065a0 <.L50>:
		}
	}
}
    65a0:	5401      	ret

000065a2 <_check_protection_uv_ov>:
 * @brief Handles Under Voltage (UV) and Over Voltage (OV) protection; transitions to VALVE_FAULT if either fault persists (600ms).
 * @param result_data Current protection check status containing status and next state suggestion.
 * @retval Protectoin_Check_Result Updated result data after checking voltage supply fault status.
 */
Protectoin_Check_Result check_protection_uv_ov(Protectoin_Check_Result result_data)
{
    65a2:	5803      	inc	S, #4

000065a4 <.LCFI1>:
    65a4:	5203      	mov	[S-4], A

000065a6 <.LM79>:
	if (valve.diag.vs.state != VS_NORMAL)
    65a6:	72d8 1256 	lod	A, 0x1256 <.LASF1692+0xb>

000065aa <.LVL25>:
    65aa:	1d09      	jne	0x65be <.L58>
    65ac:	6203      	lod	AL, [S-4]
    65ae:	5cf2      	usex	A

000065b0 <.L59>:
			clear_fail_safe_retry_cnt(VS_HIGH_ERROR);
			result_data.next_state = VALVE_FAULT;
		}
	}

	return result_data;
    65b0:	7e03      	lod	X, [S-4]
    65b2:	36da ff00 	and	X, #65280
    65b6:	26e2      	or	X, A
    65b8:	5e03      	mov	[S-4], X

000065ba <.LM81>:
}
    65ba:	72ee      	lod	A, X
    65bc:	5405      	ret	#6

000065be <.L58>:
{
	if (valve.diag.vs.state != VS_NORMAL)
	{
		result_data.status = 0;

		check_retry_cnt_protection_uv();
    65be:	5a01      	mov	[S-2], Y
    65c0:	17d0      	call	0x6562 <_check_retry_cnt_protection_uv>

000065c2 <.LM83>:
		check_retry_cnt_protection_ov();
    65c2:	17df      	call	0x6582 <_check_retry_cnt_protection_ov>

000065c4 <.LM84>:
		
		if (valve.diag.vs.UVretryCnt >= CHECK_UNDER_VOLTAGE_CNT)
    65c4:	72d8 125e 	lod	A, 0x125e <.LASF1692+0x13>
    65c8:	7a01      	lod	Y, [S-2]
    65ca:	aeda 0257 	cmp	A, #599
    65ce:	1a04      	jule	0x65d8 <.L60>

000065d0 <.LBB180>:
{
	switch(event_state)
	{
		/* --- Protection state Errors --- */
		case VS_LOW_ERROR :
			valve.diag.vs.UVretryCnt = CLEAR;	// Clear Under Voltage retry count
    65d0:	7000      	lod	A, #0
    65d2:	52d8 125e 	mov	0x125e <.LASF1692+0x13>, A

000065d6 <.LBE180>:
		check_retry_cnt_protection_ov();
		
		if (valve.diag.vs.UVretryCnt >= CHECK_UNDER_VOLTAGE_CNT)
		{
			clear_fail_safe_retry_cnt(VS_LOW_ERROR);
			result_data.next_state = VALVE_FAULT;
    65d6:	7806      	lod	Y, #6

000065d8 <.L60>:
    65d8:	7000      	lod	A, #0

000065da <.LM87>:
		}

		if (valve.diag.vs.OVretryCnt > CHECK_OVER_VOLTAGE_CNT)
    65da:	7ed8 1260 	lod	X, 0x1260 <.LLST28+0x1>
    65de:	2eda 0258 	cmp	X, #600
    65e2:	1a66      	jule	0x65b0 <.L59>

000065e4 <.LBB182>:
		/* --- Protection state Errors --- */
		case VS_LOW_ERROR :
			valve.diag.vs.UVretryCnt = CLEAR;	// Clear Under Voltage retry count
			break;
		case VS_HIGH_ERROR : 
			valve.diag.vs.OVretryCnt = CLEAR;	// Clear Over Voltage retry count
    65e4:	52d8 1260 	mov	0x1260 <.LLST28+0x1>, A

000065e8 <.LBE182>:
		}

		if (valve.diag.vs.OVretryCnt > CHECK_OVER_VOLTAGE_CNT)
		{
			clear_fail_safe_retry_cnt(VS_HIGH_ERROR);
			result_data.next_state = VALVE_FAULT;
    65e8:	7806      	lod	Y, #6
    65ea:	07e2      	jmp	0x65b0 <.L59>

000065ec <_check_protection_temp>:
 * @brief Checks the valve's temperature state and fails the protection check if the temperature is abnormal.
 * @param result_data Current protection check status containing status and next state suggestion.
 * @retval Protectoin_Check_Result Updated result data after checking temperature status.
 */
Protectoin_Check_Result check_protection_temp(Protectoin_Check_Result result_data)
{
    65ec:	5801      	inc	S, #2

000065ee <.LCFI2>:
    65ee:	5201      	mov	[S-2], A
    65f0:	7ee6      	lod	X, Y
    65f2:	6601      	lod	YL, [S-2]
    65f4:	5cf6      	usex	Y

000065f6 <.LM91>:
	if (valve.diag.temp.state != TEMPERATURE_NORMAL)
    65f6:	72d8 1268 	lod	A, 0x1268 <.LLST28+0x9>

000065fa <.LVL33>:
    65fa:	1901      	je	0x65fe <.L63>

000065fc <.LM92>:
	{
		result_data.status = 0;
    65fc:	7800      	lod	Y, #0

000065fe <.L63>:
	}

	return result_data;
    65fe:	7201      	lod	A, [S-2]
    6600:	9400      	and	AL, #0
    6602:	a6e6      	or	A, Y
    6604:	7aee      	lod	Y, X

00006606 <.LM94>:
}
    6606:	5403      	ret	#4

00006608 <_check_retry_cnt_protection_comm>:
 * @param void No input parameters are used for this function.
 * @retval void This function does not return a value.
 */
void check_retry_cnt_protection_comm(void)
{
	if (valve.diag.comm.linErrRetryCnt < MAX_VALUE_2BYTE)
    6608:	72d8 1264 	lod	A, 0x1264 <.LLST28+0x5>
    660c:	acff      	cmp	A, #-1
    660e:	1903      	je	0x6616 <.L67>

00006610 <.LM97>:
	{
		valve.diag.comm.linErrRetryCnt++;
    6610:	a001      	add	A, #1
    6612:	52d8 1264 	mov	0x1264 <.LLST28+0x5>, A

00006616 <.L67>:
	}
}
    6616:	5401      	ret

00006618 <_check_protection_comm>:
 * @brief Handles communication fault protection; logs the error and transitions to VALVE_FAULT if the fault persists past the retry time (1 sec).
 * @param result_data Current protection check status containing status and next state suggestion.
 * @retval Protectoin_Check_Result Updated result data after checking communication fault status.
 */
Protectoin_Check_Result check_protection_comm(Protectoin_Check_Result result_data)
{
    6618:	5803      	inc	S, #4

0000661a <.LCFI3>:
    661a:	5203      	mov	[S-4], A

0000661c <.LM100>:
	if (valve.diag.comm.state != COMMUNICATION_NORNAL)
    661c:	72d8 1262 	lod	A, 0x1262 <.LLST28+0x3>

00006620 <.LVL35>:
    6620:	1d09      	jne	0x6634 <.L73>
    6622:	6203      	lod	AL, [S-4]
    6624:	5cf2      	usex	A

00006626 <.L74>:
			clear_fail_safe_retry_cnt(VALVE_LIN_COMM_FAULT);
			result_data.next_state = VALVE_FAULT;
		}
	}

	return result_data;
    6626:	7e03      	lod	X, [S-4]
    6628:	36da ff00 	and	X, #65280
    662c:	26e2      	or	X, A
    662e:	5e03      	mov	[S-4], X

00006630 <.LM102>:
}
    6630:	72ee      	lod	A, X
    6632:	5405      	ret	#6

00006634 <.L73>:
	return result_data;
}

void event_memry_save(tProtectCondition event_state, uint16_t event_value)
{
	u16EventState = event_state;
    6634:	7c0d      	lod	X, #13
    6636:	5ed8 10b6 	mov	0x10b6 <_u16EventState>, X

0000663a <.LM104>:
	u16EventValue = event_value;
    663a:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

0000663e <.LBE184>:
	if (valve.diag.comm.state != COMMUNICATION_NORNAL)
	{
		result_data.status = 0;
		event_memry_save(VALVE_LIN_COMM_FAULT, valve.diag.comm.state);

		check_retry_cnt_protection_comm();
    663e:	5a01      	mov	[S-2], Y
    6640:	17e3      	call	0x6608 <_check_retry_cnt_protection_comm>
    6642:	7000      	lod	A, #0

00006644 <.LM106>:

		if (valve.diag.comm.linErrRetryCnt >= CHECK_LIN_COMM_ERR_CNT)
    6644:	7ed8 1264 	lod	X, 0x1264 <.LLST28+0x5>
    6648:	7a01      	lod	Y, [S-2]
    664a:	2eda 03e7 	cmp	X, #999
    664e:	1a6b      	jule	0x6626 <.L74>

00006650 <.LBB186>:
			break;
		case MCU_ERROR : 
			valve.diag.mcuRetryCnt = CLEAR;	// Clear Microcontroller internal error retry count
			break;
		case VALVE_LIN_COMM_FAULT : 
			valve.diag.comm.linErrRetryCnt = CLEAR;	// Clear LIN Communication Error retry count
    6650:	52d8 1264 	mov	0x1264 <.LLST28+0x5>, A

00006654 <.LBE186>:
		check_retry_cnt_protection_comm();

		if (valve.diag.comm.linErrRetryCnt >= CHECK_LIN_COMM_ERR_CNT)
		{
			clear_fail_safe_retry_cnt(VALVE_LIN_COMM_FAULT);
			result_data.next_state = VALVE_FAULT;
    6654:	7806      	lod	Y, #6
    6656:	07e7      	jmp	0x6626 <.L74>

00006658 <_check_retry_cnt_protection_oc>:
 * @param void No input parameters are used for this function.
 * @retval void This function does not return a value.
 */
void check_retry_cnt_protection_oc(void)
{
	if (valve.initStatus != 0)
    6658:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    665c:	190d      	je	0x6678 <.L76>

0000665e <.LM111>:
	{	
		valve.initStatus = 0;
    665e:	6000      	lod	AL, #0
    6660:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

00006664 <.LM112>:

		if (valve.diag.motOcRetryCnt < MAX_VALUE_1BYTE)
    6664:	62d8 128a 	lod	AL, 0x128a <.LASF1443+0xe>
    6668:	66e0      	lod	YL, AL
    666a:	5cf6      	usex	Y
    666c:	eeda 00ff 	cmp	Y, #255
    6670:	1903      	je	0x6678 <.L76>

00006672 <.LM113>:
		{
			valve.diag.motOcRetryCnt++;
    6672:	8001      	add	AL, #1
    6674:	42d8 128a 	mov	0x128a <.LASF1443+0xe>, AL

00006678 <.L76>:
		}
	}
}
    6678:	5401      	ret

0000667a <_check_protection_oc>:
 * @brief Handles motor over-current (OC) protection; logs the error, attempts recovery, or transitions to VALVE_FAULT if the retry count (2 times) is exceeded.
 * @param result_data Current protection check status containing status and next state suggestion.
 * @retval Protectoin_Check_Result Updated result data after checking OC fault status.
 */
Protectoin_Check_Result check_protection_oc(Protectoin_Check_Result result_data)
{	
    667a:	5803      	inc	S, #4

0000667c <.LCFI4>:
    667c:	5203      	mov	[S-4], A

0000667e <.LM116>:
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    667e:	62d8 1286 	lod	AL, 0x1286 <.LASF1443+0xa>

00006682 <.LVL42>:
    6682:	5cf2      	usex	A
    6684:	7ee2      	lod	X, A
    6686:	62d8 1286 	lod	AL, 0x1286 <.LASF1443+0xa>
    668a:	9440      	and	AL, #64
    668c:	1d09      	jne	0x66a0 <.L84>
    668e:	6203      	lod	AL, [S-4]
    6690:	5cf2      	usex	A

00006692 <.L85>:
			clear_fail_safe_retry_cnt(MOT_OC_ERROR);
			result_data.next_state = VALVE_FAULT;
		}
	}

	return result_data;
    6692:	7e03      	lod	X, [S-4]
    6694:	36da ff00 	and	X, #65280
    6698:	26e2      	or	X, A
    669a:	5e03      	mov	[S-4], X

0000669c <.LM118>:
}
    669c:	72ee      	lod	A, X
    669e:	5405      	ret	#6

000066a0 <.L84>:
	return result_data;
}

void event_memry_save(tProtectCondition event_state, uint16_t event_value)
{
	u16EventState = event_state;
    66a0:	7004      	lod	A, #4
    66a2:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000066a6 <.LBE192>:
 * @param result_data Current protection check status containing status and next state suggestion.
 * @retval Protectoin_Check_Result Updated result data after checking OC fault status.
 */
Protectoin_Check_Result check_protection_oc(Protectoin_Check_Result result_data)
{	
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    66a6:	5ed8 10b4 	mov	0x10b4 <_u16EventValue>, X

000066aa <.LM121>:
	{
		result_data.status  = 0;
		event_memry_save(MOT_OC_ERROR, valve.diag.motorFault);
		
		check_retry_cnt_protection_oc();
    66aa:	5a01      	mov	[S-2], Y
    66ac:	17d5      	call	0x6658 <_check_retry_cnt_protection_oc>

000066ae <.LM122>:

		if(valve.diag.motOcRetryCnt < CHECK_OVER_CURRENT_CNT)
    66ae:	7a01      	lod	Y, [S-2]
    66b0:	62d8 128a 	lod	AL, 0x128a <.LASF1443+0xe>
    66b4:	8c01      	cmp	AL, #1
    66b6:	1e0b      	jug	0x66ce <.L86>

000066b8 <.LM123>:
		{
			if (valve.elapsedTime >= TIME_500MS)
    66b8:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    66bc:	aeda 01f3 	cmp	A, #499
    66c0:	1a0a      	jule	0x66d6 <.L87>

000066c2 <.LM124>:
			{
				MotClearFaultFlag(3);
    66c2:	7003      	lod	A, #3
    66c4:	82db 3f4d 	callf	0x7e9a <_MotClearFaultFlag>

000066c8 <.LM125>:
 */
Protectoin_Check_Result check_protection_oc(Protectoin_Check_Result result_data)
{	
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
	{
		result_data.status  = 0;
    66c8:	7000      	lod	A, #0
    66ca:	7a01      	lod	Y, [S-2]
    66cc:	07e2      	jmp	0x6692 <.L85>

000066ce <.L86>:
			break;
		case VS_HIGH_ERROR : 
			valve.diag.vs.OVretryCnt = CLEAR;	// Clear Over Voltage retry count
			break;
		case MOT_OC_ERROR : 
			valve.diag.motOcRetryCnt = CLEAR;	// Clear Motor Over Current retry count
    66ce:	6000      	lod	AL, #0
    66d0:	42d8 128a 	mov	0x128a <.LASF1443+0xe>, AL

000066d4 <.LBE194>:
			}
		}
		else
		{
			clear_fail_safe_retry_cnt(MOT_OC_ERROR);
			result_data.next_state = VALVE_FAULT;
    66d4:	7806      	lod	Y, #6

000066d6 <.L87>:
 */
Protectoin_Check_Result check_protection_oc(Protectoin_Check_Result result_data)
{	
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
	{
		result_data.status  = 0;
    66d6:	7000      	lod	A, #0
    66d8:	07dc      	jmp	0x6692 <.L85>

000066da <_check_retry_cnt_protection_pos_fault>:
 * @param void No input parameters are used for this function.
 * @retval void This function does not return a value.
 */
void check_retry_cnt_protection_pos_fault(void)
{
	if (valve.initStatus != 0)
    66da:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    66de:	190d      	je	0x66fa <.L88>

000066e0 <.LM131>:
	{
		valve.initStatus = 0;
    66e0:	6000      	lod	AL, #0
    66e2:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000066e6 <.LM132>:
		
		if (valve.pos.retryCnt < MAX_VALUE_1BYTE)
    66e6:	62d8 122d 	lod	AL, 0x122d <.LLST5+0x1>
    66ea:	66e0      	lod	YL, AL
    66ec:	5cf6      	usex	Y
    66ee:	eeda 00ff 	cmp	Y, #255
    66f2:	1903      	je	0x66fa <.L88>

000066f4 <.LM133>:
		{
			valve.pos.retryCnt++;
    66f4:	8001      	add	AL, #1
    66f6:	42d8 122d 	mov	0x122d <.LLST5+0x1>, AL

000066fa <.L88>:
		}
	}
}
    66fa:	5401      	ret

000066fc <_check_protection_pos_fault>:
 * @brief Handles position sensor fault protection; logs the error, attempts recovery, or transitions to VALVE_FAULT after retry count(5 times) is exceeded.
 * @param result_data Current protection check status containing status and next state suggestion.
 * @retval Protectoin_Check_Result Updated result data after checking position fault status.
 */
Protectoin_Check_Result check_protection_pos_fault(Protectoin_Check_Result result_data)
{
    66fc:	5805      	inc	S, #6

000066fe <.LCFI5>:
    66fe:	5205      	mov	[S-6], A

00006700 <.LM136>:
	if (valve.pos.fault != POS_NORMAL)
    6700:	62d8 122c 	lod	AL, 0x122c <.LLST5>

00006704 <.LVL50>:
    6704:	1d09      	jne	0x6718 <.L96>
    6706:	6205      	lod	AL, [S-6]
    6708:	5cf2      	usex	A

0000670a <.L97>:
			clear_fail_safe_retry_cnt(SENSOR_POS_ERROR);
			result_data.next_state = VALVE_FAULT;
		}
	}

	return result_data;
    670a:	7e05      	lod	X, [S-6]
    670c:	36da ff00 	and	X, #65280
    6710:	26e2      	or	X, A
    6712:	5e05      	mov	[S-6], X

00006714 <.LM138>:
}
    6714:	72ee      	lod	A, X
    6716:	5407      	ret	#8

00006718 <.L96>:
	return result_data;
}

void event_memry_save(tProtectCondition event_state, uint16_t event_value)
{
	u16EventState = event_state;
    6718:	7c06      	lod	X, #6
    671a:	5ed8 10b6 	mov	0x10b6 <_u16EventState>, X

0000671e <.LM140>:
	u16EventValue = event_value;
    671e:	72d8 1226 	lod	A, 0x1226 <.LASF1421+0xd>
    6722:	0ea7      	lod	C, ML.7
    6724:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00006728 <.LBE200>:
	if (valve.pos.fault != POS_NORMAL)
	{
		result_data.status = 0;
		event_memry_save(SENSOR_POS_ERROR, valve.pos.currentAngle);
		
		check_retry_cnt_protection_pos_fault();
    6728:	5a03      	mov	[S-4], Y
    672a:	5e01      	mov	[S-2], X
    672c:	17d6      	call	0x66da <_check_retry_cnt_protection_pos_fault>

0000672e <.LM142>:

		if(valve.pos.retryCnt < CHECK_POSITION_SENSOR_CNT)
    672e:	7a03      	lod	Y, [S-4]
    6730:	7e01      	lod	X, [S-2]
    6732:	62d8 122d 	lod	AL, 0x122d <.LLST5+0x1>
    6736:	8c04      	cmp	AL, #4
    6738:	1e0a      	jug	0x674e <.L98>

0000673a <.LM143>:
		{
			if (valve.elapsedTime >= TIME_500MS)
    673a:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    673e:	aeda 01f3 	cmp	A, #499
    6742:	1a03      	jule	0x674a <.L99>

00006744 <.LM144>:
			{
				valve.pos.fault = POS_NORMAL;
    6744:	6000      	lod	AL, #0
    6746:	42d8 122c 	mov	0x122c <.LLST5>, AL

0000674a <.L99>:
 */
Protectoin_Check_Result check_protection_pos_fault(Protectoin_Check_Result result_data)
{
	if (valve.pos.fault != POS_NORMAL)
	{
		result_data.status = 0;
    674a:	7000      	lod	A, #0
    674c:	07de      	jmp	0x670a <.L97>

0000674e <.L98>:
			break;
		case MOT_ABSTALL_ERROR : 
			valve.diag.ObstructionRetryCnt = CLEAR;	// Clear Motor  Obstruction stall retry count
			break;
		case SENSOR_POS_ERROR : 
			valve.pos.retryCnt = CLEAR;	// Clear Valve Position Sensor retry count (Angle deviation/Out of tolerance)
    674e:	6000      	lod	AL, #0
    6750:	42d8 122d 	mov	0x122d <.LLST5+0x1>, AL

00006754 <.LBE202>:
			}
		}
		else
		{
			clear_fail_safe_retry_cnt(SENSOR_POS_ERROR);
			result_data.next_state = VALVE_FAULT;
    6754:	7aee      	lod	Y, X
    6756:	07f9      	jmp	0x674a <.L99>

00006758 <_check_retry_cnt_protection_mcu_fault>:
 * @param void No input parameters are used for this function.
 * @retval void This function does not return a value.
 */
void check_retry_cnt_protection_mcu_fault(void)
{
	event_memry_save(MCU_ERROR, valve.diag.McuFault);
    6758:	62d8 1281 	lod	AL, 0x1281 <.LASF1443+0x5>
    675c:	5cf2      	usex	A

0000675e <.LBB204>:
	return result_data;
}

void event_memry_save(tProtectCondition event_state, uint16_t event_value)
{
	u16EventState = event_state;
    675e:	7c08      	lod	X, #8
    6760:	5ed8 10b6 	mov	0x10b6 <_u16EventState>, X

00006764 <.LM151>:
	u16EventValue = event_value;
    6764:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00006768 <.LBE204>:
 */
void check_retry_cnt_protection_mcu_fault(void)
{
	event_memry_save(MCU_ERROR, valve.diag.McuFault);

	if (valve.diag.mcuRetryCnt < MAX_VALUE_2BYTE)
    6768:	0ea7      	lod	C, ML.7
    676a:	72d8 1282 	lod	A, 0x1282 <.LASF1443+0x6>
    676e:	acff      	cmp	A, #-1
    6770:	1903      	je	0x6778 <.L100>

00006772 <.LM153>:
	{
		valve.diag.mcuRetryCnt++;
    6772:	a001      	add	A, #1
    6774:	52d8 1282 	mov	0x1282 <.LASF1443+0x6>, A

00006778 <.L100>:
	}
}
    6778:	5401      	ret

0000677a <_check_protection_mcu_fault>:
 * @brief Handles MCU fault protection; transitions to VALVE_FAULT if the fault time exceeds the defined limit.
 * @param result_data Current protection check status containing status and next state suggestion.
 * @retval Protectoin_Check_Result Updated result data after checking MCU fault status.
 */
Protectoin_Check_Result check_protection_mcu_fault(Protectoin_Check_Result result_data)
{
    677a:	5803      	inc	S, #4

0000677c <.LCFI6>:
    677c:	5203      	mov	[S-4], A

0000677e <.LM156>:
	if (valve.diag.McuFault != MCU_NORMAL)
    677e:	62d8 1281 	lod	AL, 0x1281 <.LASF1443+0x5>

00006782 <.LVL59>:
    6782:	1d09      	jne	0x6796 <.L106>
    6784:	6203      	lod	AL, [S-4]
    6786:	5cf2      	usex	A

00006788 <.L107>:
			clear_fail_safe_retry_cnt(MCU_ERROR);
			result_data.next_state = VALVE_FAULT;
		}
	}

	return result_data;
    6788:	7e03      	lod	X, [S-4]
    678a:	36da ff00 	and	X, #65280
    678e:	26e2      	or	X, A
    6790:	5e03      	mov	[S-4], X

00006792 <.LM158>:
}
    6792:	72ee      	lod	A, X
    6794:	5405      	ret	#6

00006796 <.L106>:
Protectoin_Check_Result check_protection_mcu_fault(Protectoin_Check_Result result_data)
{
	if (valve.diag.McuFault != MCU_NORMAL)
	{
		result_data.status = 0;
		check_retry_cnt_protection_mcu_fault();
    6796:	5a01      	mov	[S-2], Y
    6798:	17df      	call	0x6758 <_check_retry_cnt_protection_mcu_fault>
    679a:	7000      	lod	A, #0

0000679c <.LM160>:

		if (valve.diag.mcuRetryCnt >= MCU_FAULT_RERTY_TIME)
    679c:	7ed8 1282 	lod	X, 0x1282 <.LASF1443+0x6>
    67a0:	7a01      	lod	Y, [S-2]
    67a2:	2eda 01f3 	cmp	X, #499
    67a6:	1a70      	jule	0x6788 <.L107>

000067a8 <.LBB206>:
			break;
		case SENSOR_OUT_ERROR : 
			valve.diag.gmr.retryCnt = CLEAR;	// Clear GMR Sensor Out-of-range retry count (No valid signal/Value not received)
			break;
		case MCU_ERROR : 
			valve.diag.mcuRetryCnt = CLEAR;	// Clear Microcontroller internal error retry count
    67a8:	52d8 1282 	mov	0x1282 <.LASF1443+0x6>, A

000067ac <.LBE206>:
		check_retry_cnt_protection_mcu_fault();

		if (valve.diag.mcuRetryCnt >= MCU_FAULT_RERTY_TIME)
		{
			clear_fail_safe_retry_cnt(MCU_ERROR);
			result_data.next_state = VALVE_FAULT;
    67ac:	7806      	lod	Y, #6
    67ae:	07ec      	jmp	0x6788 <.L107>

000067b0 <_check_retry_cnt_protection_obstruction_stall>:
 * @param void No input parameters are used for this function.
 * @retval void This function does not return a value.
 */
void check_retry_cnt_protection_obstruction_stall(void)
{
	if (valve.initStatus != 0)
    67b0:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    67b4:	190d      	je	0x67d0 <.L109>

000067b6 <.LM165>:
	{
		valve.initStatus = 0;
    67b6:	6000      	lod	AL, #0
    67b8:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000067bc <.LM166>:

		if (valve.diag.ObstructionRetryCnt < 0xffu)
    67bc:	62d8 1284 	lod	AL, 0x1284 <.LASF1443+0x8>
    67c0:	66e0      	lod	YL, AL
    67c2:	5cf6      	usex	Y
    67c4:	eeda 00ff 	cmp	Y, #255
    67c8:	1903      	je	0x67d0 <.L109>

000067ca <.LM167>:
		{
			valve.diag.ObstructionRetryCnt ++;
    67ca:	8001      	add	AL, #1
    67cc:	42d8 1284 	mov	0x1284 <.LASF1443+0x8>, AL

000067d0 <.L109>:
		}
	}
}
    67d0:	5401      	ret

000067d2 <_check_protection_obstruction_stall>:
 * @brief Handles temporary stall/obstruction protection; attempts recovery or transitions to VALVE_FAULT after 3 retries.
 * @param result_data Current protection check status.
 * @retval Protectoin_Check_Result Updated result data.
 */
Protectoin_Check_Result check_protection_obstruction_stall(Protectoin_Check_Result result_data)
{
    67d2:	5803      	inc	S, #4

000067d4 <.LCFI7>:
    67d4:	5203      	mov	[S-4], A

000067d6 <.LM170>:
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    67d6:	62d8 1287 	lod	AL, 0x1287 <.LASF1443+0xb>

000067da <.LVL64>:
    67da:	9401      	and	AL, #1
    67dc:	1d09      	jne	0x67f0 <.L117>
    67de:	6203      	lod	AL, [S-4]
    67e0:	5cf2      	usex	A

000067e2 <.L118>:
			clear_fail_safe_retry_cnt(MOT_ABSTALL_ERROR);
			result_data.next_state = VALVE_FAULT;
		}
	}

	return result_data;
    67e2:	7e03      	lod	X, [S-4]
    67e4:	36da ff00 	and	X, #65280
    67e8:	26e2      	or	X, A
    67ea:	5e03      	mov	[S-4], X

000067ec <.LM172>:
}
    67ec:	72ee      	lod	A, X
    67ee:	5405      	ret	#6

000067f0 <.L117>:
Protectoin_Check_Result check_protection_obstruction_stall(Protectoin_Check_Result result_data)
{
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
	{
		result_data.status = 0;
		check_retry_cnt_protection_obstruction_stall();
    67f0:	5a01      	mov	[S-2], Y
    67f2:	17de      	call	0x67b0 <_check_retry_cnt_protection_obstruction_stall>

000067f4 <.LM174>:

		if (valve.diag.ObstructionRetryCnt < OBSTRUCTION_STALL_RETRY_CNT)
    67f4:	7a01      	lod	Y, [S-2]
    67f6:	62d8 1284 	lod	AL, 0x1284 <.LASF1443+0x8>
    67fa:	8c02      	cmp	AL, #2
    67fc:	1e0b      	jug	0x6814 <.L119>

000067fe <.LM175>:
		{
			if (valve.elapsedTime >= TIME_500MS)
    67fe:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    6802:	aeda 01f3 	cmp	A, #499
    6806:	1a0a      	jule	0x681c <.L120>

00006808 <.LM176>:
			{
				MotClearStallFlag(1);
    6808:	7001      	lod	A, #1
    680a:	82db 3f3e 	callf	0x7e7c <_MotClearStallFlag>

0000680e <.LM177>:
 */
Protectoin_Check_Result check_protection_obstruction_stall(Protectoin_Check_Result result_data)
{
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
	{
		result_data.status = 0;
    680e:	7000      	lod	A, #0
    6810:	7a01      	lod	Y, [S-2]
    6812:	07e7      	jmp	0x67e2 <.L118>

00006814 <.L119>:
			break;
		case MOT_OC_ERROR : 
			valve.diag.motOcRetryCnt = CLEAR;	// Clear Motor Over Current retry count
			break;
		case MOT_ABSTALL_ERROR : 
			valve.diag.ObstructionRetryCnt = CLEAR;	// Clear Motor  Obstruction stall retry count
    6814:	6000      	lod	AL, #0
    6816:	42d8 1284 	mov	0x1284 <.LASF1443+0x8>, AL

0000681a <.LBE212>:
			}
		}
		else
		{
			clear_fail_safe_retry_cnt(MOT_ABSTALL_ERROR);
			result_data.next_state = VALVE_FAULT;
    681a:	7806      	lod	Y, #6

0000681c <.L120>:
 */
Protectoin_Check_Result check_protection_obstruction_stall(Protectoin_Check_Result result_data)
{
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
	{
		result_data.status = 0;
    681c:	7000      	lod	A, #0
    681e:	07e1      	jmp	0x67e2 <.L118>

00006820 <_check_retry_cnt_protection_gmr_fault>:
 * This function handles the initial event detection and logging when a GMR sensor fault 
 * occurs during initialization or operation, setting up for protection/fault state transition.
 */
void check_retry_cnt_protection_gmr_fault(void)
{
	if (valve.initStatus != 0)
    6820:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    6824:	1914      	je	0x684e <.L121>

00006826 <.LM183>:
	{
		valve.initStatus = 0;
    6826:	6000      	lod	AL, #0
    6828:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

0000682c <.LBB220>:
	return result_data;
}

void event_memry_save(tProtectCondition event_state, uint16_t event_value)
{
	u16EventState = event_state;
    682c:	7007      	lod	A, #7
    682e:	0ea7      	lod	C, ML.7
    6830:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00006834 <.LM185>:
	u16EventValue = event_value;
    6834:	72d8 1226 	lod	A, 0x1226 <.LASF1421+0xd>
    6838:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

0000683c <.LBE220>:
	if (valve.initStatus != 0)
	{
		valve.initStatus = 0;
		event_memry_save(SENSOR_OUT_ERROR, valve.pos.currentAngle);

		if (valve.diag.gmr.retryCnt < MAX_VALUE_1BYTE)
    683c:	0ea7      	lod	C, ML.7
    683e:	72d8 1278 	lod	A, 0x1278 <.LLST29+0x6>
    6842:	aeda 00fe 	cmp	A, #254
    6846:	1e03      	jug	0x684e <.L121>

00006848 <.LM187>:
		{
			valve.diag.gmr.retryCnt++;
    6848:	a001      	add	A, #1
    684a:	52d8 1278 	mov	0x1278 <.LLST29+0x6>, A

0000684e <.L121>:
		}
	}
}
    684e:	5401      	ret

00006850 <_check_protection_gmr_fault>:
 * @brief Handles protection logic for GMR sensor faults, including retry mechanism and transition to VALVE_FAULT.
 * @param result_data Current protection check status.
 * @retval Protectoin_Check_Result Updated result data.
 */
Protectoin_Check_Result check_protection_gmr_fault(Protectoin_Check_Result result_data)
{
    6850:	5803      	inc	S, #4

00006852 <.LCFI8>:
    6852:	5203      	mov	[S-4], A

00006854 <.LM190>:
	if (valve.diag.gmr.state != GMR_SENSOR_NORMAL)
    6854:	62d8 1276 	lod	AL, 0x1276 <.LLST29+0x4>

00006858 <.LVL72>:
    6858:	1d09      	jne	0x686c <.L126>
    685a:	6203      	lod	AL, [S-4]
    685c:	5cf2      	usex	A

0000685e <.L127>:
			clear_fail_safe_retry_cnt(SENSOR_OUT_ERROR);
			result_data.next_state = VALVE_FAULT;
		}
	}
	
	return result_data;
    685e:	7e03      	lod	X, [S-4]
    6860:	36da ff00 	and	X, #65280
    6864:	26e2      	or	X, A
    6866:	5e03      	mov	[S-4], X

00006868 <.LM192>:
}
    6868:	72ee      	lod	A, X
    686a:	5405      	ret	#6

0000686c <.L126>:
{
	if (valve.diag.gmr.state != GMR_SENSOR_NORMAL)
	{
		result_data.status = 0;

		check_retry_cnt_protection_gmr_fault();
    686c:	5a01      	mov	[S-2], Y
    686e:	17d8      	call	0x6820 <_check_retry_cnt_protection_gmr_fault>
    6870:	7000      	lod	A, #0

00006872 <.LM194>:

		if (valve.diag.gmr.retryCnt < GMR_FAULT_RETRY_CNT)
    6872:	7ed8 1278 	lod	X, 0x1278 <.LLST29+0x6>
    6876:	7a01      	lod	Y, [S-2]
    6878:	2c02      	cmp	X, #2
    687a:	1e08      	jug	0x688c <.L128>

0000687c <.LM195>:
		{
			if (valve.elapsedTime >= TIME_1S)
    687c:	7ed8 121c 	lod	X, 0x121c <.LASF1421+0x3>
    6880:	2eda 03e7 	cmp	X, #999
    6884:	1a6c      	jule	0x685e <.L127>

00006886 <.LM196>:
			{
				valve.diag.gmr.state = GMR_SENSOR_NORMAL;
    6886:	42d8 1276 	mov	0x1276 <.LLST29+0x4>, AL
    688a:	07e9      	jmp	0x685e <.L127>

0000688c <.L128>:
			break;
		case SENSOR_POS_ERROR : 
			valve.pos.retryCnt = CLEAR;	// Clear Valve Position Sensor retry count (Angle deviation/Out of tolerance)
			break;
		case SENSOR_OUT_ERROR : 
			valve.diag.gmr.retryCnt = CLEAR;	// Clear GMR Sensor Out-of-range retry count (No valid signal/Value not received)
    688c:	52d8 1278 	mov	0x1278 <.LLST29+0x6>, A

00006890 <.LBE222>:
			}
		}
		else
		{
			clear_fail_safe_retry_cnt(SENSOR_OUT_ERROR);
			result_data.next_state = VALVE_FAULT;
    6890:	7806      	lod	Y, #6
    6892:	07e5      	jmp	0x685e <.L127>

00006894 <_ValveLinGetCommand>:
}
void ValveLinGetCommand(void)
{
	int16_t pos;

	valve.comm.Enable = l_bool_rd_Fwv_MoveEnable();
    6894:	62d8 1195 	lod	AL, 0x1195 <_l_signals+0x1>
    6898:	42d8 123f 	mov	0x123f <.LLST27>, AL

0000689c <.LBB224>:
 * Define API functions using templates
 */

L_SIGNAL(l_u8, Fwv_Target_Mode)
L_SIGNAL(l_bool, Fwv_MoveEnable)
L_SIGNAL(l_bool, Fwv_Initial)
    689c:	66d8 1196 	lod	YL, 0x1196 <_l_signals+0x2>

000068a0 <.LBE224>:

	if (l_bool_rd_Fwv_Initial() != valve.comm.Initial)
    68a0:	0ea7      	lod	C, ML.7
    68a2:	62d8 1240 	lod	AL, 0x1240 <.LLST27+0x1>
    68a6:	8ee8      	cmp	AL, YL
    68a8:	1909      	je	0x68bc <.L133>

000068aa <.LBB226>:
    68aa:	62d8 1196 	lod	AL, 0x1196 <_l_signals+0x2>

000068ae <.LBE226>:
	{
		valve.comm.Initial = l_bool_rd_Fwv_Initial();
    68ae:	42d8 1240 	mov	0x1240 <.LLST27+0x1>, AL

000068b2 <.LM210>:
		if (valve.comm.Initial)
    68b2:	1904      	je	0x68bc <.L133>

000068b4 <.LM211>:
		{
			valve.calibration.req2Cal = 1;
    68b4:	6001      	lod	AL, #1
    68b6:	42d8 1230 	mov	0x1230 <.Lframe0>, AL

000068ba <.LM212>:
			ValveFaultReset();
    68ba:	1634      	call	0x6524 <_ValveFaultReset>

000068bc <.L133>:
L_SIGNAL(l_bool, Fwv_ForcedDiag)
    68bc:	62d8 1197 	lod	AL, 0x1197 <_l_signals+0x3>

000068c0 <.LBE228>:
		}
	}

	valve.comm.ForcedDiag = l_bool_rd_Fwv_ForcedDiag();
    68c0:	42d8 1241 	mov	0x1241 <.LLST27+0x2>, AL

000068c4 <.LM215>:

	if ((valve.comm.ForcedDiag == 0) && (valve.comm.Enable != 0))
    68c4:	1d0f      	jne	0x68e4 <.L131>

000068c6 <.LM216>:
    68c6:	62d8 123f 	lod	AL, 0x123f <.LLST27>
    68ca:	190c      	je	0x68e4 <.L131>

000068cc <.LBB230>:

/*
 * Define API functions using templates
 */

L_SIGNAL(l_u8, Fwv_Target_Mode)
    68cc:	62d8 1194 	lod	AL, 0x1194 <_l_signals>

000068d0 <.LBE230>:
	{

		valve.comm.targetMode = l_u8_rd_Fwv_Target_Mode();
    68d0:	42d8 123e 	mov	0x123e <.Lframe0+0xe>, AL

000068d4 <.LM219>:
		if (valve.comm.targetMode == C_MODE_A)
    68d4:	66e0      	lod	YL, AL
    68d6:	5cf6      	usex	Y
    68d8:	8c00      	cmp	AL, #0
    68da:	1d05      	jne	0x68e6 <.L138>

000068dc <.LBB232>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    68dc:	72d8 1228 	lod	A, 0x1228 <.LASF1421+0xf>

000068e0 <.L145>:
    68e0:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A

000068e4 <.L131>:
#endif
	}
	else
	{
	}
}
    68e4:	5401      	ret

000068e6 <.L138>:
		if (valve.comm.targetMode == C_MODE_A)
		{
			pos = valve.pos.modeAngle[C_MODE_A];
			ValveTargetAngleUpdate(pos);
		}
		else if (valve.comm.targetMode == C_MODE_B)
    68e6:	ec01      	cmp	Y, #1
    68e8:	1d7d      	jne	0x68e4 <.L131>

000068ea <.LM223>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    68ea:	72d8 122a 	lod	A, 0x122a <.LASF1421+0x11>
    68ee:	07f8      	jmp	0x68e0 <.L145>

000068f0 <_ValveLinUpdateSignals>:
	else
	{
	}
}
void ValveLinUpdateSignals(void) /*20250714*/
{
    68f0:	5803      	inc	S, #4

000068f2 <.LBB238>:
L_SIGNAL(l_bool, Fwv_MoveEnable)
L_SIGNAL(l_bool, Fwv_Initial)
L_SIGNAL(l_bool, Fwv_ForcedDiag)
L_SIGNAL(l_u8, Fwv_Reserved1)
L_SIGNAL(l_u8, Fwv_Actual_Mode)
    68f2:	62d8 1243 	lod	AL, 0x1243 <.LLST27+0x4>
    68f6:	42d8 1199 	mov	0x1199 <_l_signals+0x5>, AL

000068fa <.LBE238>:
	/* Byte 0 */
	l_u8_wr_Fwv_Actual_Mode(valve.comm.actualMode);

	l_bool_wr_Fwv_Position_Fault(valve.pos.fault);
    68fa:	62d8 122c 	lod	AL, 0x122c <.LLST5>
    68fe:	5ca2      	sne	A

00006900 <.LBB240>:
L_SIGNAL(l_bool, Fwv_Position_Fault)
    6900:	42d8 119a 	mov	0x119a <_l_signals+0x6>, AL

00006904 <.LBE240>:
	
	if(valve.state == VALVE_FAULT)
    6904:	7ed8 1216 	lod	X, 0x1216 <_valve>
    6908:	2c06      	cmp	X, #6
    690a:	1901      	je	0x690e <.LBB242>
    690c:	0031      	jmp	0x6970 <.L147>

0000690e <.LBB242>:
L_SIGNAL(l_bool, Fwv_FaultMode)
    690e:	6001      	lod	AL, #1
    6910:	42d8 119b 	mov	0x119b <_l_signals+0x7>, AL

00006914 <.L148>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
    6914:	6000      	lod	AL, #0
    6916:	42d8 119c 	mov	0x119c <_l_signals+0x8>, AL

0000691a <.LBE244>:
	{
		l_bool_wr_Fwv_ProtectMode(0);
	}


	if ((valve.state == VALVE_CALIBRATION) && (valve.comm.Initial == 1))
    691a:	2c05      	cmp	X, #5
    691c:	1901      	je	0x6920 <.LM232>
    691e:	0030      	jmp	0x6980 <.L149>

00006920 <.LM232>:
    6920:	62d8 1240 	lod	AL, 0x1240 <.LLST27+0x1>
    6924:	8c01      	cmp	AL, #1
    6926:	1d2c      	jne	0x6980 <.L149>

00006928 <.L193>:
L_SIGNAL(l_bool, Fwv_InitialSta)
    6928:	42d8 119d 	mov	0x119d <_l_signals+0x9>, AL

0000692c <.LBE246>:
	}
	else
	{
		l_bool_wr_Fwv_InitialSta(0);
	}
	if (valve.comm.faultMode != 0) /*20250714*/
    692c:	62d8 1245 	lod	AL, 0x1245 <.LLST27+0x6>
    6930:	66e0      	lod	YL, AL
    6932:	5cf6      	usex	Y
    6934:	5a03      	mov	[S-4], Y
    6936:	8c00      	cmp	AL, #0
    6938:	1904      	je	0x6942 <.L151>

0000693a <.LM235>:
	{
		if (valve.diag.calFault != 0)
    693a:	62d8 1285 	lod	AL, 0x1285 <.LASF1443+0x9>
    693e:	1901      	je	0x6942 <.L151>

00006940 <.LBB249>:
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
    6940:	6001      	lod	AL, #1

00006942 <.L151>:
    6942:	42d8 119e 	mov	0x119e <_l_signals+0xa>, AL

00006946 <.LBE251>:
	{
		l_bool_wr_Fwv_Calibration_Fail(0);
	}

	/* Byte 1 */
	l_bool_wr_Fwv_MoveEnable_Status(valve.comm.moving);
    6946:	62d8 1244 	lod	AL, 0x1244 <.LLST27+0x5>
    694a:	5ca2      	sne	A

0000694c <.LBB253>:
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
    694c:	42d8 119f 	mov	0x119f <_l_signals+0xb>, AL

00006950 <.LVL93>:
    6950:	62d8 1287 	lod	AL, 0x1287 <.LASF1443+0xb>
    6954:	66e0      	lod	YL, AL
    6956:	5cf6      	usex	Y
    6958:	5a01      	mov	[S-2], Y

0000695a <.LBE253>:

	if (valve.motorMotion == MOTION_STALL) /*20250714*/
    695a:	7ad8 1222 	lod	Y, 0x1222 <.LASF1421+0x9>
    695e:	ec06      	cmp	Y, #6
    6960:	1901      	je	0x6964 <.LM240>
    6962:	005f      	jmp	0x6a22 <.L154>

00006964 <.LM240>:
	{
		if ((valve.diag.stallFault != 0) && (valve.comm.faultMode != 0))
    6964:	7201      	lod	A, [S-2]
    6966:	190e      	je	0x6984 <.L155>

00006968 <.LM241>:
    6968:	7a03      	lod	Y, [S-4]
    696a:	190c      	je	0x6984 <.L155>

0000696c <.L202>:
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    696c:	6001      	lod	AL, #1
    696e:	000b      	jmp	0x6986 <.L194>

00006970 <.L147>:
L_SIGNAL(l_bool, Fwv_Initial)
L_SIGNAL(l_bool, Fwv_ForcedDiag)
L_SIGNAL(l_u8, Fwv_Reserved1)
L_SIGNAL(l_u8, Fwv_Actual_Mode)
L_SIGNAL(l_bool, Fwv_Position_Fault)
L_SIGNAL(l_bool, Fwv_FaultMode)
    6970:	6000      	lod	AL, #0
    6972:	42d8 119b 	mov	0x119b <_l_signals+0x7>, AL

00006976 <.LBE257>:
	{
		l_bool_wr_Fwv_FaultMode(0);
	}

	
	if (valve.state == VALVE_PROTECTION)
    6976:	2c07      	cmp	X, #7
    6978:	1d4d      	jne	0x6914 <.L148>

0000697a <.LBB259>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
    697a:	6001      	lod	AL, #1
    697c:	42d8 119c 	mov	0x119c <_l_signals+0x8>, AL

00006980 <.L149>:
L_SIGNAL(l_bool, Fwv_InitialSta)
    6980:	6000      	lod	AL, #0
    6982:	07d2      	jmp	0x6928 <.L193>

00006984 <.L155>:
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    6984:	6000      	lod	AL, #0

00006986 <.L194>:
    6986:	42d8 11a0 	mov	0x11a0 <_l_signals+0xc>, AL

0000698a <.L156>:
		{
			l_bool_wr_Fwv_Motor_Stall(0);
		}
	}

	if (((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0) && (valve.comm.faultMode != 0)) /*20250714*/
    698a:	66d8 1286 	lod	YL, 0x1286 <.LASF1443+0xa>
    698e:	62e8      	lod	AL, YL
    6990:	9401      	and	AL, #1
    6992:	1d01      	jne	0x6996 <.LM249>
    6994:	004e      	jmp	0x6a32 <.L158>

00006996 <.LM249>:
    6996:	7203      	lod	A, [S-4]
    6998:	1d01      	jne	0x699c <.LBB264>
    699a:	004b      	jmp	0x6a32 <.L158>

0000699c <.LBB264>:
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
    699c:	6001      	lod	AL, #1

0000699e <.L195>:
    699e:	42d8 11a2 	mov	0x11a2 <_l_signals+0xe>, AL

000069a2 <.LBE266>:
	}
	else
	{
		l_bool_wr_Fwv_Open_Circuit(0);
	}
	if (((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0) && (valve.comm.faultMode != 0)) /*20250714*/
    69a2:	62e8      	lod	AL, YL
    69a4:	9410      	and	AL, #16
    69a6:	1d01      	jne	0x69aa <.LM252>
    69a8:	0046      	jmp	0x6a36 <.L160>

000069aa <.LM252>:
    69aa:	7203      	lod	A, [S-4]
    69ac:	1d01      	jne	0x69b0 <.LBB269>
    69ae:	0043      	jmp	0x6a36 <.L160>

000069b0 <.LBB269>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
    69b0:	6001      	lod	AL, #1

000069b2 <.L196>:
    69b2:	42d8 11a1 	mov	0x11a1 <_l_signals+0xd>, AL

000069b6 <.LBE271>:
	else
	{
		l_bool_wr_Fwv_Short_Circuit(0);
	}

	if (valve.diag.vs.state == VS_NORMAL)
    69b6:	72d8 1256 	lod	A, 0x1256 <.LASF1692+0xb>
    69ba:	1901      	je	0x69be <.LBB274>
    69bc:	003e      	jmp	0x6a3a <.L162>

000069be <.LBB274>:
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    69be:	42d8 11a3 	mov	0x11a3 <_l_signals+0xf>, AL

000069c2 <.L197>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    69c2:	42d8 11a4 	mov	0x11a4 <_l_signals+0x10>, AL

000069c6 <.L163>:
	}
	else
	{
	}

	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    69c6:	62e8      	lod	AL, YL
    69c8:	9440      	and	AL, #64
    69ca:	4203      	mov	[S-4], AL
    69cc:	62e8      	lod	AL, YL
    69ce:	9440      	and	AL, #64
    69d0:	1d01      	jne	0x69d4 <.LBB279>
    69d2:	0042      	jmp	0x6a58 <.L165>

000069d4 <.LBB279>:
L_SIGNAL(l_bool, Fwv_Overcurrent)
    69d4:	6001      	lod	AL, #1

000069d6 <.L198>:
    69d6:	42d8 11a5 	mov	0x11a5 <_l_signals+0x11>, AL

000069da <.LBE281>:
	else
	{
		l_bool_wr_Fwv_Overcurrent(0);
	}

	if (valve.diag.temp.state == TEMPERATURE_HIGH)
    69da:	72d8 1268 	lod	A, 0x1268 <.LLST28+0x9>
    69de:	ac02      	cmp	A, #2
    69e0:	1901      	je	0x69e4 <.LBB284>
    69e2:	003c      	jmp	0x6a5c <.L167>

000069e4 <.LBB284>:
L_SIGNAL(l_bool, Fwv_Overtemperature)
    69e4:	6001      	lod	AL, #1

000069e6 <.L199>:
    69e6:	42d8 11a6 	mov	0x11a6 <_l_signals+0x12>, AL

000069ea <.LBE286>:
	{
		l_bool_wr_Fwv_Overtemperature(0);
	}

	/* Byte 2 [2..0] */
	if (valve.state == VALVE_DIAGRUN)
    69ea:	2c04      	cmp	X, #4
    69ec:	1901      	je	0x69f0 <.LBB289>
    69ee:	0038      	jmp	0x6a60 <.L169>

000069f0 <.LBB289>:
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
    69f0:	6001      	lod	AL, #1

000069f2 <.L200>:
    69f2:	42d8 11a7 	mov	0x11a7 <_l_signals+0x13>, AL

000069f6 <.LBE291>:
	else
	{
		l_bool_wr_Fwv_Diag_Forced_Status(0);
	}
	
	l_bool_wr_Fwv_Position_Sensor_Fault(valve.diag.gmr.state);
    69f6:	62d8 1276 	lod	AL, 0x1276 <.LLST29+0x4>
    69fa:	5ca2      	sne	A

000069fc <.LBB294>:
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
    69fc:	42d8 11a8 	mov	0x11a8 <_l_signals+0x14>, AL

00006a00 <.LBE294>:
	
	if(valve.diag.comm.state == COMMUNICATION_ERROR)
    6a00:	72d8 1262 	lod	A, 0x1262 <.LLST28+0x3>
    6a04:	ac01      	cmp	A, #1
    6a06:	1d2e      	jne	0x6a64 <.L171>

00006a08 <.L201>:
L_SIGNAL(l_bool, Fwv_CommErr)
    6a08:	42d8 11a9 	mov	0x11a9 <_l_signals+0x15>, AL

00006a0c <.LBB299>:
L_SIGNAL(l_u16, Fwv_SW_Version)
    6a0c:	7002      	lod	A, #2
    6a0e:	52d8 11aa 	mov	0x11aa <_l_signals+0x16>, A

00006a12 <.LBE299>:
	}
	
	/* Byte 2 [7..3] and Byte 3 ~ 4*/
	l_u16_wr_Fwv_SW_Version(SW_VERSION);

	if(motor.stall.stallCnt)
    6a12:	0ea7      	lod	C, ML.7
    6a14:	72d8 12d4 	lod	A, 0x12d4 <.LASF2063+0x2>
    6a18:	1901      	je	0x6a1c <.L173>

00006a1a <.LBB301>:
L_SIGNAL(l_u8, Fwv_Stall_State)
    6a1a:	6001      	lod	AL, #1

00006a1c <.L173>:
    6a1c:	42d8 11ac 	mov	0x11ac <_l_signals+0x18>, AL

00006a20 <.LBE303>:
	}
	else
	{
		l_u8_wr_Fwv_Stall_State(0);
	}
}
    6a20:	5405      	ret	#6

00006a22 <.L154>:
			l_bool_wr_Fwv_Motor_Stall(0);
		}
	}
	else
	{
		if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    6a22:	9401      	and	AL, #1
    6a24:	66e0      	lod	YL, AL
    6a26:	9401      	and	AL, #1
    6a28:	1901      	je	0x6a2c <.LBB305>
    6a2a:	07a0      	jmp	0x696c <.L202>

00006a2c <.LBB305>:
L_SIGNAL(l_bool, Fwv_FaultMode)
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    6a2c:	46d8 11a0 	mov	0x11a0 <_l_signals+0xc>, YL
    6a30:	07ac      	jmp	0x698a <.L156>

00006a32 <.L158>:
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
    6a32:	6000      	lod	AL, #0
    6a34:	07b4      	jmp	0x699e <.L195>

00006a36 <.L160>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
    6a36:	6000      	lod	AL, #0
    6a38:	07bc      	jmp	0x69b2 <.L196>

00006a3a <.L162>:
	if (valve.diag.vs.state == VS_NORMAL)
	{
		l_bool_wr_Fwv_Undervoltage(0);
		l_bool_wr_Fwv_Overvoltage(0);
	}
	else if (valve.diag.vs.state == VS_UNDERVOLTAGE)
    6a3a:	ac01      	cmp	A, #1
    6a3c:	1d04      	jne	0x6a46 <.L164>

00006a3e <.LBB309>:
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    6a3e:	42d8 11a3 	mov	0x11a3 <_l_signals+0xf>, AL

00006a42 <.LBB311>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    6a42:	6000      	lod	AL, #0
    6a44:	07be      	jmp	0x69c2 <.L197>

00006a46 <.L164>:
	{
		l_bool_wr_Fwv_Undervoltage(1);
		l_bool_wr_Fwv_Overvoltage(0);
	}
	else if (valve.diag.vs.state == VS_OVERVOLTAGE)
    6a46:	ac02      	cmp	A, #2
    6a48:	1901      	je	0x6a4c <.LBB313>
    6a4a:	07bd      	jmp	0x69c6 <.L163>

00006a4c <.LBB313>:
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    6a4c:	6000      	lod	AL, #0
    6a4e:	42d8 11a3 	mov	0x11a3 <_l_signals+0xf>, AL

00006a52 <.LBE313>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    6a52:	6001      	lod	AL, #1
    6a54:	0ea7      	lod	C, ML.7
    6a56:	07b5      	jmp	0x69c2 <.L197>

00006a58 <.L165>:
L_SIGNAL(l_bool, Fwv_Overcurrent)
    6a58:	6203      	lod	AL, [S-4]
    6a5a:	07bd      	jmp	0x69d6 <.L198>

00006a5c <.L167>:
L_SIGNAL(l_bool, Fwv_Overtemperature)
    6a5c:	6000      	lod	AL, #0
    6a5e:	07c3      	jmp	0x69e6 <.L199>

00006a60 <.L169>:
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
    6a60:	6000      	lod	AL, #0
    6a62:	07c7      	jmp	0x69f2 <.L200>

00006a64 <.L171>:
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
    6a64:	6000      	lod	AL, #0
    6a66:	07d0      	jmp	0x6a08 <.L201>

00006a68 <_get_valve_mode>:
	return status;
}
tValveState get_valve_mode(void)
{
	return valve.state;
}
    6a68:	72d8 1216 	lod	A, 0x1216 <_valve>
    6a6c:	5401      	ret

00006a6e <_get_valve_voltage>:
uint16_t get_valve_voltage(void)
{
	return valve.diag.vs.voltage;
}
    6a6e:	72d8 1258 	lod	A, 0x1258 <.LASF1692+0xd>
    6a72:	5401      	ret

00006a74 <_get_valve_temperature>:
int16_t get_valve_temperature(void)
{
	return valve.diag.temp.deg;
}
    6a74:	72d8 126c 	lod	A, 0x126c <.LLST28+0xd>
    6a78:	5401      	ret

00006a7a <_get_valve_motCurrent>:
uint16_t get_valve_motCurrent(void)
{
	return valve.diag.motorCurrent;
}
    6a7a:	72d8 127e 	lod	A, 0x127e <.LASF1443+0x2>
    6a7e:	5401      	ret

00006a80 <_AppValveInit>:

void AppValveInit(void)
{

	valve.state = VALVE_INIT;
    6a80:	7000      	lod	A, #0
    6a82:	52d8 1216 	mov	0x1216 <_valve>, A

00006a86 <.LM303>:
	valve.lastState = VALVE_INIT;
    6a86:	52d8 1218 	mov	0x1218 <_valve+0x2>, A

00006a8a <.LM304>:
	valve.elapsedTime = 0;
    6a8a:	0ea7      	lod	C, ML.7
    6a8c:	52d8 121c 	mov	0x121c <.LASF1421+0x3>, A

00006a90 <.LM305>:
	valve.sleepState = 0;
    6a90:	52d8 1220 	mov	0x1220 <.LASF1421+0x7>, A

00006a94 <.LM306>:
	valve.initStatus = 0;
	valve.linLiveTimeOut = 4000;
    6a94:	7eda 0fa0 	lod	X, #4000
    6a98:	0ea7      	lod	C, ML.7
    6a9a:	5ed8 121a 	mov	0x121a <.LASF1421+0x1>, X

00006a9e <.LM307>:
	valve.pos.currentAngle = 0;
	valve.pos.targetAngle = 0;
    6a9e:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A
    6aa2:	52d8 1226 	mov	0x1226 <.LASF1421+0xd>, A

00006aa6 <.LM308>:
	valve.lastState = VALVE_INIT;
	valve.elapsedTime = 0;
	valve.sleepState = 0;
	valve.initStatus = 0;
	valve.linLiveTimeOut = 4000;
	valve.pos.currentAngle = 0;
    6aa6:	0ea7      	lod	C, ML.7
    6aa8:	7eda 0b45 	lod	X, #2885
    6aac:	5ed8 1228 	mov	0x1228 <.LASF1421+0xf>, X

00006ab0 <.LM309>:
	valve.pos.targetAngle = 0;
	valve.pos.modeAngle[C_MODE_A] = (int16_t)C_VALVE_MODE_A_ANGLE;
    6ab0:	7eda 07c1 	lod	X, #1985
    6ab4:	0ea7      	lod	C, ML.7
    6ab6:	5ed8 122a 	mov	0x122a <.LASF1421+0x11>, X

00006aba <.LM310>:
	valve.pos.modeAngle[C_MODE_B] = (int16_t)C_VALVE_MODE_B_ANGLE;
    6aba:	52d8 122c 	mov	0x122c <.LLST5>, A

00006abe <.LM311>:
	valve.pos.fault = 0;
	valve.pos.retryCnt = 0;

	valve.calibration.req2Cal = 0;
    6abe:	42d8 1230 	mov	0x1230 <.Lframe0>, AL

00006ac2 <.LM312>:
	valve.calibration.req1Cal = 0;
    6ac2:	0ea7      	lod	C, ML.7
    6ac4:	42d8 1231 	mov	0x1231 <.Lframe0+0x1>, AL

00006ac8 <.LM313>:
	valve.calibration.offsetDone = 0;
    6ac8:	42d8 122f 	mov	0x122f <.LLST5+0x3>, AL

00006acc <.LM314>:
	valve.comm.ForcedDiag = 0;
	valve.comm.targetMode = 0xFFu;
	valve.comm.lastMode = 0xFFu;
	valve.comm.actualMode = C_MODE_B;
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
    6acc:	7eda 1388 	lod	X, #5000
    6ad0:	0ea7      	lod	C, ML.7
    6ad2:	5ed8 123c 	mov	0x123c <.Lframe0+0xc>, X
    6ad6:	7eda 00ff 	lod	X, #255
    6ada:	5ed8 123e 	mov	0x123e <.Lframe0+0xe>, X

00006ade <.LM315>:
	valve.calibration.req2Cal = 0;
	valve.calibration.req1Cal = 0;
	valve.calibration.offsetDone = 0;

	valve.comm.Initial = 0;
	valve.comm.Enable = 0;
    6ade:	0ea7      	lod	C, ML.7
    6ae0:	52d8 1240 	mov	0x1240 <.LLST27+0x1>, A

00006ae4 <.LM316>:
	valve.comm.ForcedDiag = 0;
    6ae4:	7eda 01ff 	lod	X, #511
    6ae8:	5ed8 1242 	mov	0x1242 <.LLST27+0x3>, X

00006aec <.LM317>:
	valve.comm.targetMode = 0xFFu;
	valve.comm.lastMode = 0xFFu;
	valve.comm.actualMode = C_MODE_B;
    6aec:	0ea7      	lod	C, ML.7
    6aee:	52d8 1244 	mov	0x1244 <.LLST27+0x5>, A

00006af2 <.LM318>:
	valve.diag.calFault = 0;
	valve.diag.motorFault = 0;
	valve.diag.stallFault = 0;
	valve.diag.McuFault = 0;
	valve.diag.mcuRetryCnt = 0;
	valve.diag.vs.state = VS_UNDEF;
    6af2:	7803      	lod	Y, #3
    6af4:	5ad8 1256 	mov	0x1256 <.LASF1692+0xb>, Y

00006af8 <.LM319>:
	valve.diag.vs.UVretryCnt = 0;
    6af8:	0ea7      	lod	C, ML.7
    6afa:	52d8 125e 	mov	0x125e <.LASF1692+0x13>, A

00006afe <.LM320>:
	valve.diag.vs.OVretryCnt = 0;
    6afe:	52d8 1260 	mov	0x1260 <.LLST28+0x1>, A

00006b02 <.LM321>:
	valve.diag.ign.state = IGN_UNDEF;
    6b02:	7c02      	lod	X, #2
    6b04:	0ea7      	lod	C, ML.7
    6b06:	5ed8 1270 	mov	0x1270 <.LLST28+0x11>, X

00006b0a <.LM322>:
	valve.diag.ign.uvTimer = 0;
    6b0a:	52d8 1274 	mov	0x1274 <.LLST29+0x2>, A

00006b0e <.LM323>:
	valve.diag.temp.state = TEMPERATURE_UNDEF;
    6b0e:	5ad8 1268 	mov	0x1268 <.LLST28+0x9>, Y

00006b12 <.LM324>:
	valve.diag.temp.retryCnt = 0;
    6b12:	0ea7      	lod	C, ML.7
    6b14:	52d8 126a 	mov	0x126a <.LLST28+0xb>, A

00006b18 <.LM325>:
	valve.diag.gmr.state = 0;
    6b18:	42d8 1276 	mov	0x1276 <.LLST29+0x4>, AL

00006b1c <.LM326>:
	valve.diag.gmr.retryCnt = 0;
    6b1c:	52d8 1278 	mov	0x1278 <.LLST29+0x6>, A

00006b20 <.LM327>:
	valve.diag.calRetryCnt = 0;
	valve.diag.ObstructionRetryCnt = 0;
	valve.diag.motOcRetryCnt = 0;
	valve.diag.motOpenRetryCnt = 0;
	valve.diag.motShortRetryCnt = 0;
	valve.diag.linError = 0;
    6b20:	0ea7      	lod	C, ML.7
    6b22:	52d8 1280 	mov	0x1280 <.LASF1443+0x4>, A

00006b26 <.LM328>:
	valve.comm.faultMode = 0;

	valve.diag.calFault = 0;
	valve.diag.motorFault = 0;
	valve.diag.stallFault = 0;
	valve.diag.McuFault = 0;
    6b26:	52d8 1282 	mov	0x1282 <.LASF1443+0x6>, A

00006b2a <.LM329>:
	valve.diag.mcuRetryCnt = 0;
    6b2a:	52d8 1284 	mov	0x1284 <.LASF1443+0x8>, A

00006b2e <.LM330>:
	valve.comm.actualMode = C_MODE_B;
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
	valve.comm.faultMode = 0;

	valve.diag.calFault = 0;
    6b2e:	0ea7      	lod	C, ML.7
    6b30:	52d8 1286 	mov	0x1286 <.LASF1443+0xa>, A

00006b34 <.LM331>:
	valve.diag.motorFault = 0;
	valve.diag.stallFault = 0;
    6b34:	52d8 1288 	mov	0x1288 <.LASF1443+0xc>, A

00006b38 <.LM332>:
	valve.diag.temp.state = TEMPERATURE_UNDEF;
	valve.diag.temp.retryCnt = 0;
	valve.diag.gmr.state = 0;
	valve.diag.gmr.retryCnt = 0;
	valve.diag.stallRetryCnt = 0;
	valve.diag.calRetryCnt = 0;
    6b38:	52d8 128a 	mov	0x128a <.LASF1443+0xe>, A

00006b3c <.LM333>:
	valve.diag.ObstructionRetryCnt = 0;
	valve.diag.motOcRetryCnt = 0;
	valve.diag.motOpenRetryCnt = 0;
    6b3c:	0ea7      	lod	C, ML.7
    6b3e:	42d8 128c 	mov	0x128c <.LASF1443+0x10>, AL

00006b42 <.LM334>:
	valve.diag.motShortRetryCnt = 0;
	valve.diag.linError = 0;
	valve.diag.comm.state = COMMUNICATION_UNDEF;
    6b42:	5ed8 1262 	mov	0x1262 <.LLST28+0x3>, X

00006b46 <.LM335>:
	valve.diag.comm.linErrRetryCnt = 0;
    6b46:	52d8 1264 	mov	0x1264 <.LLST28+0x5>, A

00006b4a <.LM336>:
	if (eeprom_ReadValveConfig(&valve_gmr_data))
    6b4a:	0ea7      	lod	C, ML.7
    6b4c:	72da 134a 	lod	A, #4938
    6b50:	82db 4467 	callf	0x88ce <_eeprom_ReadValveConfig>
    6b54:	ac00      	cmp	A, #0
    6b56:	1913      	je	0x6b7e <.L211>

00006b58 <.LM337>:
	{
		valve.memory.offset = (int16_t)valve_gmr_data.E1DATA0; // 250709-2 - EEPROM Load 1st -> Global Variables
    6b58:	72d8 134a 	lod	A, 0x134a <_valve_gmr_data>
    6b5c:	52d8 124e 	mov	0x124e <.LASF1692+0x3>, A

00006b60 <.LM338>:
		if ((valve.memory.offset > 0) && (valve.memory.offset <= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT))
    6b60:	7ee2      	lod	X, A
    6b62:	20ff      	add	X, #-1
    6b64:	2eda 0e0f 	cmp	X, #3599
    6b68:	1e02      	jug	0x6b6e <.L212>

00006b6a <.LM339>:
		{

			set_gmr_sensor_offset(valve.memory.offset);
    6b6a:	82db 3cec 	callf	0x79d8 <_set_gmr_sensor_offset>

00006b6e <.L212>:
		}
		valve.memory.lastAngle = (int16_t)valve_gmr_data.E1DATA1; // 250709-2 - EEPROM Load 2nd -> Global Variables
		valve.memory.code_1 = valve_gmr_data.E1DATA2;			  // 250709-2 - EEPROM Load 3rd -> Global Variables
    6b6e:	7ada 1250 	lod	Y, #4688
    6b72:	7eda 134c 	lod	X, #4940
    6b76:	0ea7      	lod	C, ML.7
    6b78:	54ce      	movsw	[Y++], [X++]
    6b7a:	0ea7      	lod	C, ML.7
    6b7c:	54ce      	movsw	[Y++], [X++]

00006b7e <.L211>:
	}
	else
	{
	}
	if (eeprom_ReadDiagConfig(&valve_diag_data))
    6b7e:	72da 1344 	lod	A, #4932
    6b82:	82db 44a8 	callf	0x8950 <_eeprom_ReadDiagConfig>
    6b86:	ac00      	cmp	A, #0
    6b88:	1912      	je	0x6bae <.L210>

00006b8a <.LM342>:
	{
		valve.memory.state = valve_diag_data.E1DATA0;
    6b8a:	7ed8 1344 	lod	X, 0x1344 <_valve_diag_data>
    6b8e:	5ed8 1248 	mov	0x1248 <.LLST27+0x9>, X

00006b92 <.LM343>:
		valve.memory.value = valve_diag_data.E1DATA1;
    6b92:	72d8 1346 	lod	A, 0x1346 <_valve_diag_data+0x2>
    6b96:	0ea7      	lod	C, ML.7
    6b98:	52d8 124c 	mov	0x124c <.LASF1692+0x1>, A

00006b9c <.LM344>:
		valve.memory.code_2 = valve_diag_data.E1DATA2;
    6b9c:	7ad8 1348 	lod	Y, 0x1348 <.LLST25+0x1>
    6ba0:	5ad8 1254 	mov	0x1254 <.LASF1692+0x9>, Y

00006ba4 <.LM345>:
		u16EventState = valve.memory.state;
    6ba4:	0ea7      	lod	C, ML.7
    6ba6:	5ed8 10b6 	mov	0x10b6 <_u16EventState>, X

00006baa <.LM346>:
		u16EventValue = valve.memory.value;
    6baa:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00006bae <.L210>:
	}
	else
	{
	}
}
    6bae:	5401      	ret

00006bb0 <_AppValveTask>:
 * \brief Actuator task called by every 1ms
 *
 */

void AppValveTask(void)
{
    6bb0:	580b      	inc	S, #12

00006bb2 <.LBB390>:
}


static void valveDiagVs(void)
{
	valve.diag.vs.voltage = get_conv_supply_voltage();
    6bb2:	82db 3d4a 	callf	0x7a94 <_get_conv_supply_voltage>

00006bb6 <.LVL139>:
    6bb6:	52d8 1258 	mov	0x1258 <.LASF1692+0xd>, A

00006bba <.LM350>:

	switch (valve.diag.vs.state)
    6bba:	7ed8 1256 	lod	X, 0x1256 <.LASF1692+0xb>
    6bbe:	2c01      	cmp	X, #1
    6bc0:	1d01      	jne	0x6bc4 <.LM350+0xa>
    6bc2:	004b      	jmp	0x6c5a <.L222>
    6bc4:	180a      	jc	0x6bda <.L223>
    6bc6:	2c02      	cmp	X, #2
    6bc8:	1d01      	jne	0x6bcc <.LM351>
    6bca:	0061      	jmp	0x6c8e <.L224>

00006bcc <.LM351>:
				}
			}
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
    6bcc:	7000      	lod	A, #0
    6bce:	52d8 125a 	mov	0x125a <.LASF1692+0xf>, A

00006bd2 <.LM352>:
		valve.diag.vs.ovTimer = 0u;
    6bd2:	52d8 125c 	mov	0x125c <.LASF1692+0x11>, A
    6bd6:	0ea7      	lod	C, ML.7
    6bd8:	0021      	jmp	0x6c1c <.L531>

00006bda <.L223>:
	valve.diag.vs.voltage = get_conv_supply_voltage();

	switch (valve.diag.vs.state)
	{
	case VS_NORMAL:
		if (valve.diag.vs.voltage < VS_UNDER_STOP)
    6bda:	aeda 031f 	cmp	A, #799
    6bde:	1e21      	jug	0x6c22 <.L225>

00006be0 <.LM354>:
		{
			valve.diag.vs.uvTimer++;
    6be0:	72d8 125a 	lod	A, 0x125a <.LASF1692+0xf>
    6be4:	a001      	add	A, #1

00006be6 <.LM355>:
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
    6be6:	aeda 00c7 	cmp	A, #199
    6bea:	1e14      	jug	0x6c14 <.L226>

00006bec <.LM356>:
	switch (valve.diag.vs.state)
	{
	case VS_NORMAL:
		if (valve.diag.vs.voltage < VS_UNDER_STOP)
		{
			valve.diag.vs.uvTimer++;
    6bec:	52d8 125a 	mov	0x125a <.LASF1692+0xf>, A

00006bf0 <.L227>:
	break;
	}
}
static void valveDiagTemp(void)
{
	valve.diag.temp.deg = get_conv_ic_temperature();
    6bf0:	82db 3d4d 	callf	0x7a9a <_get_conv_ic_temperature>
    6bf4:	52d8 126c 	mov	0x126c <.LLST28+0xd>, A

00006bf8 <.LM358>:

	switch (valve.diag.temp.state)
    6bf8:	7ed8 1268 	lod	X, 0x1268 <.LLST28+0x9>
    6bfc:	2c01      	cmp	X, #1
    6bfe:	1d01      	jne	0x6c02 <.LM358+0xa>
    6c00:	006b      	jmp	0x6cd8 <.L237>
    6c02:	1c01      	jnc	0x6c06 <.LASF1183+0x3>
    6c04:	0056      	jmp	0x6cb2 <.L238>
    6c06:	2c02      	cmp	X, #2
    6c08:	1d01      	jne	0x6c0c <.L526>
    6c0a:	006f      	jmp	0x6cea <.L239>

00006c0c <.L526>:

			}
			else
#endif
	{
		valve.diag.temp.timer = 0u;
    6c0c:	7000      	lod	A, #0
    6c0e:	52d8 126e 	mov	0x126e <.LLST28+0xf>, A
    6c12:	005f      	jmp	0x6cd2 <.L534>

00006c14 <.L226>:
		if (valve.diag.vs.voltage < VS_UNDER_STOP)
		{
			valve.diag.vs.uvTimer++;
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.uvTimer = 0u;
    6c14:	7000      	lod	A, #0
    6c16:	52d8 125a 	mov	0x125a <.LASF1692+0xf>, A

00006c1a <.LM361>:
				valve.diag.vs.state = VS_UNDERVOLTAGE;
    6c1a:	7001      	lod	A, #1

00006c1c <.L531>:
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
		valve.diag.vs.ovTimer = 0u;
		valve.diag.vs.state = VS_NORMAL;
    6c1c:	52d8 1256 	mov	0x1256 <.LASF1692+0xb>, A
    6c20:	07e7      	jmp	0x6bf0 <.L227>

00006c22 <.L225>:
    6c22:	7ed8 125c 	lod	X, 0x125c <.LASF1692+0x11>

00006c26 <.LM363>:
			{
				valve.diag.vs.uvTimer = 0u;
				valve.diag.vs.state = VS_UNDERVOLTAGE;
			}
		}
		else if (valve.diag.vs.voltage > VS_OVER_STOP)
    6c26:	aeda 06a4 	cmp	A, #1700
    6c2a:	1a0d      	jule	0x6c46 <.L228>

00006c2c <.LM364>:
		{
			valve.diag.vs.ovTimer++;
    6c2c:	2001      	add	X, #1

00006c2e <.LM365>:
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
    6c2e:	2eda 00c7 	cmp	X, #199
    6c32:	1e03      	jug	0x6c3a <.L229>

00006c34 <.L530>:
		else
		{
#if 1
			if (valve.diag.vs.ovTimer > 0)
			{
				valve.diag.vs.ovTimer--;
    6c34:	5ed8 125c 	mov	0x125c <.LASF1692+0x11>, X
    6c38:	07db      	jmp	0x6bf0 <.L227>

00006c3a <.L229>:
		else if (valve.diag.vs.voltage > VS_OVER_STOP)
		{
			valve.diag.vs.ovTimer++;
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.ovTimer = 0u;
    6c3a:	7000      	lod	A, #0
    6c3c:	52d8 125c 	mov	0x125c <.LASF1692+0x11>, A

00006c40 <.LM368>:
				valve.diag.vs.state = VS_OVERVOLTAGE;
    6c40:	7002      	lod	A, #2
    6c42:	0ea7      	lod	C, ML.7
    6c44:	07eb      	jmp	0x6c1c <.L531>

00006c46 <.L228>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
    6c46:	72d8 125a 	lod	A, 0x125a <.LASF1692+0xf>
    6c4a:	1903      	je	0x6c52 <.L234>

00006c4c <.LM370>:
			{
				valve.diag.vs.uvTimer--;
    6c4c:	a0ff      	add	A, #-1
    6c4e:	52d8 125a 	mov	0x125a <.LASF1692+0xf>, A

00006c52 <.L234>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.ovTimer > 0)
    6c52:	2c00      	cmp	X, #0
    6c54:	194d      	je	0x6bf0 <.L227>

00006c56 <.LM372>:
			{
				valve.diag.vs.ovTimer--;
    6c56:	20ff      	add	X, #-1
    6c58:	07ed      	jmp	0x6c34 <.L530>

00006c5a <.L222>:
    6c5a:	7ed8 125a 	lod	X, 0x125a <.LASF1692+0xf>

00006c5e <.LM373>:
#endif
		}
		break;
	case VS_UNDERVOLTAGE:

		if (valve.diag.vs.voltage > VS_UNDER_RETURN)
    6c5e:	aeda 0384 	cmp	A, #900
    6c62:	1a10      	jule	0x6c84 <.L232>

00006c64 <.LM374>:
		{
			valve.diag.vs.uvTimer++;
    6c64:	2001      	add	X, #1

00006c66 <.LM375>:
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
    6c66:	2eda 00c7 	cmp	X, #199
    6c6a:	1e03      	jug	0x6c72 <.L233>

00006c6c <.L529>:
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
			{
				valve.diag.vs.uvTimer--;
    6c6c:	5ed8 125a 	mov	0x125a <.LASF1692+0xf>, X
    6c70:	07bf      	jmp	0x6bf0 <.L227>

00006c72 <.L233>:
		if (valve.diag.vs.voltage > VS_UNDER_RETURN)
		{
			valve.diag.vs.uvTimer++;
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.uvTimer = 0u;
    6c72:	7000      	lod	A, #0
    6c74:	52d8 125a 	mov	0x125a <.LASF1692+0xf>, A

00006c78 <.LM378>:
				valve.diag.vs.state = VS_NORMAL;
    6c78:	52d8 1256 	mov	0x1256 <.LASF1692+0xb>, A

00006c7c <.LBB392>:
{
	switch(event_state)
	{
		/* --- Protection state Errors --- */
		case VS_LOW_ERROR :
			valve.diag.vs.UVretryCnt = CLEAR;	// Clear Under Voltage retry count
    6c7c:	0ea7      	lod	C, ML.7
    6c7e:	52d8 125e 	mov	0x125e <.LASF1692+0x13>, A
    6c82:	07b6      	jmp	0x6bf0 <.L227>

00006c84 <.L232>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
    6c84:	2c00      	cmp	X, #0
    6c86:	1d01      	jne	0x6c8a <.LM381>
    6c88:	07b3      	jmp	0x6bf0 <.L227>

00006c8a <.LM381>:
			{
				valve.diag.vs.uvTimer--;
    6c8a:	20ff      	add	X, #-1
    6c8c:	07ef      	jmp	0x6c6c <.L529>

00006c8e <.L224>:
    6c8e:	7ed8 125c 	lod	X, 0x125c <.LASF1692+0x11>

00006c92 <.LM382>:
#endif
		}
		break;
	case VS_OVERVOLTAGE:

		if (valve.diag.vs.voltage < VS_OVER_RETURN)
    6c92:	aeda 063f 	cmp	A, #1599
    6c96:	1e5d      	jug	0x6c52 <.L234>

00006c98 <.LM383>:
		{
			valve.diag.vs.ovTimer++;
    6c98:	2001      	add	X, #1

00006c9a <.LM384>:
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
    6c9a:	2eda 00c7 	cmp	X, #199
    6c9e:	1a4a      	jule	0x6c34 <.L530>

00006ca0 <.LM385>:
			{
				valve.diag.vs.ovTimer = 0u;
    6ca0:	7000      	lod	A, #0
    6ca2:	52d8 125c 	mov	0x125c <.LASF1692+0x11>, A

00006ca6 <.LM386>:
				valve.diag.vs.state = VS_NORMAL;
    6ca6:	52d8 1256 	mov	0x1256 <.LASF1692+0xb>, A

00006caa <.LBB394>:
		/* --- Protection state Errors --- */
		case VS_LOW_ERROR :
			valve.diag.vs.UVretryCnt = CLEAR;	// Clear Under Voltage retry count
			break;
		case VS_HIGH_ERROR : 
			valve.diag.vs.OVretryCnt = CLEAR;	// Clear Over Voltage retry count
    6caa:	0ea7      	lod	C, ML.7
    6cac:	52d8 1260 	mov	0x1260 <.LLST28+0x1>, A
    6cb0:	079f      	jmp	0x6bf0 <.L227>

00006cb2 <.L238>:
    6cb2:	7ed8 126e 	lod	X, 0x126e <.LLST28+0xf>

00006cb6 <.LBE394>:
	valve.diag.temp.deg = get_conv_ic_temperature();

	switch (valve.diag.temp.state)
	{
	case TEMPERATURE_NORMAL:
		if (valve.diag.temp.deg > (int16_t)TEMP_OVER_STOP)
    6cb6:	aeda 00af 	cmp	A, #175
    6cba:	1f01      	jsg	0x6cbe <.LM389>
    6cbc:	0041      	jmp	0x6d40 <.L246>

00006cbe <.LM389>:
		{
			valve.diag.temp.timer++;
    6cbe:	2001      	add	X, #1

00006cc0 <.LM390>:
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
    6cc0:	2c63      	cmp	X, #99
    6cc2:	1e03      	jug	0x6cca <.L241>

00006cc4 <.L536>:
		else
		{
#if 1
			if (valve.diag.temp.timer > 0)
			{
				valve.diag.temp.timer--;
    6cc4:	5ed8 126e 	mov	0x126e <.LLST28+0xf>, X
    6cc8:	0020      	jmp	0x6d0a <.L242>

00006cca <.L241>:
		if (valve.diag.temp.deg > (int16_t)TEMP_OVER_STOP)
		{
			valve.diag.temp.timer++;
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
			{
				valve.diag.temp.timer = 0u;
    6cca:	7000      	lod	A, #0
    6ccc:	52d8 126e 	mov	0x126e <.LLST28+0xf>, A

00006cd0 <.LM393>:
				valve.diag.temp.state = TEMPERATURE_HIGH;
    6cd0:	7002      	lod	A, #2

00006cd2 <.L534>:
			}
			else
#endif
	{
		valve.diag.temp.timer = 0u;
		valve.diag.temp.state = TEMPERATURE_NORMAL;
    6cd2:	52d8 1268 	mov	0x1268 <.LLST28+0x9>, A
    6cd6:	0019      	jmp	0x6d0a <.L242>

00006cd8 <.L237>:
    6cd8:	7ed8 126e 	lod	X, 0x126e <.LLST28+0xf>

00006cdc <.LM395>:
#endif
		}
		break;
	case TEMPERATURE_LOW:

		if (valve.diag.temp.deg >= (int16_t)TEMP_UNDER_RETURN)
    6cdc:	ac31      	cmp	A, #49
    6cde:	1b30      	jsle	0x6d40 <.L246>

00006ce0 <.LM396>:
		{
			valve.diag.temp.timer++;
    6ce0:	2001      	add	X, #1

00006ce2 <.LM397>:
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
    6ce2:	2c63      	cmp	X, #99
    6ce4:	1a01      	jule	0x6ce8 <.LM397+0x6>
    6ce6:	0792      	jmp	0x6c0c <.L526>
    6ce8:	07ed      	jmp	0x6cc4 <.L536>

00006cea <.L239>:
    6cea:	7ed8 126e 	lod	X, 0x126e <.LLST28+0xf>

00006cee <.LM398>:
#endif
		}
		break;
	case TEMPERATURE_HIGH:

		if (valve.diag.temp.deg <= (int16_t)TEMP_OVER_RETURN)
    6cee:	aeda 00a5 	cmp	A, #165
    6cf2:	1f26      	jsg	0x6d40 <.L246>

00006cf4 <.LM399>:
		{
			valve.diag.temp.timer++;
    6cf4:	2001      	add	X, #1

00006cf6 <.LM400>:
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
    6cf6:	2c63      	cmp	X, #99
    6cf8:	1a65      	jule	0x6cc4 <.L536>

00006cfa <.LM401>:
			{
				valve.diag.temp.timer = 0u;
    6cfa:	7000      	lod	A, #0
    6cfc:	52d8 126e 	mov	0x126e <.LLST28+0xf>, A

00006d00 <.LM402>:
				valve.diag.temp.state = TEMPERATURE_NORMAL;
    6d00:	52d8 1268 	mov	0x1268 <.LLST28+0x9>, A

00006d04 <.LM403>:

				valve.diag.temp.retryCnt = 0;
    6d04:	0ea7      	lod	C, ML.7
    6d06:	52d8 126a 	mov	0x126a <.LLST28+0xb>, A

00006d0a <.L242>:
	}
}
static void valveDiagIgn(void)
{
	static uint16_t ignNormalTimer = 0;
	valve.diag.ign.voltage = get_conv_ignition_voltage();
    6d0a:	82db 3de9 	callf	0x7bd2 <_get_conv_ignition_voltage>
    6d0e:	52d8 1272 	mov	0x1272 <.LLST29>, A

00006d12 <.LM405>:

#if LIN_DEBUG_ENABLE
	g_u16DebugData[3] = valve.diag.ign.state;
    6d12:	7ed8 1270 	lod	X, 0x1270 <.LLST28+0x11>
    6d16:	5ed8 11c0 	mov	0x11c0 <.LASF1797>, X

00006d1a <.LM406>:
#endif


	switch (valve.diag.ign.state)
    6d1a:	1916      	je	0x6d48 <.L249>
    6d1c:	2c01      	cmp	X, #1
    6d1e:	1d01      	jne	0x6d22 <.LM407>
    6d20:	0032      	jmp	0x6d86 <.L250>

00006d22 <.LM407>:
			}
		}
		break;

	default: /* VS_INIT */
		if (valve.diag.ign.voltage > IGN_UNDER_STOP)
    6d22:	aeda 02bc 	cmp	A, #700
    6d26:	1e01      	jug	0x6d2a <.LM408>
    6d28:	0065      	jmp	0x6df4 <.L257>

00006d2a <.LM408>:
		{
			ignNormalTimer += 1;
    6d2a:	72d8 10b2 	lod	A, 0x10b2 <___ignNormalTimer_5517>
    6d2e:	a001      	add	A, #1
    6d30:	52d8 10b2 	mov	0x10b2 <___ignNormalTimer_5517>, A
    6d34:	7c00      	lod	X, #0

00006d36 <.LM409>:
			if (ignNormalTimer >= 10u)
    6d36:	ac09      	cmp	A, #9
    6d38:	1a23      	jule	0x6d80 <.L258>

00006d3a <.LM410>:
			{
				valve.diag.ign.state = IGN_NORMAL;
    6d3a:	5ed8 1270 	mov	0x1270 <.LLST28+0x11>, X
    6d3e:	0020      	jmp	0x6d80 <.L258>

00006d40 <.L246>:
			}
		}
		else
		{
#if 1
			if (valve.diag.temp.timer > 0)
    6d40:	2c00      	cmp	X, #0
    6d42:	1963      	je	0x6d0a <.L242>

00006d44 <.LM412>:
			{
				valve.diag.temp.timer--;
    6d44:	20ff      	add	X, #-1
    6d46:	07be      	jmp	0x6cc4 <.L536>

00006d48 <.L249>:
    6d48:	7ed8 1274 	lod	X, 0x1274 <.LLST29+0x2>

00006d4c <.LM413>:


	switch (valve.diag.ign.state)
	{
	case IGN_NORMAL:
		if (valve.diag.ign.voltage <= IGN_UNDER_STOP)
    6d4c:	aeda 02bc 	cmp	A, #700
    6d50:	1e14      	jug	0x6d7a <.L251>

00006d52 <.LM414>:
		{
			valve.diag.ign.uvTimer++;
    6d52:	2001      	add	X, #1
    6d54:	5ed8 1274 	mov	0x1274 <.LLST29+0x2>, X

00006d58 <.LM415>:
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
    6d58:	2eda 01f3 	cmp	X, #499
    6d5c:	1a0a      	jule	0x6d72 <.L261>

00006d5e <.L260>:
			{
				valve.diag.ign.uvTimer = 0u;
    6d5e:	7000      	lod	A, #0
    6d60:	52d8 1274 	mov	0x1274 <.LLST29+0x2>, A

00006d64 <.LM417>:
				valve.diag.ign.state = IGN_OFF;
    6d64:	7001      	lod	A, #1

00006d66 <.L537>:
		{
			valve.diag.ign.uvTimer++;
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
			{
				valve.diag.ign.uvTimer = 0u;
				valve.diag.ign.state = IGN_NORMAL;
    6d66:	52d8 1270 	mov	0x1270 <.LLST28+0x11>, A

00006d6a <.L253>:

static void ValvePowerOffTask(void)
{
	int16_t cOffset = 0, cPos = 0, diff = 0;

	if (valve.diag.ign.state == IGN_OFF)
    6d6a:	72d8 1270 	lod	A, 0x1270 <.LLST28+0x11>
    6d6e:	ac01      	cmp	A, #1
    6d70:	1915      	je	0x6d9c <.L396>

00006d72 <.L261>:
			}
		}
	}
	else
	{
		valve.ignOffCnt = 0;
    6d72:	7000      	lod	A, #0
    6d74:	52d8 121e 	mov	0x121e <.LASF1421+0x5>, A
    6d78:	0033      	jmp	0x6de0 <.L538>

00006d7a <.L251>:
				valve.diag.ign.state = IGN_OFF;
			}
		}
		else
		{
			if (valve.diag.ign.uvTimer > 0)
    6d7a:	2c00      	cmp	X, #0
    6d7c:	197a      	je	0x6d72 <.L261>

00006d7e <.L557>:
		}
		else
		{
			if (valve.diag.ign.uvTimer > 0)
			{
				valve.diag.ign.uvTimer--;
    6d7e:	20ff      	add	X, #-1

00006d80 <.L258>:
			ignNormalTimer += 1;
			if (ignNormalTimer >= 10u)
			{
				valve.diag.ign.state = IGN_NORMAL;
			}
			valve.diag.ign.uvTimer = 0u;
    6d80:	5ed8 1274 	mov	0x1274 <.LLST29+0x2>, X
    6d84:	07f2      	jmp	0x6d6a <.L253>

00006d86 <.L250>:
    6d86:	7ed8 1274 	lod	X, 0x1274 <.LLST29+0x2>

00006d8a <.LM424>:
		}
		break;

	case IGN_OFF:

		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
    6d8a:	aeda 031f 	cmp	A, #799
    6d8e:	1a2f      	jule	0x6dee <.L254>

00006d90 <.LM425>:
		{
			valve.diag.ign.uvTimer++;
    6d90:	2001      	add	X, #1

00006d92 <.LM426>:
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
    6d92:	2eda 01f3 	cmp	X, #499
    6d96:	1e27      	jug	0x6de6 <.L255>

00006d98 <.LM427>:

	case IGN_OFF:

		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
		{
			valve.diag.ign.uvTimer++;
    6d98:	5ed8 1274 	mov	0x1274 <.LLST29+0x2>, X

00006d9c <.L396>:
{
	int16_t cOffset = 0, cPos = 0, diff = 0;

	if (valve.diag.ign.state == IGN_OFF)
	{
		if (valve.ignOffCnt < 0xffffu)
    6d9c:	72d8 121e 	lod	A, 0x121e <.LASF1421+0x5>
    6da0:	acff      	cmp	A, #-1
    6da2:	1903      	je	0x6daa <.L262>

00006da4 <.LM429>:
		{
			valve.ignOffCnt += 1;
    6da4:	a001      	add	A, #1
    6da6:	52d8 121e 	mov	0x121e <.LASF1421+0x5>, A

00006daa <.L262>:
		}

		if (valve.ignOffCnt >= 60000u) /*60sec*/
    6daa:	72d8 121e 	lod	A, 0x121e <.LASF1421+0x5>
    6dae:	aeda ea5f 	cmp	A, #59999
    6db2:	1e01      	jug	0x6db6 <.LM431>
    6db4:	006b      	jmp	0x6e8c <.L263>

00006db6 <.LM431>:
		{
			if (valve.sleepState == 0)
    6db6:	62d8 1220 	lod	AL, 0x1220 <.LASF1421+0x7>
    6dba:	66e0      	lod	YL, AL
    6dbc:	5cf6      	usex	Y
    6dbe:	8c00      	cmp	AL, #0
    6dc0:	1901      	je	0x6dc4 <.LM432>
    6dc2:	0032      	jmp	0x6e28 <.L264>

00006dc4 <.LM432>:
			{
				if ((check_fault_mode() == 0) && (check_protect_mode() == 0))
    6dc4:	82db 3243 	callf	0x6486 <_check_fault_mode>
    6dc8:	ac00      	cmp	A, #0
    6dca:	1d28      	jne	0x6e1c <.L265>
    6dcc:	82db 321c 	callf	0x6438 <_check_protect_mode>
    6dd0:	ac00      	cmp	A, #0
    6dd2:	1d24      	jne	0x6e1c <.L265>

00006dd4 <.LM433>:
				{
					ValveFaultReset();
    6dd4:	82db 3292 	callf	0x6524 <_ValveFaultReset>

00006dd8 <.LM434>:
					valve.calibration.req1Cal = 1;
    6dd8:	6001      	lod	AL, #1
    6dda:	42d8 1231 	mov	0x1231 <.Lframe0+0x1>, AL

00006dde <.L266>:
				else
				{
					ValveFaultReset();
					valve.calibration.req2Cal = 1;
				}
				valve.sleepState = 1;
    6dde:	6001      	lod	AL, #1

00006de0 <.L538>:
		}
	}
	else
	{
		valve.ignOffCnt = 0;
		valve.sleepState = 0;
    6de0:	42d8 1220 	mov	0x1220 <.LASF1421+0x7>, AL
    6de4:	0053      	jmp	0x6e8c <.L263>

00006de6 <.L255>:
		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
		{
			valve.diag.ign.uvTimer++;
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
			{
				valve.diag.ign.uvTimer = 0u;
    6de6:	7000      	lod	A, #0
    6de8:	52d8 1274 	mov	0x1274 <.LLST29+0x2>, A
    6dec:	07bc      	jmp	0x6d66 <.L537>

00006dee <.L254>:
				valve.diag.ign.state = IGN_NORMAL;
			}
		}
		else
		{
			if (valve.diag.ign.uvTimer > 0)
    6dee:	2c00      	cmp	X, #0
    6df0:	1955      	je	0x6d9c <.L396>
    6df2:	07c5      	jmp	0x6d7e <.L557>

00006df4 <.L257>:
    6df4:	7c00      	lod	X, #0

00006df6 <.LM439>:
			{
				valve.diag.ign.state = IGN_NORMAL;
			}
			valve.diag.ign.uvTimer = 0u;
		}
		else if (valve.diag.ign.voltage < IGN_UNDER_STOP)
    6df6:	aeda 02bc 	cmp	A, #700
    6dfa:	190b      	je	0x6e12 <.L259>

00006dfc <.LM440>:
		{
			valve.diag.ign.voltage = 0;
    6dfc:	5ed8 1272 	mov	0x1272 <.LLST29>, X

00006e00 <.LM441>:
			valve.diag.ign.uvTimer++;
    6e00:	72d8 1274 	lod	A, 0x1274 <.LLST29+0x2>
    6e04:	a001      	add	A, #1
    6e06:	52d8 1274 	mov	0x1274 <.LLST29+0x2>, A

00006e0a <.LM442>:
			if (valve.diag.ign.uvTimer >= 10u)
    6e0a:	ac09      	cmp	A, #9
    6e0c:	1a01      	jule	0x6e10 <.LM442+0x6>
    6e0e:	07a7      	jmp	0x6d5e <.L260>
    6e10:	07ac      	jmp	0x6d6a <.L253>

00006e12 <.L259>:
				valve.diag.ign.state = IGN_OFF;
			}
		}
		else
		{
			valve.diag.ign.uvTimer = 0u;
    6e12:	5ed8 1274 	mov	0x1274 <.LLST29+0x2>, X

00006e16 <.LM444>:
			ignNormalTimer = 0;
    6e16:	5ed8 10b2 	mov	0x10b2 <___ignNormalTimer_5517>, X
    6e1a:	07a7      	jmp	0x6d6a <.L253>

00006e1c <.L265>:
					ValveFaultReset();
					valve.calibration.req1Cal = 1;
				}
				else
				{
					ValveFaultReset();
    6e1c:	82db 3292 	callf	0x6524 <_ValveFaultReset>

00006e20 <.LM446>:
					valve.calibration.req2Cal = 1;
    6e20:	6001      	lod	AL, #1
    6e22:	42d8 1230 	mov	0x1230 <.Lframe0>, AL
    6e26:	07db      	jmp	0x6dde <.L266>

00006e28 <.L264>:
				}
				valve.sleepState = 1;
			}
			else
			{
				if (valve.state != VALVE_CALIBRATION)
    6e28:	72d8 1216 	lod	A, 0x1216 <_valve>
    6e2c:	ac05      	cmp	A, #5
    6e2e:	192e      	je	0x6e8c <.L263>

00006e30 <.LM448>:
				{
					if (valve.sleepState == 1)
    6e30:	ec01      	cmp	Y, #1
    6e32:	1d28      	jne	0x6e84 <.L267>

00006e34 <.LM449>:
					{
						cOffset = get_gmr_sensor_offset();
    6e34:	82db 3cef 	callf	0x79de <_get_gmr_sensor_offset>

00006e38 <.LM450>:
						cPos = valve.pos.currentAngle;
    6e38:	7ad8 1226 	lod	Y, 0x1226 <.LASF1421+0xd>

00006e3c <.LM451>:
						diff = cPos - valve.memory.lastAngle;
						if (diff < 0)
						{
							diff = -diff;
						}
						if ((cOffset != valve.memory.offset) || (diff > (int16_t)C_VALVE_ACCURACY_ANGLE))
    6e3c:	aed8 124e 	cmp	A, 0x124e <.LASF1692+0x3>
    6e40:	1d07      	jne	0x6e50 <.L268>

00006e42 <.LM452>:
				{
					if (valve.sleepState == 1)
					{
						cOffset = get_gmr_sensor_offset();
						cPos = valve.pos.currentAngle;
						diff = cPos - valve.memory.lastAngle;
    6e42:	7ee6      	lod	X, Y
    6e44:	2ad8 1250 	sub	X, 0x1250 <.LASF1692+0x5>

00006e48 <.LM453>:
						if (diff < 0)
						{
							diff = -diff;
						}
						if ((cOffset != valve.memory.offset) || (diff > (int16_t)C_VALVE_ACCURACY_ANGLE))
    6e48:	1d81      	jnn	0x6e4c <.L562>
    6e4a:	5cce      	neg	X

00006e4c <.L562>:
    6e4c:	2c14      	cmp	X, #20
    6e4e:	1b06      	jsle	0x6e5c <.L269>

00006e50 <.L268>:
						{
							valve_gmr_write((uint16_t)cOffset, (uint16_t)cPos, 0x5555);
    6e50:	54ca 5555 	pushw	#21845

00006e54 <.LCFI11>:
    6e54:	5adf      	push	Y

00006e56 <.LCFI12>:
    6e56:	82db 44e9 	callf	0x89d2 <_valve_gmr_write>

00006e5a <.LVL159>:
    6e5a:	5c03      	dec	S, #4

00006e5c <.L269>:
						}
						if ((u16EventState != valve.memory.state) || (u16EventValue != valve.memory.value))
    6e5c:	72d8 10b6 	lod	A, 0x10b6 <_u16EventState>
    6e60:	7ed8 10b4 	lod	X, 0x10b4 <_u16EventValue>
    6e64:	7ad8 1248 	lod	Y, 0x1248 <.LLST27+0x9>
    6e68:	eee2      	cmp	Y, A
    6e6a:	1d04      	jne	0x6e74 <.L270>
    6e6c:	7ad8 124c 	lod	Y, 0x124c <.LASF1692+0x1>
    6e70:	eeee      	cmp	Y, X
    6e72:	1906      	je	0x6e80 <.L271>

00006e74 <.L270>:
						{
							valve_diag_write(u16EventState, u16EventValue, 0xAAAA);
    6e74:	54ca aaaa 	pushw	#43690

00006e78 <.LCFI14>:
    6e78:	5edf      	push	X

00006e7a <.LCFI15>:
    6e7a:	82db 44f7 	callf	0x89ee <_valve_diag_write>
    6e7e:	5c03      	dec	S, #4

00006e80 <.L271>:
						}
						valve.sleepState = 2;
    6e80:	6002      	lod	AL, #2
    6e82:	07ae      	jmp	0x6de0 <.L538>

00006e84 <.L267>:
					}
					else
					{
						MotRequestHardStop();
    6e84:	82db 3f1c 	callf	0x7e38 <_MotRequestHardStop>

00006e88 <.LM459>:
						AppLinSleepEnter();
    6e88:	82db 3217 	callf	0x642e <_AppLinSleepEnter>

00006e8c <.L263>:
	valveDiagVs();
	valveDiagTemp();
	valveDiagIgn();

	ValvePowerOffTask();
	valve.motorMotion = MotGetState();
    6e8c:	82db 3f70 	callf	0x7ee0 <_MotGetState>
    6e90:	52d8 1222 	mov	0x1222 <.LASF1421+0x9>, A

00006e94 <.LM461>:
	valve.diag.motorFault = MotGetFaultState();
    6e94:	82db 3f77 	callf	0x7eee <_MotGetFaultState>
    6e98:	42d8 1286 	mov	0x1286 <.LASF1443+0xa>, AL

00006e9c <.LM462>:
	valve.diag.stallFault = MotGetStallState();
    6e9c:	82db 3f73 	callf	0x7ee6 <_MotGetStallState>
    6ea0:	42d8 1287 	mov	0x1287 <.LASF1443+0xb>, AL

00006ea4 <.LBB418>:
	}
}

static void valveDiagSensor(void)
{
	uint8_t sensor_f = SensorGetState();
    6ea4:	82db 3f7b 	callf	0x7ef6 <_SensorGetState>

00006ea8 <.LM464>:
	valve.diag.motorCurrent = get_conv_mot_current();
    6ea8:	5203      	mov	[S-4], A
    6eaa:	82db 3d58 	callf	0x7ab0 <_get_conv_mot_current>

00006eae <.LVL168>:
    6eae:	52d8 127e 	mov	0x127e <.LASF1443+0x2>, A

00006eb2 <.LM465>:

	if ((valve.state != VALVE_CALIBRATION) && (valve.motorMotion == MOTION_RUNNING))
    6eb2:	7ed8 1216 	lod	X, 0x1216 <_valve>
    6eb6:	7a03      	lod	Y, [S-4]
    6eb8:	2c05      	cmp	X, #5
    6eba:	1d01      	jne	0x6ebe <.LASF1075+0x1>
    6ebc:	0063      	jmp	0x6f84 <.L272>
    6ebe:	7ed8 1222 	lod	X, 0x1222 <.LASF1421+0x9>
    6ec2:	2c03      	cmp	X, #3
    6ec4:	1901      	je	0x6ec8 <.LASF1075+0xb>
    6ec6:	005e      	jmp	0x6f84 <.L272>
    6ec8:	7ed8 127c 	lod	X, 0x127c <.LASF1443>

00006ecc <.LM466>:
	{
		if ((valve.diag.motorCurrent < motor.stall.halfThd) && (sensor_f == C_STATUS_STOP))
    6ecc:	aed8 12d6 	cmp	A, 0x12d6 <.LASF2063+0x4>
    6ed0:	1801      	jc	0x6ed4 <.LM466+0x8>
    6ed2:	0051      	jmp	0x6f76 <.L273>
    6ed4:	ec02      	cmp	Y, #2
    6ed6:	1901      	je	0x6eda <.LM467>
    6ed8:	004e      	jmp	0x6f76 <.L273>

00006eda <.LM467>:
		{
			valve.diag.gmr.count += 1;
    6eda:	2001      	add	X, #1

00006edc <.L539>:
		}
		else
		{
			if (valve.diag.gmr.count > 0)
			{
				valve.diag.gmr.count -= 1;
    6edc:	5ed8 127c 	mov	0x127c <.LASF1443>, X

00006ee0 <.L274>:
			{
				clear_fail_safe_retry_cnt(SENSOR_OUT_ERROR);
			}
		}

		if (valve.diag.gmr.count > GMR_SENSOR_FAULT_TIME) /*20250715*/
    6ee0:	72d8 127c 	lod	A, 0x127c <.LASF1443>
    6ee4:	aeda 01f4 	cmp	A, #500
    6ee8:	1a07      	jule	0x6ef8 <.L276>

00006eea <.LM470>:
		{
			valve.diag.gmr.count = CLEAR;
    6eea:	7000      	lod	A, #0
    6eec:	52d8 127c 	mov	0x127c <.LASF1443>, A

00006ef0 <.LM471>:
			valve.diag.gmr.state = GMR_SENSOR_FAULT;
    6ef0:	6001      	lod	AL, #1
    6ef2:	0ea7      	lod	C, ML.7
    6ef4:	42d8 1276 	mov	0x1276 <.LLST29+0x4>, AL

00006ef8 <.L276>:
}

static void valveDiagMcu(void)
{
	static uint16_t LV_filterCnt = 0, HV_filterCnt = 0;
	uint16_t voltage = get_conv_vdda_voltage();
    6ef8:	82db 3d47 	callf	0x7a8e <_get_conv_vdda_voltage>
    6efc:	7ee2      	lod	X, A

00006efe <.LM473>:

	switch(valve.diag.McuFault)
    6efe:	62d8 1281 	lod	AL, 0x1281 <.LASF1443+0x5>

00006f02 <.LVL171>:
    6f02:	66e0      	lod	YL, AL
    6f04:	5cf6      	usex	Y
    6f06:	8c00      	cmp	AL, #0
    6f08:	1d01      	jne	0x6f0c <.LASF1008+0x1>
    6f0a:	0040      	jmp	0x6f8c <.L278>
    6f0c:	66e0      	lod	YL, AL
    6f0e:	5cf6      	usex	Y
    6f10:	ec01      	cmp	Y, #1
    6f12:	1d01      	jne	0x6f16 <.L277>
    6f14:	0054      	jmp	0x6fbe <.L279>

00006f16 <.L277>:
	valve.diag.stallFault = MotGetStallState();
	valveDiagSensor();
	valveDiagMcu();

	#if LIN_DEBUG_ENABLE
	g_u16DebugData[0] = valve.state;
    6f16:	7ada 1216 	lod	Y, #4630
    6f1a:	7ef0      	lod	X, [Y]
    6f1c:	5ed8 11ba 	mov	0x11ba <_g_u16DebugData>, X

00006f20 <.LM475>:
	#endif

	fault_err = check_fault_mode();
    6f20:	5a03      	mov	[S-4], Y
    6f22:	5e05      	mov	[S-6], X
    6f24:	82db 3243 	callf	0x6486 <_check_fault_mode>
    6f28:	5209      	mov	[S-10], A

00006f2a <.LM476>:
	protect_mode = check_protect_mode();
    6f2a:	82db 321c 	callf	0x6438 <_check_protect_mode>

00006f2e <.LVL175>:
    6f2e:	520b      	mov	[S-12], A

00006f30 <.LM477>:
	if ((valve.state != VALVE_FAULT) && (fault_err != 0))
    6f30:	7e05      	lod	X, [S-6]
    6f32:	7a03      	lod	Y, [S-4]
    6f34:	2c06      	cmp	X, #6
    6f36:	1d01      	jne	0x6f3a <.LM478>
    6f38:	005c      	jmp	0x6ff2 <.L284>

00006f3a <.LM478>:
    6f3a:	7209      	lod	A, [S-10]

00006f3c <.LVL177>:
    6f3c:	1d01      	jne	0x6f40 <.LM479>
    6f3e:	0059      	jmp	0x6ff2 <.L284>

00006f40 <.LM479>:
	{

		valve.initStatus = 1;
    6f40:	6001      	lod	AL, #1
    6f42:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

00006f46 <.LM480>:
		valve.elapsedTime = 0;
    6f46:	7000      	lod	A, #0
    6f48:	0ea7      	lod	C, ML.7
    6f4a:	52d8 121c 	mov	0x121c <.LASF1421+0x3>, A

00006f4e <.LM481>:
		valve.lastState = valve.state;
    6f4e:	5ed8 1218 	mov	0x1218 <_valve+0x2>, X

00006f52 <.LM482>:
		valve.state = VALVE_FAULT;
    6f52:	7006      	lod	A, #6
    6f54:	52f0      	mov	[Y], A

00006f56 <.L285>:
	}
	else
	{
	}

	valve.pos.currentAngle = MotGetCurrentPosition();
    6f56:	82db 3f3b 	callf	0x7e76 <_MotGetCurrentPosition>
    6f5a:	7ee2      	lod	X, A
    6f5c:	52d8 1226 	mov	0x1226 <.LASF1421+0xd>, A

00006f60 <.LBB428>:

static void calc_PosToLinData(int16_t currentAngle)
{
// #define CAL_POS_ANGLE_THD	(50* C_GMR_ANGLE_SCALE_FACTOR)
#define CAL_POS_ANGLE_THD (1 * C_GMR_ANGLE_SCALE_FACTOR)
	switch (valve.comm.actualMode)
    6f60:	62d8 1243 	lod	AL, 0x1243 <.LLST27+0x4>

00006f64 <.LVL180>:
    6f64:	1d01      	jne	0x6f68 <.LASF1363+0x3>
    6f66:	005b      	jmp	0x701e <.L287>
    6f68:	66e0      	lod	YL, AL
    6f6a:	5cf6      	usex	Y
    6f6c:	ec01      	cmp	Y, #1
    6f6e:	1d01      	jne	0x6f72 <.L528>
    6f70:	0070      	jmp	0x7052 <.L288>

00006f72 <.L528>:
		else
		{
		}
		break;
	default:
		valve.comm.actualMode = C_MODE_B;
    6f72:	6001      	lod	AL, #1
    6f74:	0074      	jmp	0x705e <.L541>

00006f76 <.L273>:
		{
			valve.diag.gmr.count += 1;
		}
		else
		{
			if (valve.diag.gmr.count > 0)
    6f76:	2c00      	cmp	X, #0
    6f78:	1902      	je	0x6f7e <.L275>

00006f7a <.LM487>:
			{
				valve.diag.gmr.count -= 1;
    6f7a:	20ff      	add	X, #-1
    6f7c:	07af      	jmp	0x6edc <.L539>

00006f7e <.L275>:
			break;
		case SENSOR_POS_ERROR : 
			valve.pos.retryCnt = CLEAR;	// Clear Valve Position Sensor retry count (Angle deviation/Out of tolerance)
			break;
		case SENSOR_OUT_ERROR : 
			valve.diag.gmr.retryCnt = CLEAR;	// Clear GMR Sensor Out-of-range retry count (No valid signal/Value not received)
    6f7e:	5ed8 1278 	mov	0x1278 <.LLST29+0x6>, X
    6f82:	07ae      	jmp	0x6ee0 <.L274>

00006f84 <.L272>:
			valve.diag.gmr.state = GMR_SENSOR_FAULT;
		}
	}
	else
	{
		valve.diag.gmr.count = CLEAR;
    6f84:	7000      	lod	A, #0
    6f86:	52d8 127c 	mov	0x127c <.LASF1443>, A
    6f8a:	07b6      	jmp	0x6ef8 <.L276>

00006f8c <.L278>:
	uint16_t voltage = get_conv_vdda_voltage();

	switch(valve.diag.McuFault)
	{
		case MCU_NORMAL :
		HV_filterCnt = 0;
    6f8c:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5530>, Y
    6f90:	72d8 10ae 	lod	A, 0x10ae <___LV_filterCnt_5529>

00006f94 <.LM491>:
		
		if (voltage <= MCU_FAULT_VS) /*scale: 10mV*/
    6f94:	2eda 012c 	cmp	X, #300
    6f98:	1e0b      	jug	0x6fb0 <.L280>

00006f9a <.LM492>:
		{
			LV_filterCnt += 1;
    6f9a:	a001      	add	A, #1
    6f9c:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5529>, A

00006fa0 <.LM493>:
			if (LV_filterCnt >= MCU_FAULT_COUNT)
    6fa0:	aeda 00c7 	cmp	A, #199
    6fa4:	1e01      	jug	0x6fa8 <.LM494>
    6fa6:	07b7      	jmp	0x6f16 <.L277>

00006fa8 <.LM494>:
			{
				valve.diag.McuFault = MCU_FAULT;
    6fa8:	6001      	lod	AL, #1

00006faa <.L540>:
		{
			HV_filterCnt += 1;
			if (HV_filterCnt >= MCU_FAULT_COUNT)
			{
				clear_fail_safe_retry_cnt(MCU_ERROR);
				valve.diag.McuFault = MCU_NORMAL;
    6faa:	42d8 1281 	mov	0x1281 <.LASF1443+0x5>, AL
    6fae:	07b3      	jmp	0x6f16 <.L277>

00006fb0 <.L280>:
				valve.diag.McuFault = MCU_FAULT;
			}
		}
		else
		{
			if (LV_filterCnt > 0)
    6fb0:	ac00      	cmp	A, #0
    6fb2:	1d01      	jne	0x6fb6 <.LM497>
    6fb4:	07b0      	jmp	0x6f16 <.L277>

00006fb6 <.LM497>:
				LV_filterCnt -= 1;
    6fb6:	a0ff      	add	A, #-1
    6fb8:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5529>, A
    6fbc:	07ac      	jmp	0x6f16 <.L277>

00006fbe <.L279>:
		}
		break;

		case MCU_FAULT :
		LV_filterCnt = 0;
    6fbe:	7000      	lod	A, #0
    6fc0:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5529>, A
    6fc4:	7ad8 10b0 	lod	Y, 0x10b0 <___HV_filterCnt_5530>

00006fc8 <.LM499>:
		
		if (voltage >= MCU_FAULT_RETURN_VS) /*scale: 10mV*/
    6fc8:	0ea7      	lod	C, ML.7
    6fca:	2eda 013f 	cmp	X, #319
    6fce:	1a0a      	jule	0x6fe4 <.L283>

00006fd0 <.LM500>:
		{
			HV_filterCnt += 1;
    6fd0:	e001      	add	Y, #1
    6fd2:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5530>, Y

00006fd6 <.LM501>:
			if (HV_filterCnt >= MCU_FAULT_COUNT)
    6fd6:	eeda 00c7 	cmp	Y, #199
    6fda:	1e01      	jug	0x6fde <.LBB425>
    6fdc:	079c      	jmp	0x6f16 <.L277>

00006fde <.LBB425>:
			break;
		case SENSOR_OUT_ERROR : 
			valve.diag.gmr.retryCnt = CLEAR;	// Clear GMR Sensor Out-of-range retry count (No valid signal/Value not received)
			break;
		case MCU_ERROR : 
			valve.diag.mcuRetryCnt = CLEAR;	// Clear Microcontroller internal error retry count
    6fde:	52d8 1282 	mov	0x1282 <.LASF1443+0x6>, A
    6fe2:	07e3      	jmp	0x6faa <.L540>

00006fe4 <.L283>:
				valve.diag.McuFault = MCU_NORMAL;
			}
		}
		else
		{
			if (HV_filterCnt > 0)
    6fe4:	ec00      	cmp	Y, #0
    6fe6:	1d01      	jne	0x6fea <.LM504>
    6fe8:	0796      	jmp	0x6f16 <.L277>

00006fea <.LM504>:
				HV_filterCnt -= 1;
    6fea:	e0ff      	add	Y, #-1
    6fec:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5530>, Y
    6ff0:	0792      	jmp	0x6f16 <.L277>

00006ff2 <.L284>:
		valve.initStatus = 1;
		valve.elapsedTime = 0;
		valve.lastState = valve.state;
		valve.state = VALVE_FAULT;
	}
	else if ((valve.state != VALVE_FAULT) && (valve.state != VALVE_PROTECTION) && (protect_mode != 0))
    6ff2:	7aee      	lod	Y, X
    6ff4:	e0fa      	add	Y, #-6
    6ff6:	ec01      	cmp	Y, #1
    6ff8:	1e01      	jug	0x6ffc <.LM506>
    6ffa:	07ad      	jmp	0x6f56 <.L285>

00006ffc <.LM506>:
    6ffc:	720b      	lod	A, [S-12]
    6ffe:	1d01      	jne	0x7002 <.LM507>
    7000:	07aa      	jmp	0x6f56 <.L285>

00007002 <.LM507>:
	{
		valve.initStatus = 1;
    7002:	6001      	lod	AL, #1
    7004:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

00007008 <.LM508>:
		valve.elapsedTime = 0;
    7008:	7000      	lod	A, #0
    700a:	0ea7      	lod	C, ML.7
    700c:	52d8 121c 	mov	0x121c <.LASF1421+0x3>, A

00007010 <.LM509>:
		valve.lastState = valve.state;
    7010:	5ed8 1218 	mov	0x1218 <_valve+0x2>, X

00007014 <.LM510>:
		valve.state = VALVE_PROTECTION;
    7014:	7007      	lod	A, #7
    7016:	0ea7      	lod	C, ML.7
    7018:	52d8 1216 	mov	0x1216 <_valve>, A
    701c:	079c      	jmp	0x6f56 <.L285>

0000701e <.L287>:
// #define CAL_POS_ANGLE_THD	(50* C_GMR_ANGLE_SCALE_FACTOR)
#define CAL_POS_ANGLE_THD (1 * C_GMR_ANGLE_SCALE_FACTOR)
	switch (valve.comm.actualMode)
	{
	case C_MODE_A:
		if (currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)CAL_POS_ANGLE_THD))
    701e:	72d8 122a 	lod	A, 0x122a <.LASF1421+0x11>
    7022:	a00a      	add	A, #10
    7024:	2ee2      	cmp	X, A
    7026:	1f01      	jsg	0x702a <.L289>
    7028:	07a4      	jmp	0x6f72 <.L528>

0000702a <.L289>:
	{
	}

	valve.pos.currentAngle = MotGetCurrentPosition();
	calc_PosToLinData(valve.pos.currentAngle);
	if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    702a:	7ad8 1222 	lod	Y, 0x1222 <.LASF1421+0x9>
    702e:	5a01      	mov	[S-2], Y
    7030:	72e6      	lod	A, Y
    7032:	a0fe      	add	A, #-2
    7034:	ac02      	cmp	A, #2
    7036:	1e16      	jug	0x7064 <.L290>

00007038 <.LM513>:
	{
		valve.comm.moving = 1;
    7038:	6001      	lod	AL, #1

0000703a <.L542>:
	}
	else
	{
		valve.comm.moving = 0;
    703a:	42d8 1244 	mov	0x1244 <.LLST27+0x5>, AL

0000703e <.LM515>:
	}
	
	switch (valve.state)
    703e:	72d8 1216 	lod	A, 0x1216 <_valve>
    7042:	ac0a      	cmp	A, #10
    7044:	1a01      	jule	0x7048 <.LASF218+0x8>
    7046:	0034      	jmp	0x70b0 <.L549>
    7048:	4422      	asl	A
    704a:	a2da 5cdc 	add	A, #23772
    704e:	7ae2      	lod	Y, A
    7050:	76f0      	jmp	[Y]

00007052 <.L288>:
		else
		{
		}
		break;
	case C_MODE_B:
		if (currentAngle >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)CAL_POS_ANGLE_THD))
    7052:	72d8 1228 	lod	A, 0x1228 <.LASF1421+0xf>
    7056:	a0f6      	add	A, #-10
    7058:	2ee2      	cmp	X, A
    705a:	1ae7      	jsl	0x702a <.L289>

0000705c <.LM517>:
		{
			valve.comm.actualMode = C_MODE_A;
    705c:	6000      	lod	AL, #0

0000705e <.L541>:
		else
		{
		}
		break;
	default:
		valve.comm.actualMode = C_MODE_B;
    705e:	42d8 1243 	mov	0x1243 <.LLST27+0x4>, AL
    7062:	07e3      	jmp	0x702a <.L289>

00007064 <.L290>:
	{
		valve.comm.moving = 1;
	}
	else
	{
		valve.comm.moving = 0;
    7064:	6000      	lod	AL, #0
    7066:	07e9      	jmp	0x703a <.L542>

00007068 <.L293>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    7068:	5ed8 1224 	mov	0x1224 <.LASF1421+0xb>, X

0000706c <.LBE438>:
{
	tValveState nextState = VALVE_INIT;
	int16_t diff = 0;

	ValveTargetAngleUpdate(valve.pos.currentAngle);
	MotSetTargetPosition(valve.pos.targetAngle);
    706c:	72ee      	lod	A, X
    706e:	82db 3f24 	callf	0x7e48 <_MotSetTargetPosition>

00007072 <.LM522>:
	if ((valve.diag.ign.state == IGN_NORMAL) && (valve.elapsedTime >= 5u))
    7072:	7ed8 1270 	lod	X, 0x1270 <.LLST28+0x11>
    7076:	1901      	je	0x707a <.LASF15>
    7078:	0348      	jmp	0x770a <.L397>
    707a:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    707e:	ac04      	cmp	A, #4
    7080:	1e01      	jug	0x7084 <.LM523>
    7082:	0050      	jmp	0x7124 <.L305>

00007084 <.LM523>:
	{
		if (u16EventState == VALVE_CAL_FAULT)
    7084:	72d8 10b6 	lod	A, 0x10b6 <_u16EventState>
    7088:	ac09      	cmp	A, #9
    708a:	1d03      	jne	0x7092 <.L306>

0000708c <.LM524>:
		{
			valve.calibration.req2Cal = 1;
    708c:	6001      	lod	AL, #1
    708e:	42d8 1230 	mov	0x1230 <.Lframe0>, AL

00007092 <.L306>:
		}
		if (valve.memory.lastAngle != 0)
    7092:	7ed8 1250 	lod	X, 0x1250 <.LASF1692+0x5>
    7096:	72d8 1226 	lod	A, 0x1226 <.LASF1421+0xd>
    709a:	2c00      	cmp	X, #0
    709c:	190b      	je	0x70b4 <.L307>

0000709e <.L558>:
		{
			diff = valve.pos.currentAngle - valve.memory.lastAngle;
    709e:	aaee      	sub	A, X

000070a0 <.L543>:
			if (diff < 0)
			{
				diff = -diff;
			}
			if (diff > (int16_t)C_VALVE_ACCURACY_ANGLE)
    70a0:	ac00      	cmp	A, #0
    70a2:	1d81      	jnn	0x70a6 <.L563>
    70a4:	5cc2      	neg	A

000070a6 <.L563>:
    70a6:	ac14      	cmp	A, #20
    70a8:	1b03      	jsle	0x70b0 <.L549>

000070aa <.LM528>:
			{

				valve.calibration.req2Cal = 1;
    70aa:	6001      	lod	AL, #1

000070ac <.LVL197>:
    70ac:	42d8 1230 	mov	0x1230 <.Lframe0>, AL

000070b0 <.L549>:
		break;
	case CALSTEP_COMPLETED:

		valve.calibration.req2Cal = 0;
		valve.calibration.req1Cal = 0;
		nextState = VALVE_STANDBY;
    70b0:	7c01      	lod	X, #1
    70b2:	0038      	jmp	0x7124 <.L305>

000070b4 <.L307>:
			}
		}
		else
		{

			if (valve.pos.currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)(45 * C_GMR_ANGLE_SCALE_FACTOR)))
    70b4:	7ed8 122a 	lod	X, 0x122a <.LASF1421+0x11>
    70b8:	7aee      	lod	Y, X
    70ba:	e2da 01c2 	add	Y, #450
    70be:	eee2      	cmp	Y, A
    70c0:	1eee      	jsge	0x709e <.L558>

000070c2 <.LM531>:
			{
				diff = valve.pos.currentAngle - valve.pos.modeAngle[C_MODE_B];
			}
			else
			{
				diff = valve.pos.currentAngle - valve.pos.modeAngle[C_MODE_A];
    70c2:	aad8 1228 	sub	A, 0x1228 <.LASF1421+0xf>
    70c6:	07ec      	jmp	0x70a0 <.L543>

000070c8 <.L295>:
{

	tValveState nextState = VALVE_STANDBY;
	int16_t diffPos;

	if (valve.initStatus != 0)
    70c8:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    70cc:	1903      	je	0x70d4 <.L312>

000070ce <.LM533>:
	{
		valve.initStatus = 0;
    70ce:	6000      	lod	AL, #0
    70d0:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000070d4 <.L312>:
	}

	MotRequestHardStop();
    70d4:	82db 3f1c 	callf	0x7e38 <_MotRequestHardStop>

000070d8 <.LM535>:

	if ((valve.calibration.req2Cal == 1) || (valve.calibration.req1Cal == 1))
    70d8:	62d8 1230 	lod	AL, 0x1230 <.Lframe0>
    70dc:	8c01      	cmp	AL, #1
    70de:	1d01      	jne	0x70e2 <.LASF1057+0x9>
    70e0:	010c      	jmp	0x72fa <.L400>
    70e2:	62d8 1231 	lod	AL, 0x1231 <.Lframe0+0x1>
    70e6:	8c01      	cmp	AL, #1
    70e8:	1d01      	jne	0x70ec <.LM536>
    70ea:	0107      	jmp	0x72fa <.L400>

000070ec <.LM536>:
	{

		nextState = VALVE_CALIBRATION;
	}
	else if (valve.comm.ForcedDiag != 0)
    70ec:	62d8 1241 	lod	AL, 0x1241 <.LLST27+0x2>
    70f0:	1902      	je	0x70f6 <.L313>

000070f2 <.L551>:
}

static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;
    70f2:	7c04      	lod	X, #4
    70f4:	0017      	jmp	0x7124 <.L305>

000070f6 <.L313>:
	else if (valve.comm.ForcedDiag != 0)
	{

		nextState = VALVE_DIAGRUN;
	}
	else if (valve.comm.Enable != 0)
    70f6:	62d8 123f 	lod	AL, 0x123f <.LLST27>
    70fa:	195a      	je	0x70b0 <.L549>

000070fc <.LM539>:
	{

		if (valve.pos.targetAngle > valve.pos.currentAngle)
    70fc:	7ed8 1224 	lod	X, 0x1224 <.LASF1421+0xb>
    7100:	72d8 1226 	lod	A, 0x1226 <.LASF1421+0xd>
    7104:	2ee2      	cmp	X, A
    7106:	1f01      	jsg	0x710a <.LM540>
    7108:	0043      	jmp	0x7190 <.L314>

0000710a <.LM540>:
		{
			diffPos = valve.pos.targetAngle - valve.pos.currentAngle;
    710a:	2ae2      	sub	X, A

0000710c <.L315>:
		{

			nextState = VALVE_READY;
		}
#else
		if ((valve.comm.lastMode != valve.comm.targetMode) && (diffPos >= (int16_t)C_VALVE_ACCURACY_ANGLE))
    710c:	66d8 123e 	lod	YL, 0x123e <.Lframe0+0xe>
    7110:	62d8 1242 	lod	AL, 0x1242 <.LLST27+0x3>
    7114:	8ee8      	cmp	AL, YL
    7116:	1d01      	jne	0x711a <.LM542>
    7118:	003e      	jmp	0x7196 <.L401>

0000711a <.LM542>:
		{

			nextState = VALVE_READY;
    711a:	2c13      	cmp	X, #19
    711c:	5cbe      	ssg	X

0000711e <.LVL206>:
    711e:	2001      	add	X, #1

00007120 <.L316>:
		}
#endif
		valve.comm.lastMode = valve.comm.targetMode;
    7120:	46d8 1242 	mov	0x1242 <.LLST27+0x3>, YL

00007124 <.L305>:
		nextState = VALVE_STANDBY;
		break;
	}

	/* state changed */
	if (valve.state != nextState)
    7124:	7ad8 1216 	lod	Y, 0x1216 <_valve>
    7128:	eeee      	cmp	Y, X
    712a:	1d01      	jne	0x712e <.LM545>
    712c:	01aa      	jmp	0x7482 <.L389>

0000712e <.LM545>:
	{
		valve.initStatus = 1;
    712e:	6001      	lod	AL, #1
    7130:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

00007134 <.LM546>:
		valve.elapsedTime = 0;
    7134:	7000      	lod	A, #0
    7136:	0ea7      	lod	C, ML.7
    7138:	52d8 121c 	mov	0x121c <.LASF1421+0x3>, A

0000713c <.LM547>:
		if (valve.state != VALVE_LOWPOWER)
    713c:	ec09      	cmp	Y, #9
    713e:	1902      	je	0x7144 <.L390>

00007140 <.LM548>:
		{
			valve.lastState = valve.state;
    7140:	5ad8 1218 	mov	0x1218 <_valve+0x2>, Y

00007144 <.L390>:
		}
		valve.state = nextState;
    7144:	5ed8 1216 	mov	0x1216 <_valve>, X

00007148 <.L391>:
	{
		if (valve.elapsedTime < 0xffffu)
			valve.elapsedTime += 1;
	}

	if (valve.linLiveTimeOut > 0)
    7148:	72d8 121a 	lod	A, 0x121a <.LASF1421+0x1>
    714c:	1d01      	jne	0x7150 <.LM551>
    714e:	02e3      	jmp	0x7716 <.L392>

00007150 <.LM551>:
	{
		valve.linLiveTimeOut -= 1;
    7150:	a0ff      	add	A, #-1
    7152:	52d8 121a 	mov	0x121a <.LASF1421+0x1>, A

00007156 <.LM552>:
		valve.diag.comm.state = COMMUNICATION_NORNAL;
    7156:	7000      	lod	A, #0
    7158:	52d8 1262 	mov	0x1262 <.LLST28+0x3>, A

0000715c <.LBB474>:
			break;
		case MCU_ERROR : 
			valve.diag.mcuRetryCnt = CLEAR;	// Clear Microcontroller internal error retry count
			break;
		case VALVE_LIN_COMM_FAULT : 
			valve.diag.comm.linErrRetryCnt = CLEAR;	// Clear LIN Communication Error retry count
    715c:	0ea7      	lod	C, ML.7
    715e:	52d8 1264 	mov	0x1264 <.LLST28+0x5>, A

00007162 <.L393>:
	else
	{
		valve.diag.comm.state = COMMUNICATION_ERROR;
	}

	if (Fwv_Request_Event != 0)
    7162:	62d8 10ab 	lod	AL, 0x10ab <_Fwv_Request_Event>
    7166:	1908      	je	0x7178 <.L394>

00007168 <.LM555>:
	{
		Fwv_Request_Event = 0;
    7168:	6000      	lod	AL, #0
    716a:	42d8 10ab 	mov	0x10ab <_Fwv_Request_Event>, AL

0000716e <.LM556>:
		//		ValveLinGetCommand();
		valve.linLiveTimeOut = LIN_TIMEOUT_COUNT;
    716e:	72da 0fa0 	lod	A, #4000
    7172:	0ea7      	lod	C, ML.7
    7174:	52d8 121a 	mov	0x121a <.LASF1421+0x1>, A

00007178 <.L394>:
	}
	if (Fwv_Response_Event != 0)
    7178:	62d8 10aa 	lod	AL, 0x10aa <__data_end>
    717c:	1908      	je	0x718e <.L220>

0000717e <.LM558>:
	{
		Fwv_Response_Event = 0;
    717e:	6000      	lod	AL, #0
    7180:	42d8 10aa 	mov	0x10aa <__data_end>, AL

00007184 <.LM559>:
		//		ValveLinUpdateSignals();
		valve.linLiveTimeOut = LIN_TIMEOUT_COUNT;
    7184:	72da 0fa0 	lod	A, #4000
    7188:	0ea7      	lod	C, ML.7
    718a:	52d8 121a 	mov	0x121a <.LASF1421+0x1>, A

0000718e <.L220>:
	}
}
    718e:	540d      	ret	#14

00007190 <.L314>:
		{
			diffPos = valve.pos.targetAngle - valve.pos.currentAngle;
		}
		else
		{
			diffPos = valve.pos.currentAngle - valve.pos.targetAngle;
    7190:	aaee      	sub	A, X
    7192:	7ee2      	lod	X, A

00007194 <.LVL213>:
    7194:	07bb      	jmp	0x710c <.L315>

00007196 <.L401>:
}

static tValveState ValveStandbyTask(void)
{

	tValveState nextState = VALVE_STANDBY;
    7196:	7c01      	lod	X, #1

00007198 <.LVL215>:
    7198:	07c3      	jmp	0x7120 <.L316>

0000719a <.L296>:
static tValveState ValveReadyTask(void)
{

	tValveState nextState = VALVE_READY;

	if (valve.initStatus != 0)
    719a:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    719e:	1905      	je	0x71aa <.L317>

000071a0 <.LM564>:
	{
		valve.initStatus = 0;
    71a0:	6000      	lod	AL, #0
    71a2:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000071a6 <.LM565>:
		MotClearHardStop();
    71a6:	82db 3f20 	callf	0x7e40 <_MotClearHardStop>

000071aa <.L317>:
	}

	MotSetTargetPosition(valve.pos.targetAngle);
    71aa:	72d8 1224 	lod	A, 0x1224 <.LASF1421+0xb>
    71ae:	82db 3f24 	callf	0x7e48 <_MotSetTargetPosition>

000071b2 <.L403>:
}

static tValveState ValveOperationTask(void)
{

	tValveState nextState = VALVE_OPERATION;
    71b2:	7c03      	lod	X, #3
    71b4:	07b7      	jmp	0x7124 <.L305>

000071b6 <.L297>:
	int16_t actualPos;

	if (valve.initStatus != 0)
    71b6:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    71ba:	1905      	je	0x71c6 <.L318>

000071bc <.LM569>:
	{
		valve.initStatus = 0;
    71bc:	6000      	lod	AL, #0
    71be:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000071c2 <.LM570>:

		MotClearHardStop();
    71c2:	82db 3f20 	callf	0x7e40 <_MotClearHardStop>

000071c6 <.L318>:
	}

	if (valve.elapsedTime >= valve.comm.timeOut)
    71c6:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    71ca:	aed8 123c 	cmp	A, 0x123c <.Lframe0+0xc>
    71ce:	1804      	jc	0x71d8 <.L319>

000071d0 <.LM572>:
	{

		valve.pos.fault = POS_FAULT;
    71d0:	6001      	lod	AL, #1
    71d2:	42d8 122c 	mov	0x122c <.LLST5>, AL
    71d6:	07ed      	jmp	0x71b2 <.L403>

000071d8 <.L319>:
		else
		{
			nextState = VALVE_STANDBY;
		}
#else
		if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    71d8:	72d8 1222 	lod	A, 0x1222 <.LASF1421+0x9>
    71dc:	a0fe      	add	A, #-2
    71de:	ac02      	cmp	A, #2
    71e0:	1a68      	jule	0x71b2 <.L403>

000071e2 <.LM574>:
		{
		}
		else
		{

			actualPos = valve.pos.currentAngle;
    71e2:	7ed8 1226 	lod	X, 0x1226 <.LASF1421+0xd>

000071e6 <.LM575>:
				
				}
			}
			else {}
#else
			if ((actualPos >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)C_VALVE_ACCURACY_ANGLE)) && (actualPos <= (valve.pos.modeAngle[C_MODE_A] + (int16_t)C_VALVE_ACCURACY_ANGLE)))
    71e6:	72d8 1228 	lod	A, 0x1228 <.LASF1421+0xf>
    71ea:	7ae2      	lod	Y, A
    71ec:	e0ec      	add	Y, #-20
    71ee:	2ee6      	cmp	X, Y
    71f0:	1a83      	jsl	0x71f8 <.L320>
    71f2:	a014      	add	A, #20
    71f4:	2ee2      	cmp	X, A
    71f6:	1b0c      	jsle	0x7210 <.L321>

000071f8 <.L320>:
			{
			}
			else if ((actualPos >= (valve.pos.modeAngle[C_MODE_B] - (int16_t)C_VALVE_ACCURACY_ANGLE)) && (actualPos <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)C_VALVE_ACCURACY_ANGLE)))
    71f8:	72d8 122a 	lod	A, 0x122a <.LASF1421+0x11>
    71fc:	7ae2      	lod	Y, A
    71fe:	e0ec      	add	Y, #-20
    7200:	2ee6      	cmp	X, Y
    7202:	1a83      	jsl	0x720a <.L322>
    7204:	a014      	add	A, #20
    7206:	2ee2      	cmp	X, A
    7208:	1b03      	jsle	0x7210 <.L321>

0000720a <.L322>:
			{
			}
			else
			{
				valve.pos.fault = POS_FAULT;
    720a:	6001      	lod	AL, #1
    720c:	42d8 122c 	mov	0x122c <.LLST5>, AL

00007210 <.L321>:
			}
#endif
			if (valve.pos.fault != 0)
    7210:	62d8 122c 	lod	AL, 0x122c <.LLST5>
    7214:	1901      	je	0x7218 <.LBB481>
    7216:	027b      	jmp	0x770e <.L404>

00007218 <.LBB481>:
			break;
		case MOT_ABSTALL_ERROR : 
			valve.diag.ObstructionRetryCnt = CLEAR;	// Clear Motor  Obstruction stall retry count
			break;
		case SENSOR_POS_ERROR : 
			valve.pos.retryCnt = CLEAR;	// Clear Valve Position Sensor retry count (Angle deviation/Out of tolerance)
    7218:	42d8 122d 	mov	0x122d <.LLST5+0x1>, AL
    721c:	0749      	jmp	0x70b0 <.L549>

0000721e <.L298>:
static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;

	if (valve.initStatus != 0)
    721e:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    7222:	1909      	je	0x7236 <.L323>

00007224 <.LM581>:
	{
		valve.initStatus = 0;
    7224:	6000      	lod	AL, #0
    7226:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

0000722a <.LM582>:
		valve.test.step = 0;
    722a:	7000      	lod	A, #0
    722c:	0ea7      	lod	C, ML.7
    722e:	52d8 1246 	mov	0x1246 <.LLST27+0x7>, A

00007232 <.LM583>:
		MotClearHardStop();
    7232:	82db 3f20 	callf	0x7e40 <_MotClearHardStop>

00007236 <.L323>:
	}
	valve.comm.lastMode = 0xff;
    7236:	60ff      	lod	AL, #-1
    7238:	42d8 1242 	mov	0x1242 <.LLST27+0x3>, AL

0000723c <.LM585>:
	if (valve.comm.ForcedDiag == 0)
    723c:	62d8 1241 	lod	AL, 0x1241 <.LLST27+0x2>
    7240:	1d05      	jne	0x724c <.L324>

00007242 <.LM586>:
	{
		if (valve.comm.moving == 0)
    7242:	62d8 1244 	lod	AL, 0x1244 <.LLST27+0x5>
    7246:	1d01      	jne	0x724a <.LASF72+0x6>
    7248:	0733      	jmp	0x70b0 <.L549>
    724a:	0753      	jmp	0x70f2 <.L551>

0000724c <.L324>:
		}
	}
	else
	{
		/* B->A->B*/
		if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    724c:	72d8 1222 	lod	A, 0x1222 <.LASF1421+0x9>
    7250:	a0fe      	add	A, #-2
    7252:	ac02      	cmp	A, #2
    7254:	1e04      	jug	0x725e <.L326>

00007256 <.LM588>:
		{
			valve.elapsedTime = 0;
    7256:	7000      	lod	A, #0
    7258:	52d8 121c 	mov	0x121c <.LASF1421+0x3>, A
    725c:	074a      	jmp	0x70f2 <.L551>

0000725e <.L326>:
		}
		else
		{

			if (valve.elapsedTime >= 2000u)
    725e:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    7262:	aeda 07cf 	cmp	A, #1999
    7266:	1e01      	jug	0x726a <.LM590>
    7268:	0744      	jmp	0x70f2 <.L551>

0000726a <.LM590>:
			{
				if (valve.test.step == 0)
    726a:	72d8 1246 	lod	A, 0x1246 <.LLST27+0x7>
    726e:	1d06      	jne	0x727c <.L327>

00007270 <.LM591>:
				{
					valve.test.step = 1;
    7270:	7001      	lod	A, #1

00007272 <.L550>:
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 2) /*20250714*/
				{
					valve.test.step = 3;
    7272:	52d8 1246 	mov	0x1246 <.LLST27+0x7>, A

00007276 <.LM593>:
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
    7276:	72d8 122a 	lod	A, 0x122a <.LASF1421+0x11>
    727a:	0007      	jmp	0x728a <.L552>

0000727c <.L327>:
				{
					valve.test.step = 1;
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 1)
    727c:	ac01      	cmp	A, #1
    727e:	1d0a      	jne	0x7294 <.L328>

00007280 <.LM595>:
				{
#if 0
					valve.test.step=0;
#else
					valve.test.step = 2;
    7280:	7002      	lod	A, #2
    7282:	52d8 1246 	mov	0x1246 <.LLST27+0x7>, A

00007286 <.LM596>:
#endif
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
    7286:	72d8 1228 	lod	A, 0x1228 <.LASF1421+0xf>

0000728a <.L552>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    728a:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A

0000728e <.LBE470>:
				}
				else if (valve.test.step == 2) /*20250714*/
				{
					valve.test.step = 3;
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
					MotSetTargetPosition(valve.pos.targetAngle);
    728e:	82db 3f24 	callf	0x7e48 <_MotSetTargetPosition>
    7292:	072f      	jmp	0x70f2 <.L551>

00007294 <.L328>:
					valve.test.step = 2;
#endif
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 2) /*20250714*/
    7294:	ac02      	cmp	A, #2
    7296:	1901      	je	0x729a <.LM600>
    7298:	072c      	jmp	0x70f2 <.L551>

0000729a <.LM600>:
				{
					valve.test.step = 3;
    729a:	7003      	lod	A, #3
    729c:	07ea      	jmp	0x7272 <.L550>

0000729e <.L299>:
{
	tValveState nextState = VALVE_CALIBRATION;
	int16_t diff;
	uint16_t timeOut;

	if (valve.calibration.req2Cal)
    729e:	62d8 1230 	lod	AL, 0x1230 <.Lframe0>
    72a2:	66e0      	lod	YL, AL
    72a4:	5cf6      	usex	Y
    72a6:	5a0b      	mov	[S-12], Y

000072a8 <.LVL230>:
    72a8:	8c00      	cmp	AL, #0
    72aa:	191c      	je	0x72e4 <.L405>

000072ac <.LM602>:
	{
		timeOut = 20000;
    72ac:	7ada 4e20 	lod	Y, #20000

000072b0 <.L544>:
	}
	else
	{
		timeOut = 6000;
    72b0:	5a09      	mov	[S-10], Y

000072b2 <.LM604>:
	}
	// uint16_t state,value;
	if (valve.initStatus != 0)
    72b2:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    72b6:	1908      	je	0x72c8 <.L330>

000072b8 <.LM605>:
	{
		valve.initStatus = 0;
    72b8:	6000      	lod	AL, #0
    72ba:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000072be <.LM606>:
		valve.calibration.state = CALSTEP_RESET;
    72be:	42d8 122e 	mov	0x122e <.LLST5+0x2>, AL

000072c2 <.LM607>:
		valve.diag.calFault = 0;
    72c2:	0ea7      	lod	C, ML.7
    72c4:	42d8 1285 	mov	0x1285 <.LASF1443+0x9>, AL

000072c8 <.L330>:
	}
	valve.comm.lastMode = 0xff;
    72c8:	60ff      	lod	AL, #-1
    72ca:	42d8 1242 	mov	0x1242 <.LLST27+0x3>, AL

000072ce <.LM609>:
	switch (valve.calibration.state)
    72ce:	62d8 122e 	lod	AL, 0x122e <.LLST5+0x2>
    72d2:	5cf2      	usex	A
    72d4:	ac09      	cmp	A, #9
    72d6:	1a01      	jule	0x72da <.LASF1020+0x5>
    72d8:	06eb      	jmp	0x70b0 <.L549>
    72da:	4422      	asl	A
    72dc:	a2da 5cf2 	add	A, #23794
    72e0:	7ae2      	lod	Y, A

000072e2 <.LVL232>:
    72e2:	76f0      	jmp	[Y]

000072e4 <.L405>:
	{
		timeOut = 20000;
	}
	else
	{
		timeOut = 6000;
    72e4:	7ada 1770 	lod	Y, #6000
    72e8:	07e3      	jmp	0x72b0 <.L544>

000072ea <.L331>:
	}
	valve.comm.lastMode = 0xff;
	switch (valve.calibration.state)
	{
	case CALSTEP_RESET:
		MotClearStallFlag(2); /* clear stall flag if set */
    72ea:	7002      	lod	A, #2
    72ec:	82db 3f3e 	callf	0x7e7c <_MotClearStallFlag>

000072f0 <.LM612>:
		MotRequestHardStop();
    72f0:	82db 3f1c 	callf	0x7e38 <_MotRequestHardStop>

000072f4 <.LM613>:
		valve.calibration.state = CALSTEP_START;
    72f4:	6001      	lod	AL, #1

000072f6 <.L559>:
		valve.calibration.timer = 0;
		if (valve.calibration.req2Cal != 0)
		{
			ValveTargetAngleUpdate(-10 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 0% position */
			MotSetTargetPosition(valve.pos.targetAngle);
			valve.calibration.state = CALSTEP_0d_POS;
    72f6:	42d8 122e 	mov	0x122e <.LLST5+0x2>, AL

000072fa <.L400>:
	MotRequestHardStop();

	if ((valve.calibration.req2Cal == 1) || (valve.calibration.req1Cal == 1))
	{

		nextState = VALVE_CALIBRATION;
    72fa:	7c05      	lod	X, #5
    72fc:	0713      	jmp	0x7124 <.L305>

000072fe <.L333>:
		MotClearStallFlag(2); /* clear stall flag if set */
		MotRequestHardStop();
		valve.calibration.state = CALSTEP_START;
		break;
	case CALSTEP_START:
		MotClearHardStop();
    72fe:	82db 3f20 	callf	0x7e40 <_MotClearHardStop>

00007302 <.LM617>:
		valve.calibration.delay = 3;
    7302:	7803      	lod	Y, #3
    7304:	5ad8 1238 	mov	0x1238 <.Lframe0+0x8>, Y

00007308 <.LM618>:
		valve.calibration.timer = 0;
    7308:	7000      	lod	A, #0
    730a:	0ea7      	lod	C, ML.7
    730c:	52d8 123a 	mov	0x123a <.Lframe0+0xa>, A

00007310 <.LM619>:
		if (valve.calibration.req2Cal != 0)
    7310:	62d8 1230 	lod	AL, 0x1230 <.Lframe0>
    7314:	1908      	je	0x7326 <.L340>

00007316 <.L341>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    7316:	709c      	lod	A, #-100
    7318:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A

0000731c <.LBE444>:
		valve.calibration.delay = 3;
		valve.calibration.timer = 0;
		if (valve.calibration.req2Cal != 0)
		{
			ValveTargetAngleUpdate(-10 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 0% position */
			MotSetTargetPosition(valve.pos.targetAngle);
    731c:	82db 3f24 	callf	0x7e48 <_MotSetTargetPosition>

00007320 <.LM622>:
			valve.calibration.state = CALSTEP_0d_POS;
    7320:	6002      	lod	AL, #2
    7322:	0ea7      	lod	C, ML.7
    7324:	07e8      	jmp	0x72f6 <.L559>

00007326 <.L340>:
		}
		else
		{
			if (valve.pos.currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)(45 * C_GMR_ANGLE_SCALE_FACTOR)))
    7326:	72d8 122a 	lod	A, 0x122a <.LASF1421+0x11>
    732a:	a2da 01c2 	add	A, #450
    732e:	aed8 1226 	cmp	A, 0x1226 <.LASF1421+0xd>
    7332:	1ef1      	jsge	0x7316 <.L341>

00007334 <.LBB446>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    7334:	72da 0e74 	lod	A, #3700
    7338:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A

0000733c <.LBE446>:
				valve.calibration.state = CALSTEP_0d_POS;
			}
			else
			{
				ValveTargetAngleUpdate(370 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 360% position */
				MotSetTargetPosition(valve.pos.targetAngle);
    733c:	5a03      	mov	[S-4], Y
    733e:	82db 3f24 	callf	0x7e48 <_MotSetTargetPosition>

00007342 <.LM626>:
				valve.calibration.state = CALSTEP_360d_POS;
    7342:	7a03      	lod	Y, [S-4]
    7344:	46d8 122e 	mov	0x122e <.LLST5+0x2>, YL
    7348:	07d8      	jmp	0x72fa <.L400>

0000734a <.L334>:
			}
		}
		break;
	case CALSTEP_0d_POS:
		valve.calibration.timer += 1;
    734a:	72d8 123a 	lod	A, 0x123a <.Lframe0+0xa>
    734e:	a001      	add	A, #1
    7350:	52d8 123a 	mov	0x123a <.Lframe0+0xa>, A

00007354 <.LM628>:
		if (valve.calibration.timer >= timeOut)
    7354:	ae09      	cmp	A, [S-10]
    7356:	1802      	jc	0x735c <.L342>

00007358 <.L561>:
			{

				MotClearStallFlag(2); /* clear stall flag if set */
				MotRequestHardStop();

				valve.calibration.state = CALSTEP_FAULT;
    7358:	6008      	lod	AL, #8
    735a:	07cd      	jmp	0x72f6 <.L559>

0000735c <.L342>:
		valve.calibration.timer += 1;
		if (valve.calibration.timer >= timeOut)
		{
			valve.calibration.state = CALSTEP_FAULT;
		}
		else if (valve.calibration.delay > 0)
    735c:	72d8 1238 	lod	A, 0x1238 <.Lframe0+0x8>
    7360:	1904      	je	0x736a <.L343>

00007362 <.L560>:
		}
		break;
	case CALSTEP_INIT_POS:
		if (valve.calibration.delay > 0)
		{
			valve.calibration.delay -= 1;
    7362:	a0ff      	add	A, #-1
    7364:	52d8 1238 	mov	0x1238 <.Lframe0+0x8>, A
    7368:	07c8      	jmp	0x72fa <.L400>

0000736a <.L343>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			if (valve.motorMotion == MOTION_STALL)
    736a:	7a01      	lod	Y, [S-2]
    736c:	ec06      	cmp	Y, #6
    736e:	1901      	je	0x7372 <.LM633>
    7370:	0084      	jmp	0x747a <.L354>

00007372 <.LM633>:
			{
				MotClearStallFlag(2); /* clear stall flag if set */
    7372:	7002      	lod	A, #2
    7374:	82db 3f3e 	callf	0x7e7c <_MotClearStallFlag>

00007378 <.LM634>:
				MotRequestHardStop();
    7378:	82db 3f1c 	callf	0x7e38 <_MotRequestHardStop>

0000737c <.LM635>:
				if (valve.calibration.offsetDone == 0)
    737c:	62d8 122f 	lod	AL, 0x122f <.LLST5+0x3>
    7380:	1d2d      	jne	0x73dc <.L346>

00007382 <.LM636>:
				{
					calcSensorOffset(valve.pos.currentAngle);
    7382:	7ad8 1226 	lod	Y, 0x1226 <.LASF1421+0xd>

00007386 <.LBB448>:

	return nextState;
}
static void calcSensorOffset(int16_t currDegree)
{
	int16_t offset = get_gmr_sensor_offset();
    7386:	5a03      	mov	[S-4], Y
    7388:	132a      	call	0x79de <_get_gmr_sensor_offset>

0000738a <.LM638>:
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
	}
#else
	offset += (int16_t)((int16_t)(C_GMR_SENSOR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR) - currDegree);
    738a:	7a03      	lod	Y, [S-4]
    738c:	aae6      	sub	A, Y

0000738e <.LVL250>:
    738e:	a2da 0708 	add	A, #1800

00007392 <.LM639>:
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    7392:	aeda 0e0f 	cmp	A, #3599
    7396:	1b2f      	jsle	0x73f6 <.L347>

00007398 <.LM640>:
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7398:	a2da f1f0 	add	A, #61936

0000739c <.L348>:
	else
	{
	}
#endif

	set_gmr_sensor_offset(offset);
    739c:	131d      	call	0x79d8 <_set_gmr_sensor_offset>

0000739e <.LBE448>:
				MotClearStallFlag(2); /* clear stall flag if set */
				MotRequestHardStop();
				if (valve.calibration.offsetDone == 0)
				{
					calcSensorOffset(valve.pos.currentAngle);
					diff = valve.memory.offset - get_gmr_sensor_offset();
    739e:	7ad8 124e 	lod	Y, 0x124e <.LASF1692+0x3>
    73a2:	5a03      	mov	[S-4], Y
    73a4:	131c      	call	0x79de <_get_gmr_sensor_offset>
    73a6:	7a03      	lod	Y, [S-4]
    73a8:	eae2      	sub	Y, A

000073aa <.LM643>:
					if (diff < 0)
					{
						diff = -diff;
					}
					if (diff > C_VALVE_CAL_HYSTERISYS)
    73aa:	1d81      	jnn	0x73ae <.L564>
    73ac:	5cc6      	neg	Y

000073ae <.L564>:
    73ae:	4cf9      	movs	YA, Y
    73b0:	82db 2ffa 	callf	0x5ff4 <___floatsisf>

000073b4 <.LVL257>:
    73b4:	54ca 0000 	pushw	#0
    73b8:	54ca 4120 	pushw	#16672

000073bc <.LCFI17>:
    73bc:	82db 2fd8 	callf	0x5fb0 <___gtsf2>
    73c0:	5c03      	dec	S, #4

000073c2 <.LCFI18>:
    73c2:	ac00      	cmp	A, #0
    73c4:	1b0b      	jsle	0x73dc <.L346>

000073c6 <.LM644>:
					{
						valve_gmr_write((uint16_t)get_gmr_sensor_offset(), (uint16_t)valve.pos.currentAngle, 0x5555);
    73c6:	7ad8 1226 	lod	Y, 0x1226 <.LASF1421+0xd>
    73ca:	5a03      	mov	[S-4], Y
    73cc:	1308      	call	0x79de <_get_gmr_sensor_offset>
    73ce:	54ca 5555 	pushw	#21845

000073d2 <.LCFI19>:
    73d2:	7a05      	lod	Y, [S-6]
    73d4:	5adf      	push	Y

000073d6 <.LCFI20>:
    73d6:	82db 44e9 	callf	0x89d2 <_valve_gmr_write>
    73da:	5c03      	dec	S, #4

000073dc <.L346>:
					}
				}
				valve.calibration.offsetDone = 1;
				valve.calibration.delay = 3;
    73dc:	7003      	lod	A, #3
    73de:	52d8 1238 	mov	0x1238 <.Lframe0+0x8>, A

000073e2 <.LM646>:
				valve.calibration.timer = 0;
    73e2:	7000      	lod	A, #0
    73e4:	0ea7      	lod	C, ML.7
    73e6:	52d8 123a 	mov	0x123a <.Lframe0+0xa>, A

000073ea <.LM647>:
				valve.calibration.state = CALSTEP_CALC;
    73ea:	72da 0105 	lod	A, #261
    73ee:	52d8 122e 	mov	0x122e <.LLST5+0x2>, A
    73f2:	0ea7      	lod	C, ML.7
    73f4:	0782      	jmp	0x72fa <.L400>

000073f6 <.L347>:
	offset += (int16_t)((int16_t)(C_GMR_SENSOR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR) - currDegree);
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
	}
	else if (offset < 0)
    73f6:	ac00      	cmp	A, #0
    73f8:	1ed1      	jsge	0x739c <.L348>

000073fa <.LM649>:
	{
		offset = (-offset);
		offset = (int16_t)C_GMR_SENSOR_ANGLE_LIMIT - offset;
    73fa:	a2da 0e10 	add	A, #3600

000073fe <.LVL268>:
    73fe:	07ce      	jmp	0x739c <.L348>

00007400 <.L335>:
			}
		}
		break;

	case CALSTEP_360d_POS:
		valve.calibration.timer += 1;
    7400:	72d8 123a 	lod	A, 0x123a <.Lframe0+0xa>
    7404:	a001      	add	A, #1
    7406:	52d8 123a 	mov	0x123a <.Lframe0+0xa>, A

0000740a <.LM651>:
		if (valve.calibration.timer >= timeOut)
    740a:	7e09      	lod	X, [S-10]
    740c:	2ee2      	cmp	X, A
    740e:	1e01      	jug	0x7412 <.LM652>
    7410:	07a3      	jmp	0x7358 <.L561>

00007412 <.LM652>:
		{

			valve.calibration.state = CALSTEP_FAULT;
		}
		else if (valve.calibration.delay > 0)
    7412:	72d8 1238 	lod	A, 0x1238 <.Lframe0+0x8>
    7416:	1901      	je	0x741a <.LM653>
    7418:	07a4      	jmp	0x7362 <.L560>

0000741a <.LM653>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			if (valve.motorMotion == MOTION_STALL)
    741a:	7a01      	lod	Y, [S-2]
    741c:	ec06      	cmp	Y, #6
    741e:	1d2d      	jne	0x747a <.L354>

00007420 <.LM654>:
			{
				MotClearStallFlag(2);																	/* clear stall flag if set */
    7420:	7002      	lod	A, #2
    7422:	82db 3f3e 	callf	0x7e7c <_MotClearStallFlag>

00007426 <.LM655>:
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
    7426:	72d8 1226 	lod	A, 0x1226 <.LASF1421+0xd>
    742a:	7ee2      	lod	X, A
    742c:	22da ff47 	add	X, #65351

00007430 <.LM656>:
				if (valve.calibration.d360Angle < 0)
    7430:	2c00      	cmp	X, #0
    7432:	1e85      	jsge	0x743e <.L355>

00007434 <.LM657>:
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7434:	a2da 0d57 	add	A, #3415

00007438 <.L546>:
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
				{
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7438:	52d8 1236 	mov	0x1236 <.Lframe0+0x6>, A
    743c:	0005      	jmp	0x7448 <.L356>

0000743e <.L355>:
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
				if (valve.calibration.d360Angle < 0)
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    743e:	2eda 0e0f 	cmp	X, #3599
    7442:	1f18      	jsg	0x7474 <.L357>

00007444 <.LM660>:
		else
		{
			if (valve.motorMotion == MOTION_STALL)
			{
				MotClearStallFlag(2);																	/* clear stall flag if set */
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
    7444:	5ed8 1236 	mov	0x1236 <.Lframe0+0x6>, X

00007448 <.L356>:
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else
				{
				}
				valve.calibration.travel = valve.calibration.d360Angle - valve.calibration.d0Angle;
    7448:	72d8 1236 	lod	A, 0x1236 <.Lframe0+0x6>
    744c:	7ee2      	lod	X, A
    744e:	2ad8 1234 	sub	X, 0x1234 <.Lframe0+0x4>
    7452:	5ed8 1232 	mov	0x1232 <.Lframe0+0x2>, X

00007456 <.LM662>:
#if 1
				valve.pos.modeAngle[C_MODE_A] = valve.calibration.d360Angle;
    7456:	52d8 1228 	mov	0x1228 <.LASF1421+0xf>, A

0000745a <.LM663>:
#endif
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
    745a:	0ea7      	lod	C, ML.7
    745c:	72d8 122a 	lod	A, 0x122a <.LASF1421+0x11>

00007460 <.LBB452>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    7460:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A

00007464 <.LBE452>:
				valve.calibration.travel = valve.calibration.d360Angle - valve.calibration.d0Angle;
#if 1
				valve.pos.modeAngle[C_MODE_A] = valve.calibration.d360Angle;
#endif
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				MotSetTargetPosition(valve.pos.targetAngle);
    7464:	82db 3f24 	callf	0x7e48 <_MotSetTargetPosition>

00007468 <.LM666>:
				valve.calibration.delay = 3;
    7468:	7003      	lod	A, #3
    746a:	0ea7      	lod	C, ML.7
    746c:	52d8 1238 	mov	0x1238 <.Lframe0+0x8>, A

00007470 <.LM667>:
				valve.calibration.state = CALSTEP_INIT_POS;
    7470:	6007      	lod	AL, #7
    7472:	0741      	jmp	0x72f6 <.L559>

00007474 <.L357>:
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
				{
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7474:	a2da f137 	add	A, #61751
    7478:	07df      	jmp	0x7438 <.L546>

0000747a <.L354>:
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				MotSetTargetPosition(valve.pos.targetAngle);
				valve.calibration.delay = 3;
				valve.calibration.state = CALSTEP_INIT_POS;
			}
			else if (valve.motorMotion == MOTION_STOPPED)
    747a:	7a01      	lod	Y, [S-2]
    747c:	ec01      	cmp	Y, #1
    747e:	1d01      	jne	0x7482 <.L389>
    7480:	076b      	jmp	0x7358 <.L561>

00007482 <.L389>:
		}
		valve.state = nextState;
	}
	else
	{
		if (valve.elapsedTime < 0xffffu)
    7482:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    7486:	acff      	cmp	A, #-1
    7488:	1d01      	jne	0x748c <.LM671>
    748a:	065e      	jmp	0x7148 <.L391>

0000748c <.LM671>:
			valve.elapsedTime += 1;
    748c:	a001      	add	A, #1
    748e:	52d8 121c 	mov	0x121c <.LASF1421+0x3>, A
    7492:	065a      	jmp	0x7148 <.L391>

00007494 <.L336>:
				valve.calibration.state = CALSTEP_FAULT;
			}
		}
		break;
	case CALSTEP_CALC:
		if (valve.calibration.delay > 0)
    7494:	72d8 1238 	lod	A, 0x1238 <.Lframe0+0x8>
    7498:	1901      	je	0x749c <.LM673>
    749a:	0763      	jmp	0x7362 <.L560>

0000749c <.LM673>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
    749c:	72ee      	lod	A, X
    749e:	a2da 00b9 	add	A, #185

000074a2 <.LM674>:
			if (valve.calibration.d0Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    74a2:	aeda 0e0f 	cmp	A, #3599
    74a6:	1b05      	jsle	0x74b2 <.L359>

000074a8 <.LM675>:
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    74a8:	22da f2a9 	add	X, #62121

000074ac <.L547>:
			}
			else if (valve.calibration.d0Angle < 0)
			{
				valve.calibration.d0Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    74ac:	5ed8 1234 	mov	0x1234 <.Lframe0+0x4>, X
    74b0:	0004      	jmp	0x74ba <.L360>

000074b2 <.L359>:
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
			if (valve.calibration.d0Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
			}
			else if (valve.calibration.d0Angle < 0)
    74b2:	ac00      	cmp	A, #0
    74b4:	1a96      	jsl	0x74e2 <.L361>

000074b6 <.LM678>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
    74b6:	52d8 1234 	mov	0x1234 <.Lframe0+0x4>, A

000074ba <.L360>:
			else
			{
			}
#if 1

			valve.pos.modeAngle[C_MODE_B] = valve.calibration.d0Angle;
    74ba:	72d8 1234 	lod	A, 0x1234 <.Lframe0+0x4>
    74be:	52d8 122a 	mov	0x122a <.LASF1421+0x11>, A

000074c2 <.LM680>:
#endif
			if (valve.calibration.req2Cal != 0)
    74c2:	7a0b      	lod	Y, [S-12]
    74c4:	1911      	je	0x74e8 <.L362>

000074c6 <.LBB454>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    74c6:	72da 0e74 	lod	A, #3700
    74ca:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A

000074ce <.LBE454>:
			valve.pos.modeAngle[C_MODE_B] = valve.calibration.d0Angle;
#endif
			if (valve.calibration.req2Cal != 0)
			{
				ValveTargetAngleUpdate(370 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 360% position */
				valve.calibration.state = CALSTEP_360d_POS;
    74ce:	6003      	lod	AL, #3

000074d0 <.L548>:
			}
			else
			{
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				valve.calibration.state = CALSTEP_INIT_POS;
    74d0:	42d8 122e 	mov	0x122e <.LLST5+0x2>, AL

000074d4 <.LM684>:
			}
			MotClearHardStop();
    74d4:	82db 3f20 	callf	0x7e40 <_MotClearHardStop>

000074d8 <.LM685>:
			MotSetTargetPosition(valve.pos.targetAngle);
    74d8:	72d8 1224 	lod	A, 0x1224 <.LASF1421+0xb>
    74dc:	82db 3f24 	callf	0x7e48 <_MotSetTargetPosition>
    74e0:	070c      	jmp	0x72fa <.L400>

000074e2 <.L361>:
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
			}
			else if (valve.calibration.d0Angle < 0)
			{
				valve.calibration.d0Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    74e2:	22da 0ec9 	add	X, #3785
    74e6:	07e2      	jmp	0x74ac <.L547>

000074e8 <.L362>:
		l_u8_wr_Fwv_Stall_State(0);
	}
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    74e8:	52d8 1224 	mov	0x1224 <.LASF1421+0xb>, A

000074ec <.LBE456>:
				valve.calibration.state = CALSTEP_360d_POS;
			}
			else
			{
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				valve.calibration.state = CALSTEP_INIT_POS;
    74ec:	6007      	lod	AL, #7
    74ee:	07f0      	jmp	0x74d0 <.L548>

000074f0 <.L337>:
			MotClearHardStop();
			MotSetTargetPosition(valve.pos.targetAngle);
		}
		break;
	case CALSTEP_INIT_POS:
		if (valve.calibration.delay > 0)
    74f0:	72d8 1238 	lod	A, 0x1238 <.Lframe0+0x8>
    74f4:	1901      	je	0x74f8 <.LM690>
    74f6:	0735      	jmp	0x7362 <.L560>

000074f8 <.LM690>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			if (valve.motorMotion == MOTION_STALL)
    74f8:	7a01      	lod	Y, [S-2]
    74fa:	ec06      	cmp	Y, #6
    74fc:	1d06      	jne	0x750a <.L365>

000074fe <.LM691>:
			{

				MotClearStallFlag(2); /* clear stall flag if set */
    74fe:	7002      	lod	A, #2
    7500:	82db 3f3e 	callf	0x7e7c <_MotClearStallFlag>

00007504 <.LM692>:
				MotRequestHardStop();
    7504:	82db 3f1c 	callf	0x7e38 <_MotRequestHardStop>
    7508:	0727      	jmp	0x7358 <.L561>

0000750a <.L365>:

				valve.calibration.state = CALSTEP_FAULT;
			}
			else if (valve.motorMotion == MOTION_STOPPED)
    750a:	7a01      	lod	Y, [S-2]
    750c:	ec01      	cmp	Y, #1
    750e:	1901      	je	0x7512 <.LM694>
    7510:	07b8      	jmp	0x7482 <.L389>

00007512 <.LM694>:
			{

				valve.calibration.state = CALSTEP_COMPLETED;
    7512:	6009      	lod	AL, #9
    7514:	06f0      	jmp	0x72f6 <.L559>

00007516 <.L338>:
		}
		break;

	case CALSTEP_FAULT:

		valve.calibration.req2Cal = 0;
    7516:	7000      	lod	A, #0
    7518:	52d8 1230 	mov	0x1230 <.Lframe0>, A

0000751c <.LM696>:
		valve.calibration.req1Cal = 0;
		valve.diag.calFault = 1;
    751c:	6001      	lod	AL, #1
    751e:	0ea7      	lod	C, ML.7
    7520:	42d8 1285 	mov	0x1285 <.LASF1443+0x9>, AL

00007524 <.LM697>:
		u16EventState = VALVE_CAL_FAULT;
    7524:	7009      	lod	A, #9
    7526:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000752a <.LM698>:
		u16EventValue = valve.pos.currentAngle;
    752a:	0ea7      	lod	C, ML.7
    752c:	5ed8 10b4 	mov	0x10b4 <_u16EventValue>, X

00007530 <.L553>:
	}
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
    7530:	7c06      	lod	X, #6
    7532:	05f8      	jmp	0x7124 <.L305>

00007534 <.L339>:

		nextState = VALVE_FAULT;
		break;
	case CALSTEP_COMPLETED:

		valve.calibration.req2Cal = 0;
    7534:	7000      	lod	A, #0
    7536:	52d8 1230 	mov	0x1230 <.Lframe0>, A
    753a:	05ba      	jmp	0x70b0 <.L549>

0000753c <.L300>:
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
	uint16_t status = 1;
	MotRequestHardStop();
    753c:	82db 3f1c 	callf	0x7e38 <_MotRequestHardStop>

00007540 <.LM702>:
	valve.comm.lastMode = 0xff;
    7540:	60ff      	lod	AL, #-1
    7542:	42d8 1242 	mov	0x1242 <.LLST27+0x3>, AL

00007546 <.LM703>:
	if (valve.initStatus != 0)
    7546:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    754a:	1926      	je	0x7598 <.L367>

0000754c <.LM704>:
	{
		valve.initStatus = 0;
    754c:	6000      	lod	AL, #0
    754e:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

00007552 <.LM705>:
		if (valve.diag.calFault != 0)
    7552:	62d8 1285 	lod	AL, 0x1285 <.LASF1443+0x9>
    7556:	1905      	je	0x7562 <.L368>

00007558 <.LM706>:
		{
			valve.diag.calRetryCnt += 1;
    7558:	62d8 1289 	lod	AL, 0x1289 <.LASF1443+0xd>
    755c:	8001      	add	AL, #1
    755e:	42d8 1289 	mov	0x1289 <.LASF1443+0xd>, AL

00007562 <.L368>:
		}
		if ((valve.diag.stallFault & STALL_MASK_PERMENT) != 0)
    7562:	62d8 1287 	lod	AL, 0x1287 <.LASF1443+0xb>
    7566:	9402      	and	AL, #2
    7568:	1905      	je	0x7574 <.L369>

0000756a <.LM708>:
		{
			valve.diag.stallRetryCnt += 1;
    756a:	62d8 1288 	lod	AL, 0x1288 <.LASF1443+0xc>
    756e:	8001      	add	AL, #1
    7570:	42d8 1288 	mov	0x1288 <.LASF1443+0xc>, AL

00007574 <.L369>:
		}
		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0)
    7574:	66d8 1286 	lod	YL, 0x1286 <.LASF1443+0xa>
    7578:	62e8      	lod	AL, YL
    757a:	9401      	and	AL, #1
    757c:	1905      	je	0x7588 <.L370>

0000757e <.LM710>:
		{
			valve.diag.motOpenRetryCnt += 1;
    757e:	62d8 128b 	lod	AL, 0x128b <.LASF1443+0xf>
    7582:	8001      	add	AL, #1
    7584:	42d8 128b 	mov	0x128b <.LASF1443+0xf>, AL

00007588 <.L370>:
		}
		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0)
    7588:	62e8      	lod	AL, YL
    758a:	9410      	and	AL, #16
    758c:	1905      	je	0x7598 <.L367>

0000758e <.LM712>:
		{
			valve.diag.motShortRetryCnt += 1;
    758e:	62d8 128c 	lod	AL, 0x128c <.LASF1443+0x10>
    7592:	8001      	add	AL, #1
    7594:	42d8 128c 	mov	0x128c <.LASF1443+0x10>, AL

00007598 <.L367>:
		}
	}

	if (valve.elapsedTime >= 1000u)
    7598:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    759c:	aeda 03e7 	cmp	A, #999
    75a0:	1e01      	jug	0x75a4 <.LM714>
    75a2:	0052      	jmp	0x7648 <.L406>

000075a4 <.LM714>:
	{
		if (valve.diag.calRetryCnt < 3)
    75a4:	62d8 1289 	lod	AL, 0x1289 <.LASF1443+0xd>
    75a8:	8c02      	cmp	AL, #2
    75aa:	1e03      	jug	0x75b2 <.L373>

000075ac <.LM715>:
		{
			valve.diag.calFault = 0;
    75ac:	6000      	lod	AL, #0
    75ae:	42d8 1285 	mov	0x1285 <.LASF1443+0x9>, AL

000075b2 <.L373>:
		}
		if (valve.diag.stallRetryCnt < 3)
    75b2:	62d8 1288 	lod	AL, 0x1288 <.LASF1443+0xc>
    75b6:	8c02      	cmp	AL, #2
    75b8:	1e03      	jug	0x75c0 <.L374>

000075ba <.LM717>:
		{
			MotClearStallFlag(2);
    75ba:	7002      	lod	A, #2
    75bc:	82db 3f3e 	callf	0x7e7c <_MotClearStallFlag>

000075c0 <.L374>:
		}
		if (valve.diag.motOpenRetryCnt < 3)
    75c0:	62d8 128b 	lod	AL, 0x128b <.LASF1443+0xf>
    75c4:	8c02      	cmp	AL, #2
    75c6:	1e03      	jug	0x75ce <.L375>

000075c8 <.LM719>:
		{
			MotClearFaultFlag(1);
    75c8:	7001      	lod	A, #1
    75ca:	82db 3f4d 	callf	0x7e9a <_MotClearFaultFlag>

000075ce <.L375>:
		}
		if (valve.diag.motShortRetryCnt < 3)
    75ce:	62d8 128c 	lod	AL, 0x128c <.LASF1443+0x10>
    75d2:	8c02      	cmp	AL, #2
    75d4:	1e03      	jug	0x75dc <.L376>

000075d6 <.LM721>:
		{
			MotClearFaultFlag(2);
    75d6:	7002      	lod	A, #2
    75d8:	82db 3f4d 	callf	0x7e9a <_MotClearFaultFlag>

000075dc <.L376>:
		}

		if (valve.diag.calFault != 0)
    75dc:	66d8 1285 	lod	YL, 0x1285 <.LASF1443+0x9>

000075e0 <.LM723>:
		{
			status = 0;
		}

		if (MotGetFaultState() != 0)
    75e0:	5a03      	mov	[S-4], Y
    75e2:	82db 3f77 	callf	0x7eee <_MotGetFaultState>
    75e6:	7a03      	lod	Y, [S-4]
    75e8:	ac00      	cmp	A, #0
    75ea:	1901      	je	0x75ee <.LM724>
    75ec:	002f      	jmp	0x764c <.L407>

000075ee <.LM724>:
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
	uint16_t status = 1;
    75ee:	62e8      	lod	AL, YL
    75f0:	5c86      	se	Y

000075f2 <.L372>:
		{
			status = 0;
		}
	}

		if (MotGetStallState() != 0)
    75f2:	5a03      	mov	[S-4], Y
    75f4:	82db 3f73 	callf	0x7ee6 <_MotGetStallState>

000075f8 <.LVL294>:
    75f8:	7a03      	lod	Y, [S-4]
    75fa:	ac00      	cmp	A, #0
    75fc:	1901      	je	0x7600 <.L377>

000075fe <.LM726>:
		{
			status = 0;
    75fe:	7800      	lod	Y, #0

00007600 <.L377>:

	/**
	 * @brief Checks and maintains the fault state based on current diagnostic conditions.
	 */

	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)	// Check if critical motor fault (e.g., Over Current) is active
    7600:	62d8 1286 	lod	AL, 0x1286 <.LASF1443+0xa>
    7604:	9440      	and	AL, #64
    7606:	1901      	je	0x760a <.L378>

00007608 <.LM728>:
	{
		status = 0; 
    7608:	7800      	lod	Y, #0

0000760a <.L378>:
	}
	if (valve.diag.comm.state != COMMUNICATION_NORNAL)	// Check if communication is currently abnormal
    760a:	72d8 1262 	lod	A, 0x1262 <.LLST28+0x3>
    760e:	1901      	je	0x7612 <.L379>

00007610 <.LM730>:
	{
		status = 0;
    7610:	7800      	lod	Y, #0

00007612 <.L379>:
	}
	if (valve.diag.vs.state != VS_NORMAL)	// Check if Voltage Supply (VS) state is abnormal
    7612:	72d8 1256 	lod	A, 0x1256 <.LASF1692+0xb>
    7616:	1901      	je	0x761a <.L380>

00007618 <.LM732>:
	{
		status = 0;
    7618:	7800      	lod	Y, #0

0000761a <.L380>:
	}
	if (valve.diag.McuFault != MCU_NORMAL)	// Check if the MCU has an active fault
    761a:	62d8 1281 	lod	AL, 0x1281 <.LASF1443+0x5>
    761e:	1901      	je	0x7622 <.L381>

00007620 <.LM734>:
	{
		status = 0;
    7620:	7800      	lod	Y, #0

00007622 <.L381>:
	}
	if (valve.diag.gmr.state != GMR_SENSOR_NORMAL)	// Check if GMR sensor state is abnormal
    7622:	62d8 1276 	lod	AL, 0x1276 <.LLST29+0x4>
    7626:	1901      	je	0x762a <.L382>

00007628 <.LM736>:
	{
		status = 0;
    7628:	7800      	lod	Y, #0

0000762a <.L382>:
	}
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)	// Check if a temporary stall fault is active
    762a:	62d8 1287 	lod	AL, 0x1287 <.LASF1443+0xb>
    762e:	9401      	and	AL, #1
    7630:	1901      	je	0x7634 <.L383>

00007632 <.LM738>:
	{
		status = 0;
    7632:	7800      	lod	Y, #0

00007634 <.L383>:
	}
	if (valve.pos.fault != POS_NORMAL)	// Check if a position error/fault is active
    7634:	62d8 122c 	lod	AL, 0x122c <.LLST5>
    7638:	1d03      	jne	0x7640 <.L384>

0000763a <.LM740>:
	{
		status = 0;
	}

	if (status != 0)
    763a:	ec00      	cmp	Y, #0
    763c:	1901      	je	0x7640 <.L384>
    763e:	0538      	jmp	0x70b0 <.L549>

00007640 <.L384>:
		//			nextState=valve.lastState;
		nextState = VALVE_STANDBY;
	}
	else
	{
		valve.comm.faultMode = 1;
    7640:	6001      	lod	AL, #1
    7642:	42d8 1245 	mov	0x1245 <.LLST27+0x6>, AL
    7646:	0774      	jmp	0x7530 <.L553>

00007648 <.L406>:
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
	uint16_t status = 1;
    7648:	7801      	lod	Y, #1
    764a:	07d3      	jmp	0x75f2 <.L372>

0000764c <.L407>:
			status = 0;
		}

		if (MotGetFaultState() != 0)
		{
			status = 0;
    764c:	7800      	lod	Y, #0
    764e:	07d1      	jmp	0x75f2 <.L372>

00007650 <.L301>:
	Protectoin_Check_Result final_result;

	final_result.next_state = VALVE_PROTECTION;
	final_result.status = 1;

	MotRequestHardStop();
    7650:	13f3      	call	0x7e38 <_MotRequestHardStop>

00007652 <.LM745>:
	valve.comm.lastMode = 0xff;
    7652:	60ff      	lod	AL, #-1
    7654:	42d8 1242 	mov	0x1242 <.LLST27+0x3>, AL

00007658 <.LM746>:

	final_result = check_protection_uv_ov(final_result);	// Verification Complete
    7658:	4ce2 0001 	mov	YA, #458753
    765c:	0007 
    765e:	58a3      	mov	[S-10], YA

00007660 <.LVL306>:
    7660:	7209      	lod	A, [S-10]
    7662:	7807      	lod	Y, #7
    7664:	82db 32d1 	callf	0x65a2 <_check_protection_uv_ov>
    7668:	5209      	mov	[S-10], A
    766a:	5a07      	mov	[S-8], Y

0000766c <.LM747>:

	final_result = check_protection_temp(final_result);		// Verification Complete
    766c:	82db 32f6 	callf	0x65ec <_check_protection_temp>
    7670:	5209      	mov	[S-10], A

00007672 <.LVL310>:
    7672:	5a07      	mov	[S-8], Y

00007674 <.LM748>:

	final_result = check_protection_comm(final_result);		// Verification Complete
    7674:	82db 330c 	callf	0x6618 <_check_protection_comm>
    7678:	5209      	mov	[S-10], A

0000767a <.LVL313>:
    767a:	5a07      	mov	[S-8], Y

0000767c <.LM749>:

	final_result = check_protection_oc(final_result);		// Verification Complete
    767c:	82db 333d 	callf	0x667a <_check_protection_oc>
    7680:	5209      	mov	[S-10], A

00007682 <.LVL316>:
    7682:	5a07      	mov	[S-8], Y

00007684 <.LM750>:

	final_result = check_protection_mcu_fault(final_result);	// Verification Complete
    7684:	82db 33bd 	callf	0x677a <_check_protection_mcu_fault>
    7688:	5209      	mov	[S-10], A

0000768a <.LVL319>:
    768a:	5a07      	mov	[S-8], Y

0000768c <.LM751>:
	
	final_result = check_protection_obstruction_stall(final_result);	// Verification Complete
    768c:	82db 33e9 	callf	0x67d2 <_check_protection_obstruction_stall>
    7690:	5209      	mov	[S-10], A

00007692 <.LVL322>:
    7692:	5a07      	mov	[S-8], Y

00007694 <.LM752>:

	final_result = check_protection_gmr_fault(final_result);	// Verification Complete
    7694:	82db 3428 	callf	0x6850 <_check_protection_gmr_fault>
    7698:	5209      	mov	[S-10], A

0000769a <.LVL325>:
    769a:	5a07      	mov	[S-8], Y

0000769c <.LM753>:

	final_result = check_protection_pos_fault(final_result);
    769c:	82db 337e 	callf	0x66fc <_check_protection_pos_fault>
    76a0:	5209      	mov	[S-10], A

000076a2 <.LVL328>:
    76a2:	5a07      	mov	[S-8], Y

000076a4 <.LVL329>:
    76a4:	7ee6      	lod	X, Y

000076a6 <.LM754>:

	if (final_result.status != 0)
    76a6:	6209      	lod	AL, [S-10]
    76a8:	1901      	je	0x76ac <.LASF1625+0x4>
    76aa:	0502      	jmp	0x70b0 <.L549>
    76ac:	053b      	jmp	0x7124 <.L305>

000076ae <.L302>:
}
static tValveState ValvePowerLatchTask(void)
{
	tValveState nextState = VALVE_POWERLATCH;

	MotRequestHardStop();
    76ae:	13c4      	call	0x7e38 <_MotRequestHardStop>

000076b0 <.LM756>:
	if (valve.initStatus != 0)
    76b0:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    76b4:	1903      	je	0x76bc <.L386>

000076b6 <.LM757>:
	{
		valve.initStatus = 0;
    76b6:	6000      	lod	AL, #0
    76b8:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000076bc <.L386>:
	}
	if (valve.diag.ign.state != IGN_OFF)
    76bc:	72d8 1270 	lod	A, 0x1270 <.LLST28+0x11>
    76c0:	ac01      	cmp	A, #1
    76c2:	1927      	je	0x7712 <.L416>

000076c4 <.LM759>:
	{

		nextState = valve.lastState;
    76c4:	7ed8 1218 	lod	X, 0x1218 <_valve+0x2>

000076c8 <.LVL333>:
    76c8:	052d      	jmp	0x7124 <.L305>

000076ca <.L303>:

static tValveState ValveLowPowerTask(void)
{
	tValveState nextState = VALVE_LOWPOWER;

	if (valve.initStatus != 0)
    76ca:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    76ce:	1903      	je	0x76d6 <.L387>

000076d0 <.LM761>:
	{
		valve.initStatus = 0;
    76d0:	6000      	lod	AL, #0
    76d2:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

000076d6 <.L387>:
	}
	if (valve.diag.ign.state != IGN_OFF)
    76d6:	72d8 1270 	lod	A, 0x1270 <.LLST28+0x11>
    76da:	ac01      	cmp	A, #1
    76dc:	1d0c      	jne	0x76f6 <.L417>

000076de <.LM763>:
	return final_result.next_state;
}

static tValveState ValveLowPowerTask(void)
{
	tValveState nextState = VALVE_LOWPOWER;
    76de:	7c09      	lod	X, #9

000076e0 <.L388>:
	{

		nextState = VALVE_STANDBY;
	}

	if (valve.elapsedTime >= 60000u) /*60sec*/
    76e0:	72d8 121c 	lod	A, 0x121c <.LASF1421+0x3>
    76e4:	aeda ea5f 	cmp	A, #59999
    76e8:	1e01      	jug	0x76ec <.LM765>
    76ea:	051c      	jmp	0x7124 <.L305>

000076ec <.LM765>:
	{
		AppLinSleepEnter();
    76ec:	5e05      	mov	[S-6], X
    76ee:	82db 3217 	callf	0x642e <_AppLinSleepEnter>

000076f2 <.LVL336>:
    76f2:	7e05      	lod	X, [S-6]
    76f4:	0517      	jmp	0x7124 <.L305>

000076f6 <.L417>:
		valve.initStatus = 0;
	}
	if (valve.diag.ign.state != IGN_OFF)
	{

		nextState = VALVE_STANDBY;
    76f6:	7c01      	lod	X, #1
    76f8:	07f3      	jmp	0x76e0 <.L388>

000076fa <.L304>:
static tValveState ValveUndefTask(void)
{

	tValveState nextState = VALVE_UNDEF;

	if (valve.initStatus != 0)
    76fa:	62d8 1221 	lod	AL, 0x1221 <.LASF1421+0x8>
    76fe:	1903      	je	0x7706 <.L418>

00007700 <.LM768>:
	{
		valve.initStatus = 0;
    7700:	6000      	lod	AL, #0
    7702:	42d8 1221 	mov	0x1221 <.LASF1421+0x8>, AL

00007706 <.L418>:
		break;
	case VALVE_LOWPOWER:
		nextState = ValveLowPowerTask();
		break;
	case VALVE_UNDEF:
		nextState = ValveUndefTask();
    7706:	7c0a      	lod	X, #10
    7708:	050d      	jmp	0x7124 <.L305>

0000770a <.L397>:
	*/
}

static tValveState ValveInitTask(void)
{
	tValveState nextState = VALVE_INIT;
    770a:	7c00      	lod	X, #0
    770c:	050b      	jmp	0x7124 <.L305>

0000770e <.L404>:
				valve.pos.fault = POS_FAULT;
			}
#endif
			if (valve.pos.fault != 0)
			{
				nextState = VALVE_PROTECTION;
    770e:	7c07      	lod	X, #7

00007710 <.LVL341>:
    7710:	0509      	jmp	0x7124 <.L305>

00007712 <.L416>:
	}
	return nextState;
}
static tValveState ValvePowerLatchTask(void)
{
	tValveState nextState = VALVE_POWERLATCH;
    7712:	7c08      	lod	X, #8
    7714:	0507      	jmp	0x7124 <.L305>

00007716 <.L392>:
		valve.diag.comm.state = COMMUNICATION_NORNAL;
		clear_fail_safe_retry_cnt(VALVE_LIN_COMM_FAULT);
	}
	else
	{
		valve.diag.comm.state = COMMUNICATION_ERROR;
    7716:	7001      	lod	A, #1
    7718:	52d8 1262 	mov	0x1262 <.LLST28+0x3>, A
    771c:	0522      	jmp	0x7162 <.L393>

0000771e <_adc_DoSoftwareTrigger>:
    771e:	5803      	inc	S, #4

00007720 <.LCFI0>:
    7720:	5201      	mov	[S-2], A

00007722 <.LM2>:
    7722:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>

00007726 <.LVL2>:
    7726:	9401      	and	AL, #1
    7728:	1d0a      	jne	0x773e <.L2>

0000772a <.LBB540>:
    772a:	601f      	lod	AL, #31
    772c:	42d8 016b 	mov	0x16b <.LASF1177+0x2>, AL

00007730 <.LBB542>:
    7730:	7002      	lod	A, #2
    7732:	0ea7      	lod	C, ML.7
    7734:	52d8 016a 	mov	0x16a <.LASF1177+0x1>, A

00007738 <.LBB544>:
    7738:	7001      	lod	A, #1
    773a:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

0000773e <.L2>:
    773e:	7028      	lod	A, #40
    7740:	82db 1128 	callf	0x2250 <_delay_cycles>

00007744 <.LBB549>:
    7744:	6004      	lod	AL, #4
    7746:	42d8 016a 	mov	0x16a <.LASF1177+0x1>, AL

0000774a <.L3>:
    774a:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    774e:	b402      	and	A, #2
    7750:	1902      	je	0x7756 <.L5>

00007752 <.LM9>:
    7752:	7000      	lod	A, #0
    7754:	5405      	ret	#6

00007756 <.L5>:
    7756:	7ed8 016a 	lod	X, 0x16a <.LASF1177+0x1>
    775a:	7aee      	lod	Y, X
    775c:	44c8      	rl	YL, #2
    775e:	f403      	and	Y, #3
    7760:	ee01      	cmp	Y, [S-2]
    7762:	1906      	je	0x7770 <.L6>

00007764 <.LM11>:
    7764:	7ed8 016a 	lod	X, 0x16a <.LASF1177+0x1>
    7768:	36da 1000 	and	X, #4096
    776c:	196e      	je	0x774a <.L3>

0000776e <.L4>:
    776e:	5405      	ret	#6

00007770 <.L6>:
    7770:	7001      	lod	A, #1
    7772:	07fd      	jmp	0x776e <.L4>

00007774 <_adc_Init>:
    7774:	1290      	call	0x7c96 <_conv_high_voltage_init>

00007776 <.LM16>:
    7776:	12df      	call	0x7d36 <_conv_low_voltage_init>

00007778 <.LM17>:
    7778:	12f7      	call	0x7d68 <_conv_motor_voltage_init>

0000777a <.LM18>:
    777a:	132c      	call	0x7dd4 <_conv_shunt_current_init>

0000777c <.LBB551>:
    777c:	7000      	lod	A, #0
    777e:	52d8 133e 	mov	0x133e <_calib_current>, A

00007782 <.LBE551>:
    7782:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    7786:	8404      	or	AL, #4
    7788:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

0000778c <.LBB553>:
    778c:	72da 2710 	lod	A, #10000
    7790:	82db 1128 	callf	0x2250 <_delay_cycles>

00007794 <.LBE553>:
    7794:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    7798:	8440      	or	AL, #64
    779a:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

0000779e <.LM23>:
    779e:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    77a0:	8402      	or	AL, #2
    77a2:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000077a4 <.LBB556>:
    77a4:	7ee3      	lod	X, M

000077a6 <.LBB559>:
    77a6:	5049      	call	fp2:0x48

000077a8 <.LBE559>:
    77a8:	62d8 008c 	lod	AL, 0x8c <.LASF1529>
    77ac:	94f3      	and	AL, #-13
    77ae:	8404      	or	AL, #4
    77b0:	42d8 008c 	mov	0x8c <.LASF1529>, AL

000077b4 <.LM27>:
    77b4:	62d8 0070 	lod	AL, 0x70 <__mlx4_cst_tables_ram_size+0x12>
    77b8:	8420      	or	AL, #32
    77ba:	42d8 0070 	mov	0x70 <__mlx4_cst_tables_ram_size+0x12>, AL

000077be <.LBB561>:
    77be:	5ee3      	mov	M, X

000077c0 <.LBE556>:
    77c0:	5401      	ret

000077c2 <_adc_Start>:
    77c2:	7ee2      	lod	X, A

000077c4 <.LBB565>:
    77c4:	601f      	lod	AL, #31

000077c6 <.LVL18>:
    77c6:	42d8 016b 	mov	0x16b <.LASF1177+0x2>, AL

000077ca <.LBB567>:
    77ca:	7002      	lod	A, #2
    77cc:	0ea7      	lod	C, ML.7
    77ce:	52d8 016a 	mov	0x16a <.LASF1177+0x1>, A

000077d2 <.LBB569>:
    77d2:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    77d4:	8402      	or	AL, #2
    77d6:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000077d8 <.LM38>:
    77d8:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    77dc:	94fc      	and	AL, #-4
    77de:	8402      	or	AL, #2
    77e0:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

000077e4 <.LM39>:
    77e4:	6007      	lod	AL, #7
    77e6:	42d8 016c 	mov	0x16c <.LASF1177+0x3>, AL

000077ea <.LM40>:
    77ea:	0ea7      	lod	C, ML.7
    77ec:	72da 101a 	lod	A, #4122
    77f0:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

000077f4 <.LM41>:
    77f4:	72da 0ac4 	lod	A, #2756
    77f8:	0ea7      	lod	C, ML.7
    77fa:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

000077fe <.LBB571>:
    77fe:	7ae3      	lod	Y, M

00007800 <.LBB574>:
    7800:	5049      	call	fp2:0x48

00007802 <.LBE574>:
    7802:	6020      	lod	AL, #32
    7804:	42d8 0054 	mov	0x54 <.Lframe0>, AL

00007808 <.LBB576>:
    7808:	5ae3      	mov	M, Y

0000780a <.LBB580>:
    780a:	7001      	lod	A, #1
    780c:	0ea7      	lod	C, ML.7
    780e:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00007812 <.LBE580>:
    7812:	2c00      	cmp	X, #0
    7814:	1904      	je	0x781e <.L10>

00007816 <.L12>:
    7816:	72d8 0054 	lod	A, 0x54 <.Lframe0>
    781a:	9420      	and	AL, #32
    781c:	197c      	je	0x7816 <.L12>

0000781e <.L10>:
    781e:	5401      	ret

00007820 <_adc_Stop>:
    7820:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7824:	9402      	and	AL, #2
    7826:	1d1c      	jne	0x7860 <.L18>

00007828 <.L39>:
    7828:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    782c:	9402      	and	AL, #2
    782e:	1d14      	jne	0x7858 <.L22>

00007830 <.LBB593>:
    7830:	7002      	lod	A, #2
    7832:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    7836:	07f8      	jmp	0x7828 <.L39>

00007838 <.L23>:
    7838:	7001      	lod	A, #1
    783a:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

0000783e <.L40>:
    783e:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7842:	9401      	and	AL, #1
    7844:	1979      	je	0x7838 <.L23>

00007846 <.LBB597>:
    7846:	0000      	nop

00007848 <.L41>:
    7848:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    784c:	9402      	and	AL, #2
    784e:	1d04      	jne	0x7858 <.L22>

00007850 <.LBB599>:
    7850:	7002      	lod	A, #2
    7852:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    7856:	07f8      	jmp	0x7848 <.L41>

00007858 <.L22>:
    7858:	72d8 016a 	lod	A, 0x16a <.LASF1177+0x1>
    785c:	94c0      	and	AL, #-64
    785e:	1d6f      	jne	0x783e <.L40>

00007860 <.L18>:
    7860:	5401      	ret

00007862 <_adc_Shunt_OffsetCalib>:
    7862:	581d      	inc	S, #30

00007864 <.LCFI1>:
    7864:	7eef      	lod	X, S
    7866:	20f0      	add	X, #-16
    7868:	7800      	lod	Y, #0
    786a:	72e6      	lod	A, Y
    786c:	52de      	mov	[X++], A
    786e:	52de      	mov	[X++], A
    7870:	52de      	mov	[X++], A
    7872:	720f      	lod	A, [S-16]
    7874:	5207      	mov	[S-8], A
    7876:	720d      	lod	A, [S-14]
    7878:	5205      	mov	[S-6], A
    787a:	720b      	lod	A, [S-12]
    787c:	5203      	mov	[S-4], A
    787e:	72ef      	lod	A, S
    7880:	a0ea      	add	A, #-22
    7882:	5209      	mov	[S-10], A
    7884:	7207      	lod	A, [S-8]
    7886:	b483      	and	A, #-125
    7888:	a440      	or	A, #64
    788a:	b6da fc7f 	and	A, #64639
    788e:	a6da 0180 	or	A, #384
    7892:	5207      	mov	[S-8], A
    7894:	7205      	lod	A, [S-6]
    7896:	b483      	and	A, #-125
    7898:	a440      	or	A, #64
    789a:	b6da fc7f 	and	A, #64639
    789e:	a6da 0180 	or	A, #384
    78a2:	5205      	mov	[S-6], A
    78a4:	7203      	lod	A, [S-4]
    78a6:	8403      	or	AL, #3
    78a8:	5203      	mov	[S-4], A
    78aa:	7209      	lod	A, [S-10]
    78ac:	521d      	mov	[S-30], A
    78ae:	7207      	lod	A, [S-8]
    78b0:	521b      	mov	[S-28], A
    78b2:	7205      	lod	A, [S-6]
    78b4:	5219      	mov	[S-26], A
    78b6:	7203      	lod	A, [S-4]
    78b8:	5217      	mov	[S-24], A

000078ba <.LM63>:
    78ba:	5a01      	mov	[S-2], Y
    78bc:	17b1      	call	0x7820 <_adc_Stop>

000078be <.LM64>:
    78be:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    78c2:	8440      	or	AL, #64
    78c4:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

000078c8 <.LM65>:
    78c8:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    78ca:	8402      	or	AL, #2
    78cc:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000078ce <.LBB601>:
    78ce:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    78d0:	8402      	or	AL, #2
    78d2:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000078d4 <.LM67>:
    78d4:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    78d8:	94fc      	and	AL, #-4
    78da:	8402      	or	AL, #2
    78dc:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

000078e0 <.LM68>:
    78e0:	6007      	lod	AL, #7
    78e2:	42d8 016c 	mov	0x16c <.LASF1177+0x3>, AL

000078e6 <.LM69>:
    78e6:	72ef      	lod	A, S
    78e8:	a0e2      	add	A, #-30

000078ea <.LVL26>:
    78ea:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

000078ee <.LM70>:
    78ee:	72da 08d8 	lod	A, #2264

000078f2 <.LVL27>:
    78f2:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

000078f6 <.LBE601>:
    78f6:	0ea7      	lod	C, ML.7
    78f8:	7003      	lod	A, #3
    78fa:	1711      	call	0x771e <_adc_DoSoftwareTrigger>

000078fc <.LM72>:
    78fc:	7a01      	lod	Y, [S-2]
    78fe:	72e6      	lod	A, Y
    7900:	170e      	call	0x771e <_adc_DoSoftwareTrigger>

00007902 <.LM73>:
    7902:	7215      	lod	A, [S-22]
    7904:	7e13      	lod	X, [S-20]
    7906:	a2ee      	add	A, X
    7908:	a001      	add	A, #1
    790a:	4432      	lsr	A
    790c:	52d8 10ba 	mov	0x10ba <_i16MotorCurrentZeroOffset>, A

00007910 <.LM74>:
    7910:	541f      	ret	#32

00007912 <_adc_ConvertToCurrent>:
int16_t adc_ConvertToCurrent(uint16_t u16AdcVal)
{
    int16_t current;

    /* the current sensor current in mA units */
    current = conv_shunt_current(u16AdcVal); // Option-A
    7912:	0275      	jmp	0x7dfe <_conv_shunt_current>

00007914 <_adc_ConvertToTchip>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the temperature in 1 degC.
 */
int16_t adc_ConvertToTchip(uint16_t u16AdcVal)
{
    return CalculateTemperature3pLinearize(u16AdcVal);
    7914:	76da 5173 	jmpf	0xa2e6 <_CalculateTemperature3pLinearize>

00007918 <_adc_ConvertToVsupply>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the supply voltage in 10 mV.
 */
int16_t adc_ConvertToVsupply(uint16_t u16AdcVal)
{
    return conv_high_voltage_with_tcorrection(u16AdcVal, dBase[ADC_SAMPLE_TEMP]);
    7918:	7ed8 12ea 	lod	X, 0x12ea <_dBase+0x2>
    791c:	5edf      	push	X

0000791e <.LCFI5>:
    791e:	11e5      	call	0x7cea <_conv_high_voltage_with_tcorrection>

00007920 <.LCFI6>:
}
    7920:	5403      	ret	#4

00007922 <_adc_ConvertToVoltage>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    7922:	4822 0294 	mulu	YA, A, #660

00007926 <.LBE605>:
 */
int16_t adc_ConvertToVoltage(uint16_t u16AdcVal)
{
    int16_t i16Volt;

    i16Volt = (int16_t)(mulU32_U16byU16(u16AdcVal, 660u) / 1024u);
    7926:	48a9      	lsr	YA, #10

00007928 <.LM106>:

    return (i16Volt);
}
    7928:	5401      	ret

0000792a <__ADC_SAR_INT>:
/**
 * @brief ADC Interrupt Service Routine
 * In case no ADC_ISR action required, this ISR has 4us overhead
 */
__attribute__((interrupt)) void _ADC_SAR_INT(void)
{
    792a:	5edf      	push	X

0000792c <.LCFI9>:
    792c:	5adf      	push	Y

0000792e <.LCFI10>:
    792e:	52df      	push	A

00007930 <.LCFI11>:
    7930:	4c83      	push	D

00007932 <.LCFI12>:
    if (p16AdcIrq != NULL)
    7932:	72d8 10b8 	lod	A, 0x10b8 <_p16AdcIrq>
    7936:	1903      	je	0x793e <.L51>

00007938 <.LM109>:
    {
        p16AdcIrq();
    7938:	0001      	jmp	0x793c <.L57>

0000793a <.L56>:
    793a:	76e2      	jmp	A

0000793c <.L57>:
    793c:	17fe      	call	0x793a <.L56>

0000793e <.L51>:
    if (p16AdcIrq2 != NULL)
    {
        p16AdcIrq2();
    }
#endif
}
    793e:	4cc3      	pop	D

00007940 <.LCFI13>:
    7940:	72cf      	pop	A

00007942 <.LCFI14>:
    7942:	7acf      	pop	Y

00007944 <.LCFI15>:
    7944:	7ecf      	pop	X

00007946 <.LCFI16>:
    7946:	72cb      	pop	M
    7948:	5401      	ret

0000794a <_gmr_calibration_setup>:
	l16_SetGmrSensorOffset = (DEFAULT_GMR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR);
	l_au16MotorOffsetCurrent = 0;
}
void gmr_calibration_setup(void)
{
	l16_GmrCalEnable = 1;
    794a:	7801      	lod	Y, #1
    794c:	5ad8 10be 	mov	0x10be <_l16_GmrCalEnable>, Y

00007950 <.LM3>:
	l16_SinPosMaxPeak = 0;
    7950:	7c00      	lod	X, #0
    7952:	0ea7      	lod	C, ML.7
    7954:	5ed8 1312 	mov	0x1312 <_l16_SinPosMaxPeak>, X

00007958 <.LM4>:
	l16_SinPosMinPeak = 0x7fff;
    7958:	72da 7fff 	lod	A, #32767
    795c:	52d8 130c 	mov	0x130c <_l16_SinPosMinPeak>, A

00007960 <.LM5>:
	l16_SinNegMaxPeak = 0;
    7960:	0ea7      	lod	C, ML.7
    7962:	5ed8 130a 	mov	0x130a <_l16_SinNegMaxPeak>, X

00007966 <.LM6>:
	l16_SinNegMinPeak = 0x7fff;
    7966:	52d8 1316 	mov	0x1316 <_l16_SinNegMinPeak>, A

0000796a <.LM7>:
	l16_CosinPosMaxPeak = 0;
    796a:	5ed8 1310 	mov	0x1310 <_l16_CosinPosMaxPeak>, X

0000796e <.LM8>:
	l16_CosinPosMinPeak = 0x7fff;
    796e:	0ea7      	lod	C, ML.7
    7970:	52d8 130e 	mov	0x130e <_l16_CosinPosMinPeak>, A

00007974 <.LM9>:
	l16_CosinNegMaxPeak = 0;
    7974:	5ed8 1318 	mov	0x1318 <_l16_CosinNegMaxPeak>, X

00007978 <.LM10>:
	l16_CosinNegMinPeak = 0x7fff;
    7978:	52d8 1314 	mov	0x1314 <_l16_CosinNegMinPeak>, A

0000797c <.LM11>:
	l16_SinOutputOffset = 0xFFFF;
    797c:	0ea7      	lod	C, ML.7
    797e:	70ff      	lod	A, #-1
    7980:	52d8 131a 	mov	0x131a <_l16_SinOutputOffset>, A

00007984 <.LM12>:
	l16_CosinOutputOffset = 1;
    7984:	5ad8 131c 	mov	0x131c <_l16_CosinOutputOffset>, Y

00007988 <.LM13>:
}
    7988:	5401      	ret

0000798a <_sensor_init>:
int16_t l16_CosinNegMinPeak;
int16_t l16_SinOutputOffset;
int16_t l16_CosinOutputOffset;
int16_t l16_SetGmrSensorOffset = 0;
void sensor_init(void)
{
    798a:	5803      	inc	S, #4

0000798c <.LCFI0>:
    798c:	7eda 103a 	lod	X, #4154
    7990:	5e03      	mov	[S-4], X

00007992 <.LM15>:
	uint16_t num = 0, index = 0, initValue;

	for (num = 0; num < C_ADC_END_ITEM; num++)
    7992:	7000      	lod	A, #0
    7994:	5201      	mov	[S-2], A

00007996 <.LM16>:
	{
		if (num == C_ADC_VS_)
			initValue = 0xFF;
    7996:	72da 00ff 	lod	A, #255

0000799a <.L3>:
    799a:	7e03      	lod	X, [S-4]
    799c:	7afc      	lod	Y, [X+4]
    799e:	7c08      	lod	X, #8

000079a0 <.L5>:
		else
			initValue = 0;
		l_sAdcAvgObject[num].u32MovAvgxN = 0;
		for (index = 0; index < 8; index++)
		{
			l_sAdcAvgObject[num].pu16Raw[index] = initValue;
    79a0:	52d6      	mov	[Y++], A

000079a2 <.LM18>:
		else if (num == C_ADC_TEMP_)
			initValue = 0x260;
		else
			initValue = 0;
		l_sAdcAvgObject[num].u32MovAvgxN = 0;
		for (index = 0; index < 8; index++)
    79a2:	1bfe      	djnz	X, 0x79a0 <.L5>
    79a4:	4cf2      	usex	YA

000079a6 <.LVL3>:
    79a6:	48e2      	asl	YA, #3
    79a8:	7e03      	lod	X, [S-4]
    79aa:	4ca7      	mov	[X], YA

000079ac <.LM19>:
int16_t l16_SetGmrSensorOffset = 0;
void sensor_init(void)
{
	uint16_t num = 0, index = 0, initValue;

	for (num = 0; num < C_ADC_END_ITEM; num++)
    79ac:	7201      	lod	A, [S-2]
    79ae:	a001      	add	A, #1

000079b0 <.LVL5>:
    79b0:	5201      	mov	[S-2], A
    79b2:	ac09      	cmp	A, #9
    79b4:	1d06      	jne	0x79c2 <.L6>

000079b6 <.LM20>:
		{
			l_sAdcAvgObject[num].pu16Raw[index] = initValue;
			l_sAdcAvgObject[num].u32MovAvgxN += initValue;
		}
	}
	gmr_calibration_setup();
    79b6:	17c9      	call	0x794a <_gmr_calibration_setup>

000079b8 <.LM21>:
	//	l16_SetGmrSensorOffset=C_GMR_SENSOR_OFFSET*C_GMR_ANGLE_SCALE_FACTOR;
	l16_SetGmrSensorOffset = (DEFAULT_GMR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR);
    79b8:	72da 0456 	lod	A, #1110
    79bc:	52d8 10bc 	mov	0x10bc <_l16_SetGmrSensorOffset>, A

000079c0 <.LM22>:
	l_au16MotorOffsetCurrent = 0;
}
    79c0:	5405      	ret	#6

000079c2 <.L6>:

	for (num = 0; num < C_ADC_END_ITEM; num++)
	{
		if (num == C_ADC_VS_)
			initValue = 0xFF;
		else if (num == C_ADC_TEMP_)
    79c2:	7e01      	lod	X, [S-2]
    79c4:	2c01      	cmp	X, #1
    79c6:	1d06      	jne	0x79d4 <.L7>

000079c8 <.LM24>:
			initValue = 0x260;
    79c8:	72da 0260 	lod	A, #608

000079cc <.L4>:
    79cc:	7e03      	lod	X, [S-4]
    79ce:	200c      	add	X, #12
    79d0:	5e03      	mov	[S-4], X
    79d2:	07e3      	jmp	0x799a <.L3>

000079d4 <.L7>:
		else
			initValue = 0;
    79d4:	7000      	lod	A, #0
    79d6:	07fa      	jmp	0x79cc <.L4>

000079d8 <_set_gmr_sensor_offset>:
void gmr_calibration_end(void)
{
}
void set_gmr_sensor_offset(int16_t offset)
{
	l16_SetGmrSensorOffset = offset;
    79d8:	52d8 10bc 	mov	0x10bc <_l16_SetGmrSensorOffset>, A

000079dc <.LM30>:
}
    79dc:	5401      	ret

000079de <_get_gmr_sensor_offset>:
int16_t get_gmr_sensor_offset(void)
{
	return l16_SetGmrSensorOffset;
}
    79de:	72d8 10bc 	lod	A, 0x10bc <_l16_SetGmrSensorOffset>
    79e2:	5401      	ret

000079e4 <_adc_raw_update>:
void adc_raw_update(void)
{
    79e4:	5801      	inc	S, #2

000079e6 <.LCFI1>:
	uint16_t index = 0;

	for (index = 0; index < C_ADC_END_ITEM; index++)
    79e6:	7000      	lod	A, #0
    79e8:	5201      	mov	[S-2], A

000079ea <.L25>:
	{
		switch (index)
    79ea:	7201      	lod	A, [S-2]
    79ec:	a0ff      	add	A, #-1
    79ee:	ac07      	cmp	A, #7
    79f0:	1e05      	jug	0x79fc <.L13>
    79f2:	4422      	asl	A
    79f4:	7ee2      	lod	X, A
    79f6:	22da 5d06 	add	X, #23814
    79fa:	76f8      	jmp	[X]

000079fc <.L13>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    79fc:	72d8 12f2 	lod	A, 0x12f2 <_dBase+0xa>

00007a00 <.LBE38>:
		{
		case C_ADC_VS_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VS_], adc_GetRawVs());
    7a00:	52df      	push	A

00007a02 <.LCFI2>:
    7a02:	72da 1038 	lod	A, #4152

00007a06 <.L28>:
		case C_ADC_SENSOR_3:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_3], adc_Get_GMR_pCosine());
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_4:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_4], adc_Get_GMR_pSine());
    7a06:	82db 4505 	callf	0x8a0a <_FILTER_AVG_CalcMovAvg>

00007a0a <.LM39>:
}
void adc_raw_update(void)
{
	uint16_t index = 0;

	for (index = 0; index < C_ADC_END_ITEM; index++)
    7a0a:	7203      	lod	A, [S-4]
    7a0c:	5c01      	dec	S, #2

00007a0e <.LCFI3>:
    7a0e:	a001      	add	A, #1
    7a10:	5201      	mov	[S-2], A
    7a12:	ac09      	cmp	A, #9
    7a14:	1d6a      	jne	0x79ea <.L25>

00007a16 <.LM40>:
			break;
		default:
			break;
		}
	}
}
    7a16:	5403      	ret	#4

00007a18 <.L14>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    7a18:	72d8 12ea 	lod	A, 0x12ea <_dBase+0x2>

00007a1c <.LBE40>:
		case C_ADC_VS_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VS_], adc_GetRawVs());
			//						temp = l_sAdcAvgObject[C_ADC_VS_].u16MovAvg;
			break;
		case C_ADC_TEMP_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_TEMP_], adc_GetRawTemperature());
    7a1c:	52df      	push	A

00007a1e <.LCFI4>:
    7a1e:	72da 1044 	lod	A, #4164
    7a22:	07f1      	jmp	0x7a06 <.L28>

00007a24 <.L16>:
 */
static INLINE uint16_t adc_GetRawCurrent(void)
{
    extern volatile uint16_t dBase[];
    extern int16_t i16MotorCurrentZeroOffset;
    int16_t i16MotorCurrent = ((dBase[ADC_SAMPLE_CURR] + dBase[ADC_SAMPLE_CURR_2]) >> 1);
    7a24:	72d8 12ec 	lod	A, 0x12ec <_dBase+0x4>
    7a28:	7ed8 12f8 	lod	X, 0x12f8 <_dBase+0x10>
    7a2c:	a2ee      	add	A, X
    7a2e:	4432      	lsr	A

00007a30 <.LM44>:
    if (i16MotorCurrent >= i16MotorCurrentZeroOffset)
    7a30:	7ed8 10ba 	lod	X, 0x10ba <_i16MotorCurrentZeroOffset>
    7a34:	aeee      	cmp	A, X
    7a36:	1a85      	jsl	0x7a42 <.L26>

00007a38 <.LM45>:
    {
        i16MotorCurrent -= i16MotorCurrentZeroOffset;
    7a38:	aaee      	sub	A, X

00007a3a <.L24>:
			//						temp = l_sAdcAvgObject[C_ADC_TEMP_].u16MovAvg;
			break;
		case C_ADC_CURRENT_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_CURRENT_], adc_GetRawCurrent());
    7a3a:	52df      	push	A

00007a3c <.LCFI6>:
    7a3c:	72da 1050 	lod	A, #4176
    7a40:	07e2      	jmp	0x7a06 <.L28>

00007a42 <.L26>:
    }
    else
    {
        i16MotorCurrent = 0;
    7a42:	7000      	lod	A, #0

00007a44 <.LVL22>:
    7a44:	07fa      	jmp	0x7a3a <.L24>

00007a46 <.L17>:
 * @returns  raw VDDA voltage sample.
 */
static INLINE uint16_t adc_GetRawVdda(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VDDA];
    7a46:	72d8 12ee 	lod	A, 0x12ee <_dBase+0x6>

00007a4a <.LBE46>:
			//						temp = l_sAdcAvgObject[C_ADC_CURRENT_].u16MovAvg;
			break;
		case C_ADC_VDDA:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VDDA], adc_GetRawVdda());
    7a4a:	52df      	push	A

00007a4c <.LCFI8>:
    7a4c:	72da 105c 	lod	A, #4188
    7a50:	07da      	jmp	0x7a06 <.L28>

00007a52 <.L18>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_GetRawIGN(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_IGN];
    7a52:	72d8 12f0 	lod	A, 0x12f0 <_dBase+0x8>

00007a56 <.LBE48>:
			//						temp = l_sAdcAvgObject[C_ADC_VDDA].u16MovAvg;
			break;
		case C_ADC_IGN:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_IGN], adc_GetRawIGN());
    7a56:	52df      	push	A

00007a58 <.LCFI10>:
    7a58:	72da 1068 	lod	A, #4200
    7a5c:	07d4      	jmp	0x7a06 <.L28>

00007a5e <.L19>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_nCosine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO1];
    7a5e:	72d8 12f4 	lod	A, 0x12f4 <_dBase+0xc>

00007a62 <.LBE50>:
			//						temp = l_sAdcAvgObject[C_ADC_VREF_].u16MovAvg;
			break;
		case C_ADC_SENSOR_1:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_1], adc_Get_GMR_nCosine());
    7a62:	52df      	push	A

00007a64 <.LCFI12>:
    7a64:	72da 1074 	lod	A, #4212
    7a68:	07ce      	jmp	0x7a06 <.L28>

00007a6a <.L20>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_nSine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO2];
    7a6a:	72d8 12f6 	lod	A, 0x12f6 <_dBase+0xe>

00007a6e <.LBE52>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_2:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_2], adc_Get_GMR_nSine());
    7a6e:	52df      	push	A

00007a70 <.LCFI14>:
    7a70:	72da 1080 	lod	A, #4224
    7a74:	07c8      	jmp	0x7a06 <.L28>

00007a76 <.L21>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_pCosine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO3];
    7a76:	72d8 12fa 	lod	A, 0x12fa <.LLST34>

00007a7a <.LBE54>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_3:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_3], adc_Get_GMR_pCosine());
    7a7a:	52df      	push	A

00007a7c <.LCFI16>:
    7a7c:	72da 108c 	lod	A, #4236
    7a80:	07c2      	jmp	0x7a06 <.L28>

00007a82 <.L22>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_pSine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO4];
    7a82:	72d8 12fc 	lod	A, 0x12fc <.LLST34+0x2>

00007a86 <.LBE56>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_4:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_4], adc_Get_GMR_pSine());
    7a86:	52df      	push	A

00007a88 <.LCFI18>:
    7a88:	72da 1098 	lod	A, #4248
    7a8c:	07bc      	jmp	0x7a06 <.L28>

00007a8e <_get_conv_vdda_voltage>:
{
	return (l_sAdcAvgObject[num].u16MovAvg);
}
uint16_t get_conv_vdda_voltage(void)
{
	return adc_ConvertToVoltage(get_sensor_raw_data(C_ADC_VDDA));
    7a8e:	72d8 105c 	lod	A, 0x105c <.LLST11+0x11>
    7a92:	0747      	jmp	0x7922 <_adc_ConvertToVoltage>

00007a94 <_get_conv_supply_voltage>:
}
uint16_t get_conv_supply_voltage(void)
{
	return adc_ConvertToVsupply(get_sensor_raw_data(C_ADC_VS_));
    7a94:	72d8 1038 	lod	A, 0x1038 <_l_sAdcAvgObject>
    7a98:	073f      	jmp	0x7918 <_adc_ConvertToVsupply>

00007a9a <_get_conv_ic_temperature>:
int16_t get_conv_ic_temperature(void)
{
#if 0
	return adc_ConvertToTchip(get_sensor_raw_data(C_ADC_TEMP_));
#else
	int16_t temperature = adc_ConvertToTchip(get_sensor_raw_data(C_ADC_TEMP_));
    7a9a:	72d8 1044 	lod	A, 0x1044 <_l_sAdcAvgObject+0xc>
    7a9e:	173a      	call	0x7914 <_adc_ConvertToTchip>

00007aa0 <.LM71>:
	if (temperature >= 0)
    7aa0:	ac00      	cmp	A, #0
    7aa2:	1a82      	jsl	0x7aa8 <.L33>

00007aa4 <.L36>:
		{
			temperature = 0;
		}
		else
		{
			temperature = (C_TEMP_CONV_OFFSET + temperature);
    7aa4:	a028      	add	A, #40
    7aa6:	5401      	ret

00007aa8 <.L33>:
	{
		temperature += C_TEMP_CONV_OFFSET;
	}
	else
	{
		if (temperature < (-40))
    7aa8:	acd8      	cmp	A, #-40
    7aaa:	1efc      	jsge	0x7aa4 <.L36>

00007aac <.LM74>:
		{
			temperature = 0;
    7aac:	7000      	lod	A, #0

00007aae <.LM75>:
		}
	}

	return temperature;
#endif
}
    7aae:	5401      	ret

00007ab0 <_get_conv_mot_current>:
uint16_t get_conv_mot_current(void)
{
	return adc_ConvertToCurrent(get_sensor_raw_data(C_ADC_CURRENT_));
    7ab0:	72d8 1050 	lod	A, 0x1050 <.LLST11+0x5>
    7ab4:	072e      	jmp	0x7912 <_adc_ConvertToCurrent>

00007ab6 <_get_gmr_sine_output>:
	int16_t cal, offset = C_GMR_OUTPUT_OFFSET;
	int16_t pSin, nSin;
	pSin = get_sensor_raw_data(C_ADC_SENSOR_4) - offset;
	nSin = get_sensor_raw_data(C_ADC_SENSOR_2) - offset;

	cal = pSin - nSin;
    7ab6:	72d8 1098 	lod	A, 0x1098 <.LASF1487>
    7aba:	aad8 1080 	sub	A, 0x1080 <.LLST12+0x1>

00007abe <.LM81>:
if (cal<l16_SinNegMaxPeak)
{
l16_SinNegMaxPeak=cal;
}
#endif
	cal = cal - l16_SinOutputOffset;
    7abe:	aad8 131a 	sub	A, 0x131a <_l16_SinOutputOffset>

00007ac2 <.LVL44>:
    7ac2:	0ea7      	lod	C, ML.7
    7ac4:	aeda c001 	cmp	A, #49153
    7ac8:	1e82      	jsge	0x7ace <.L39>
    7aca:	72da c001 	lod	A, #49153

00007ace <.L39>:
		cal = C_GMR_NEGAITIVE_MAX;
	}
	else
	{
	}
	return (cal);
    7ace:	aeda 3fff 	cmp	A, #16383
    7ad2:	1b02      	jsle	0x7ad8 <.L40>
    7ad4:	72da 3fff 	lod	A, #16383

00007ad8 <.L40>:
}
    7ad8:	5401      	ret

00007ada <_get_gmr_cosine_output>:
	int16_t cal, offset = C_GMR_OUTPUT_OFFSET;
	int16_t pCosin, nCosin;
	pCosin = get_sensor_raw_data(C_ADC_SENSOR_3) - offset;
	nCosin = get_sensor_raw_data(C_ADC_SENSOR_1) - offset;

	cal = pCosin - nCosin;
    7ada:	72d8 108c 	lod	A, 0x108c <.LLST12+0xd>
    7ade:	aad8 1074 	sub	A, 0x1074 <.Lframe0+0x10>

00007ae2 <.LM86>:
if (cal<l16_CosinNegMaxPeak)
{
l16_CosinNegMaxPeak=cal;
}
#endif
	cal = cal - l16_CosinOutputOffset;
    7ae2:	aad8 131c 	sub	A, 0x131c <_l16_CosinOutputOffset>

00007ae6 <.LVL49>:
    7ae6:	0ea7      	lod	C, ML.7
    7ae8:	aeda c001 	cmp	A, #49153
    7aec:	1e82      	jsge	0x7af2 <.L42>
    7aee:	72da c001 	lod	A, #49153

00007af2 <.L42>:
		cal = C_GMR_NEGAITIVE_MAX;
	}
	else
	{
	}
	return (cal);
    7af2:	aeda 3fff 	cmp	A, #16383
    7af6:	1b02      	jsle	0x7afc <.L43>
    7af8:	72da 3fff 	lod	A, #16383

00007afc <.L43>:
}
    7afc:	5401      	ret

00007afe <_calculate_gmr_angle>:
/* ELMOS
u16 loc_rotor_angle_estimated = math_get_angle_unsafe( loc_e_beta_filtered, loc_e_alpha_filtered );
*/

int16_t calculate_gmr_angle(void)
{
    7afe:	5801      	inc	S, #2

00007b00 <.LCFI19>:
	int16_t ang_result;

	ang_result = (int16_t)atan2I16(get_gmr_cosine_output(), get_gmr_sine_output());
    7b00:	17da      	call	0x7ab6 <_get_gmr_sine_output>
    7b02:	5201      	mov	[S-2], A
    7b04:	17ea      	call	0x7ada <_get_gmr_cosine_output>
    7b06:	7a01      	lod	Y, [S-2]
    7b08:	5adf      	push	Y

00007b0a <.LCFI20>:
    7b0a:	82db 5233 	callf	0xa466 <_atan2I16>

00007b0e <.LBB60>:
}
/* 0~0xFFFF -> 0~360*10*/
static uint16_t MLX_to_GMR_conv(uint16_t angle)
{
	uint16_t cal, offset;
	if (angle < 0x2000) /* 45*/
    7b0e:	5c01      	dec	S, #2

00007b10 <.LCFI21>:
    7b10:	aeda 1fff 	cmp	A, #8191
    7b14:	1e01      	jug	0x7b18 <.LM92>
    7b16:	0049      	jmp	0x7baa <.L54>

00007b18 <.LM92>:
	{
		offset = 0;
	}
	else if (angle < 0x4000) /* 90*/
    7b18:	aeda 3fff 	cmp	A, #16383
    7b1c:	1e1a      	jug	0x7b52 <.L46>

00007b1e <.LM93>:
	{
		angle -= 0x2000;
    7b1e:	a2da e000 	add	A, #57344

00007b22 <.LM94>:
		offset = 450;
    7b22:	7eda 01c2 	lod	X, #450

00007b26 <.L45>:
	else /* 360*/
	{
		angle -= 0xE000;
		offset = 3150;
	}
	angle = (angle >> 6); /* div 64 */
    7b26:	44b2      	lsr	A, #2
    7b28:	44b2      	lsr	A, #2
    7b2a:	44b2      	lsr	A, #2

00007b2c <.LM96>:
	cal = (450 * angle) >> 7;
    7b2c:	4872 01c2 	muls	A, A, #450

00007b30 <.LVL58>:
    7b30:	4442      	rl	A
    7b32:	9401      	and	AL, #1
    7b34:	72e4      	swap	A

00007b36 <.LM97>:
	cal += offset;
    7b36:	a2ee      	add	A, X

00007b38 <.LM98>:
	if (cal >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    7b38:	aeda 0e0f 	cmp	A, #3599
    7b3c:	1a02      	jule	0x7b42 <.L52>

00007b3e <.LM99>:
	{
		cal -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7b3e:	a2da f1f0 	add	A, #61936

00007b42 <.L52>:
	}

	cal += l16_SetGmrSensorOffset;
    7b42:	a2d8 10bc 	add	A, 0x10bc <_l16_SetGmrSensorOffset>

00007b46 <.LM101>:
	if (cal >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    7b46:	aeda 0e0f 	cmp	A, #3599
    7b4a:	1a02      	jule	0x7b50 <.L53>

00007b4c <.LM102>:
	{
		cal -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7b4c:	a2da f1f0 	add	A, #61936

00007b50 <.L53>:

	/* output angle(0~0xFFFF) -> 0~360 degree */
	ang_result = MLX_to_GMR_conv(ang_result);

	return ang_result;
}
    7b50:	5403      	ret	#4

00007b52 <.L46>:
	else if (angle < 0x4000) /* 90*/
	{
		angle -= 0x2000;
		offset = 450;
	}
	else if (angle < 0x6000) /* 135*/
    7b52:	aeda 5fff 	cmp	A, #24575
    7b56:	1e05      	jug	0x7b62 <.L47>

00007b58 <.LM105>:
	{
		angle -= 0x4000;
    7b58:	a2da c000 	add	A, #49152

00007b5c <.LM106>:
		offset = 900;
    7b5c:	7eda 0384 	lod	X, #900
    7b60:	07e2      	jmp	0x7b26 <.L45>

00007b62 <.L47>:
	}
	else if (angle < 0x8000) /* 180*/
    7b62:	ac00      	cmp	A, #0
    7b64:	1a85      	jsl	0x7b70 <.L48>

00007b66 <.LM108>:
	{
		angle -= 0x6000;
    7b66:	a2da a000 	add	A, #40960

00007b6a <.LM109>:
		offset = 1350;
    7b6a:	7eda 0546 	lod	X, #1350
    7b6e:	07db      	jmp	0x7b26 <.L45>

00007b70 <.L48>:
	}
	else if (angle < 0xA000) /* 225*/
    7b70:	aeda 9fff 	cmp	A, #40959
    7b74:	1e05      	jug	0x7b80 <.L49>

00007b76 <.LM111>:
	{
		angle -= 0x8000;
    7b76:	a2da 8000 	add	A, #32768

00007b7a <.LM112>:
		offset = 1800;
    7b7a:	7eda 0708 	lod	X, #1800
    7b7e:	07d3      	jmp	0x7b26 <.L45>

00007b80 <.L49>:
	}
	else if (angle < 0xC000) /* 270*/
    7b80:	aeda bfff 	cmp	A, #49151
    7b84:	1e05      	jug	0x7b90 <.L50>

00007b86 <.LM114>:
	{
		angle -= 0xA000;
    7b86:	a2da 6000 	add	A, #24576

00007b8a <.LM115>:
		offset = 2250;
    7b8a:	7eda 08ca 	lod	X, #2250
    7b8e:	07cb      	jmp	0x7b26 <.L45>

00007b90 <.L50>:
	}
	else if (angle < 0xE000) /* 315*/
    7b90:	aeda dfff 	cmp	A, #57343
    7b94:	1e05      	jug	0x7ba0 <.L51>

00007b96 <.LM117>:
	{
		angle -= 0xC000;
    7b96:	a2da 4000 	add	A, #16384

00007b9a <.LM118>:
		offset = 2700;
    7b9a:	7eda 0a8c 	lod	X, #2700
    7b9e:	07c3      	jmp	0x7b26 <.L45>

00007ba0 <.L51>:
	}
	else /* 360*/
	{
		angle -= 0xE000;
    7ba0:	a2da 2000 	add	A, #8192

00007ba4 <.LM120>:
		offset = 3150;
    7ba4:	7eda 0c4e 	lod	X, #3150
    7ba8:	07be      	jmp	0x7b26 <.L45>

00007baa <.L54>:
static uint16_t MLX_to_GMR_conv(uint16_t angle)
{
	uint16_t cal, offset;
	if (angle < 0x2000) /* 45*/
	{
		offset = 0;
    7baa:	7c00      	lod	X, #0
    7bac:	07bc      	jmp	0x7b26 <.L45>

00007bae <_forward_linear_Interpolation>:

	return ang_result;
}

int16_t forward_linear_Interpolation(int16_t x, int16_t x0, int16_t x1, int16_t y0, int16_t y1)
{
    7bae:	7ae2      	lod	Y, A

00007bb0 <.LM123>:
    7bb0:	7e07      	lod	X, [S-8]
    7bb2:	7209      	lod	A, [S-10]

00007bb4 <.LM124>:
	int16_t tmp = 0;
	int16_t retVal = 0;

	tmp = (int16_t)(y1 - y0) * (int16_t)(x - x0);
    7bb4:	aaee      	sub	A, X

00007bb6 <.LM125>:

	return ang_result;
}

int16_t forward_linear_Interpolation(int16_t x, int16_t x0, int16_t x1, int16_t y0, int16_t y1)
{
    7bb6:	7e03      	lod	X, [S-4]

00007bb8 <.LM126>:
	int16_t tmp = 0;
	int16_t retVal = 0;

	tmp = (int16_t)(y1 - y0) * (int16_t)(x - x0);
    7bb8:	eaee      	sub	Y, X

00007bba <.LVL80>:
    7bba:	4871      	muls	A, A, Y

00007bbc <.LM127>:

	if ((x1 - x0) != 0)
    7bbc:	2e05      	cmp	X, [S-6]
    7bbe:	1906      	je	0x7bcc <.L56>

00007bc0 <.LM128>:
	{
		tmp /= (int16_t)(x1 - x0);
    7bc0:	7e05      	lod	X, [S-6]
    7bc2:	2a03      	sub	X, [S-4]
    7bc4:	4cf8      	movs	YA, A
    7bc6:	4c73      	divs	YA, X
    7bc8:	4c73      	divs	YA, X
    7bca:	4c7b      	dadjs	YA, X

00007bcc <.L56>:
    7bcc:	7e07      	lod	X, [S-8]

00007bce <.LM129>:
	}

	tmp += (int16_t)y0;
    7bce:	a2ee      	add	A, X

00007bd0 <.LM130>:

	retVal = tmp;

	return retVal;
}
    7bd0:	5401      	ret

00007bd2 <_get_conv_ignition_voltage>:
	{0x15B, 900u},	// 1
	{0x178, 1200u}, // 2
	{0x19B, 1800u}	// 3
};
uint16_t get_conv_ignition_voltage(void)
{
    7bd2:	5803      	inc	S, #4

00007bd4 <.LBB64>:
	}
}

int16_t get_sensor_raw_data(uint16_t num)
{
	return (l_sAdcAvgObject[num].u16MovAvg);
    7bd4:	7ad8 1068 	lod	Y, 0x1068 <.Lframe0+0x4>

00007bd8 <.LBE64>:
uint16_t get_conv_ignition_voltage(void)
{
	uint16_t volt = get_sensor_raw_data(C_ADC_IGN);
	uint16_t cal_result = 0, index;

	if (volt < IGNconversionMap[0].actual)
    7bd8:	eeda 0131 	cmp	Y, #305
    7bdc:	1a27      	jule	0x7c2c <.L60>

00007bde <.LM134>:
	{
		cal_result = 0;
	}
	else if (volt > IGNconversionMap[3].actual)
    7bde:	eeda 019b 	cmp	Y, #411
    7be2:	1e26      	jug	0x7c30 <.L61>

00007be4 <.LM135>:
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
		{
			if (volt <= IGNconversionMap[index + 1U].actual)
    7be4:	eeda 015b 	cmp	Y, #347
    7be8:	1a1f      	jule	0x7c28 <.L62>
    7bea:	eeda 0178 	cmp	Y, #376
    7bee:	5cb0      	sug	A
    7bf0:	a001      	add	A, #1

00007bf2 <.L64>:
	{
		cal_result = 1800u;
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
    7bf2:	5203      	mov	[S-4], A

00007bf4 <.LM137>:
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
    7bf4:	44a2      	asl	A, #2
    7bf6:	4422      	asl	A
    7bf8:	7ee2      	lod	X, A
    7bfa:	22da 5d1e 	add	X, #23838
    7bfe:	5e01      	mov	[S-2], X

00007c00 <.LM138>:
			if (volt <= IGNconversionMap[index + 1U].actual)
			{
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
    7c00:	72fc      	lod	A, [X+4]
    7c02:	52df      	push	A

00007c04 <.LCFI23>:
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
    7c04:	7205      	lod	A, [S-6]
    7c06:	44a2      	asl	A, #2
    7c08:	4422      	asl	A
    7c0a:	a2da 5d16 	add	A, #23830
    7c0e:	5205      	mov	[S-6], A

00007c10 <.LM140>:
			if (volt <= IGNconversionMap[index + 1U].actual)
			{
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
    7c10:	7ee2      	lod	X, A
    7c12:	72fc      	lod	A, [X+4]
    7c14:	52df      	push	A

00007c16 <.LCFI24>:
    7c16:	7e05      	lod	X, [S-6]
    7c18:	72f8      	lod	A, [X]
    7c1a:	52df      	push	A

00007c1c <.LCFI25>:
    7c1c:	7e09      	lod	X, [S-10]
    7c1e:	72f8      	lod	A, [X]
    7c20:	52df      	push	A

00007c22 <.LCFI26>:
    7c22:	72e6      	lod	A, Y
    7c24:	17c4      	call	0x7bae <_forward_linear_Interpolation>

00007c26 <.LCFI27>:
    7c26:	540d      	ret	#14

00007c28 <.L62>:
	{
		cal_result = 1800u;
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
    7c28:	7000      	lod	A, #0
    7c2a:	07e3      	jmp	0x7bf2 <.L64>

00007c2c <.L60>:
	uint16_t volt = get_sensor_raw_data(C_ADC_IGN);
	uint16_t cal_result = 0, index;

	if (volt < IGNconversionMap[0].actual)
	{
		cal_result = 0;
    7c2c:	7000      	lod	A, #0
    7c2e:	5405      	ret	#6

00007c30 <.L61>:
	}
	else if (volt > IGNconversionMap[3].actual)
	{
		cal_result = 1800u;
    7c30:	72da 0708 	lod	A, #1800

00007c34 <.LM144>:
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
	}

	return (cal_result);
}
    7c34:	5405      	ret	#6

00007c36 <_conv_clock_error_init>:
int16_t clock_error_SClockHighCal;  /**< CPU clock gain for high temperature range */
int16_t clock_error_OClockCal;  /**< CPU clock offset */

void conv_clock_error_init(void)
{
    clock_error_OTempCal = EE_GET(OTEMPCAL);
    7c36:	72d8 09b4 	lod	A, 0x9b4 <.LASF1595+0x5>
    7c3a:	52d8 131e 	mov	0x131e <_clock_error_OTempCal>, A

00007c3e <.LM3>:

    #if (FPLL == 32000) || (FPLL == 16000)
    clock_error_SClockLowCal = EE_GET(SCLOCK32LOWCAL);
    7c3e:	72d8 09c4 	lod	A, 0x9c4 <.Lframe0>
    7c42:	66e0      	lod	YL, AL
    7c44:	5ce6      	ssex	Y
    7c46:	5ad8 1322 	mov	0x1322 <_clock_error_SClockLowCal>, Y

00007c4a <.LM4>:
    clock_error_SClockHighCal = EE_GET(SCLOCK32HIGHCAL);
    7c4a:	62e4      	lod	AL, AH
    7c4c:	5ce2      	ssex	A
    7c4e:	52d8 1324 	mov	0x1324 <_clock_error_SClockHighCal>, A

00007c52 <.LM5>:
    clock_error_OClockCal = EE_GET(OCLOCK32CAL);
    7c52:	62d8 09c6 	lod	AL, 0x9c6 <.Lframe0+0x2>
    7c56:	5ce2      	ssex	A
    7c58:	52d8 1320 	mov	0x1320 <_clock_error_OClockCal>, A

00007c5c <.LM6>:
    #else
    clock_error_SClockLowCal = 0;
    clock_error_SClockHighCal = 0;
    clock_error_OClockCal = 0;
    #endif
}
    7c5c:	5401      	ret

00007c5e <_conv_clock_error_speed>:
int16_t conv_clock_error_speed(uint16_t raw_temperature)
{
    int16_t temp;
    int16_t gain;

    temp = (int16_t)raw_temperature - clock_error_OTempCal;
    7c5e:	aad8 131e 	sub	A, 0x131e <_clock_error_OTempCal>

00007c62 <.LM9>:

    if (temp > 0)
    7c62:	ac00      	cmp	A, #0
    7c64:	1b0f      	jsle	0x7c84 <.L3>

00007c66 <.LM10>:
    {
        gain = clock_error_SClockLowCal;
    7c66:	7ed8 1322 	lod	X, 0x1322 <_clock_error_SClockLowCal>

00007c6a <.L4>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    7c6a:	4833      	muls	YA, A, X

00007c6c <.LBE6>:
    else
    {
        gain = clock_error_SClockHighCal;
    }

    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
    7c6c:	4cb2 0000 	cmp	YA, #0
    7c70:	0000 
    7c72:	1e84      	jsge	0x7c7c <.L5>
    7c74:	4cc0      	mov	D, YA
    7c76:	4c0a 003f 	addu	D, #63
    7c7a:	4c80      	mov	YA, D

00007c7c <.L5>:
    7c7c:	48b5      	asr	YA, #6
    7c7e:	a2d8 1320 	add	A, 0x1320 <_clock_error_OClockCal>

00007c82 <.LM13>:
}
    7c82:	5401      	ret

00007c84 <.L3>:
    {
        gain = clock_error_SClockLowCal;
    }
    else
    {
        gain = clock_error_SClockHighCal;
    7c84:	7ed8 1324 	lod	X, 0x1324 <_clock_error_SClockHighCal>

00007c88 <.LVL5>:
    7c88:	07f0      	jmp	0x7c6a <.L4>

00007c8a <_conv_clock_error_correct_period>:
    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
}

uint16_t conv_clock_error_correct_period(uint16_t period, int16_t clock_error)
{
    int16_t temp = 2048 + clock_error;
    7c8a:	7e03      	lod	X, [S-4]
    7c8c:	22da 0800 	add	X, #2048

00007c90 <.LBB8>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    7c90:	4823      	mulu	YA, A, X

00007c92 <.LBE8>:
    return (uint16_t)(mulU32_U16byU16(period, (uint16_t)temp) / 2048u);
    7c92:	48aa      	lsr	YA, #11

00007c94 <.LM19>:
}
    7c94:	5401      	ret

00007c96 <_conv_high_voltage_init>:
calib_data_t calib_hvi;

void conv_high_voltage_init(void)
{
#if defined(EE_O_HVI_GET)
    calib_hvi.simple.offset = EE_GET(O_HVI);
    7c96:	72d8 09d4 	lod	A, 0x9d4 <.LLST18+0x4>
    7c9a:	62e4      	lod	AL, AH
    7c9c:	5ce2      	ssex	A
    7c9e:	52d8 1326 	mov	0x1326 <_calib_hvi>, A
    7ca2:	72d8 09d8 	lod	A, 0x9d8 <.LLST18+0x8>
    7ca6:	d400      	and	AH, #0

00007ca8 <.LM3>:
    calib_hvi.simple.gain = EE_GET(GAIN_HVI);
    7ca8:	52d8 1328 	mov	0x1328 <_calib_hvi+0x2>, A

00007cac <.LM4>:
    calib_hvi.gain_low_t = EE_GET(GAINLO_VSMF);
    7cac:	7ad8 09e2 	lod	Y, 0x9e2 <.LASF1599+0x9>
    7cb0:	46d8 132a 	mov	0x132a <_calib_hvi+0x4>, YL

00007cb4 <.LM5>:
    calib_hvi.gain_high_t = EE_GET(GAINHI_VSMF);
    7cb4:	0ea7      	lod	C, ML.7
    7cb6:	4ed8 2b13 	mov	0x132b <_calib_hvi+0x5>, YH

00007cba <.LM6>:
    calib_hvi.simple.gain = EE_GET(VS_GAIN);
    calib_hvi.gain_low_t = 0;
    calib_hvi.gain_high_t = 0;
#endif

    if (calib_hvi.simple.gain == 0u)
    7cba:	ac00      	cmp	A, #0
    7cbc:	1d04      	jne	0x7cc6 <.L1>

00007cbe <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_hvi.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7cbe:	72da 00a4 	lod	A, #164
    7cc2:	52d8 1328 	mov	0x1328 <_calib_hvi+0x2>, A

00007cc6 <.L1>:
    }
}
    7cc6:	5401      	ret

00007cc8 <_conv_high_voltage>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    7cc8:	aad8 1326 	sub	A, 0x1326 <_calib_hvi>

00007ccc <.LBB24>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7ccc:	7ed8 1328 	lod	X, 0x1328 <_calib_hvi+0x2>
    7cd0:	36da 00ff 	and	X, #255

00007cd4 <.LM12>:

    __asm__ __volatile__ (
    7cd4:	4833      	muls	YA, A, X

00007cd6 <.LBE24>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    7cd6:	4cb2 0000 	cmp	YA, #0
    7cda:	0000 
    7cdc:	1e84      	jsge	0x7ce6 <.L4>
    7cde:	4cc0      	mov	D, YA
    7ce0:	4c0a 001f 	addu	D, #31
    7ce4:	4c80      	mov	YA, D

00007ce6 <.L4>:
    7ce6:	48b4      	asr	YA, #5

00007ce8 <.LBE22>:

int16_t conv_high_voltage(uint16_t u16ADC_Value)
{
    /* cHVI = (mHVI - O_HVI_EE) * Gain_HVI_EE / 2^5 */
    return apply_offset_gain(u16ADC_Value, &calib_hvi.simple, HVI_GAIN_DIV);
}
    7ce8:	5401      	ret

00007cea <_conv_high_voltage_with_tcorrection>:

int16_t conv_high_voltage_with_tcorrection(uint16_t u16ADC_Value, uint16_t u16ADC_Temp)
{
    7cea:	5805      	inc	S, #6

00007cec <.LCFI0>:
     * }else{
     *     tempGain = ((GainHi_VSMF_EE / 2^11) * mTempDiff)/2^7;
     * }
     * cHVIcorr = cHVI * (1 + tempGain)
     */
    return apply_temp_gain(conv_high_voltage(u16ADC_Value), u16ADC_Temp, &calib_hvi);
    7cec:	17ed      	call	0x7cc8 <_conv_high_voltage>

00007cee <.LVL5>:
    7cee:	5205      	mov	[S-6], A

00007cf0 <.LBB26>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_temp_gain(uint16_t u16ADC_Value, uint16_t u16ADC_Temp, calib_data_t * cal_data)
{
    int16_t gain;
    int16_t temp_diff = (int16_t)(u16ADC_Temp - EE_GET(OTEMPCAL));
    7cf0:	7e09      	lod	X, [S-10]
    7cf2:	2ad8 09b4 	sub	X, 0x9b4 <.LASF1595+0x5>

00007cf6 <.LM18>:

    if (temp_diff > 0)
    7cf6:	2c00      	cmp	X, #0
    7cf8:	1b1b      	jsle	0x7d30 <.L6>

00007cfa <.LBB28>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7cfa:	66d8 132a 	lod	YL, 0x132a <_calib_hvi+0x4>

00007cfe <.L12>:
    7cfe:	5ce6      	ssex	Y

00007d00 <.LM20>:

    __asm__ __volatile__ (
    7d00:	72ee      	lod	A, X

00007d02 <.LVL10>:
    7d02:	4811      	muls	D, A, Y
    7d04:	5880      	mov	[S-4], D

00007d06 <.LBE30>:
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_low_t) / 128);
    }
    else
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_high_t) / 128);
    7d06:	4caa 0000 	cmpu	D, #0
    7d0a:	1e83      	jsge	0x7d12 <.L9>

00007d0c <.LVL11>:
    7d0c:	4c0a 007f 	addu	D, #127
    7d10:	5880      	mov	[S-4], D

00007d12 <.L9>:
    7d12:	58e0      	mov	YA, [S-4]

00007d14 <.LVL12>:
    7d14:	48b6      	asr	YA, #7

00007d16 <.LBB33>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    7d16:	7e05      	lod	X, [S-6]

00007d18 <.LVL14>:
    7d18:	4833      	muls	YA, A, X

00007d1a <.LBE33>:
    }

    return (u16ADC_Value + (mulI32_I16byI16(gain, u16ADC_Value) / 2048));
    7d1a:	4cb2 0000 	cmp	YA, #0
    7d1e:	0000 
    7d20:	1e84      	jsge	0x7d2a <.L10>
    7d22:	4cc0      	mov	D, YA
    7d24:	4c0a 07ff 	addu	D, #2047
    7d28:	4c80      	mov	YA, D

00007d2a <.L10>:
    7d2a:	48ba      	asr	YA, #11
    7d2c:	a205      	add	A, [S-6]

00007d2e <.LBE26>:
}
    7d2e:	5407      	ret	#8

00007d30 <.L6>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7d30:	66d8 132b 	lod	YL, 0x132b <_calib_hvi+0x5>
    7d34:	07e4      	jmp	0x7cfe <.L12>

00007d36 <_conv_low_voltage_init>:
calib_data_t calib_lvi;

void conv_low_voltage_init(void)
{
#if defined(EE_O_LVI_GET)
    calib_lvi.simple.offset = EE_GET(O_LVI);
    7d36:	72d8 09d6 	lod	A, 0x9d6 <.LLST18+0x6>
    7d3a:	7ee2      	lod	X, A
    7d3c:	54e4      	mov	Cx, #4
    7d3e:	44fe      	asr	X, #2
    7d40:	1ffe      	djnz	Cx, 0x7d3e <_conv_low_voltage_init+0x8>
    7d42:	5ed8 132c 	mov	0x132c <_calib_lvi>, X
    7d46:	d400      	and	AH, #0

00007d48 <.LM3>:
    calib_lvi.simple.gain = EE_GET(GAIN_LVI);
    7d48:	52d8 132e 	mov	0x132e <_calib_lvi+0x2>, A

00007d4c <.LM4>:
    calib_lvi.gain_low_t = EE_GET(GAINLO_LVI);
    7d4c:	7ad8 09da 	lod	Y, 0x9da <.LASF1599+0x1>
    7d50:	46d8 1330 	mov	0x1330 <_calib_lvi+0x4>, YL

00007d54 <.LM5>:
    calib_lvi.gain_high_t = EE_GET(GAINHI_LVI);
    7d54:	0ea7      	lod	C, ML.7
    7d56:	4ed8 3113 	mov	0x1331 <_calib_lvi+0x5>, YH

00007d5a <.LM6>:
    calib_lvi.simple.gain = 213u;                   /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    calib_lvi.gain_low_t = 0;
    calib_lvi.gain_high_t = 0;
#endif

    if (calib_lvi.simple.gain == 0u)
    7d5a:	ac00      	cmp	A, #0
    7d5c:	1d04      	jne	0x7d66 <.L1>

00007d5e <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_lvi.simple.gain = 213u;               /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    7d5e:	72da 00d5 	lod	A, #213
    7d62:	52d8 132e 	mov	0x132e <_calib_lvi+0x2>, A

00007d66 <.L1>:
    }
}
    7d66:	5401      	ret

00007d68 <_conv_motor_voltage_init>:
calib_data_t calib_vsm;
/** VSM filtered calibration data */
calib_data_t calib_vsmf;

void conv_motor_voltage_init(void)
{
    7d68:	5805      	inc	S, #6

00007d6a <.LCFI0>:
#if defined(EE_O_HVI_GET)
    calib_vsm.simple.offset = EE_GET(O_HVI);
    7d6a:	72d8 09d4 	lod	A, 0x9d4 <.LLST18+0x4>
    7d6e:	7ae2      	lod	Y, A
    7d70:	66ec      	lod	YL, YH
    7d72:	5ce6      	ssex	Y
    7d74:	5a03      	mov	[S-4], Y
    7d76:	5ad8 1338 	mov	0x1338 <_calib_vsm>, Y
    7d7a:	d400      	and	AH, #0

00007d7c <.LM3>:
    calib_vsm.simple.gain = EE_GET(GAIN_VSMF);
    7d7c:	52d8 133a 	mov	0x133a <_calib_vsm+0x2>, A

00007d80 <.LM4>:
    calib_vsm.gain_low_t = EE_GET(GAINLO_VSMF);
    7d80:	66d8 09e2 	lod	YL, 0x9e2 <.LASF1599+0x9>
    7d84:	5ce6      	ssex	Y
    7d86:	5a05      	mov	[S-6], Y
    7d88:	46d8 133c 	mov	0x133c <_calib_vsm+0x4>, YL

00007d8c <.LM5>:
    calib_vsm.gain_high_t = EE_GET(GAINHI_VSMF);
    7d8c:	7ad8 09e2 	lod	Y, 0x9e2 <.LASF1599+0x9>
    7d90:	66ec      	lod	YL, YH
    7d92:	5ce6      	ssex	Y
    7d94:	5a01      	mov	[S-2], Y
    7d96:	46d8 133d 	mov	0x133d <_calib_vsm+0x5>, YL

00007d9a <.LM6>:
    calib_vsm.simple.gain = EE_GET(VSM_GAIN);
    calib_vsm.gain_low_t = 0;
    calib_vsm.gain_high_t = 0;
#endif

    if (calib_vsm.simple.gain == 0u)
    7d9a:	ac00      	cmp	A, #0
    7d9c:	1d04      	jne	0x7da6 <.L2>

00007d9e <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsm.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7d9e:	7eda 00a4 	lod	X, #164
    7da2:	5ed8 133a 	mov	0x133a <_calib_vsm+0x2>, X

00007da6 <.L2>:
    }

#if defined(EE_O_HVI_GET)
    calib_vsmf.simple.offset = EE_GET(O_HVI) + EE_GET(O_VSMF);
    7da6:	7ed8 09d8 	lod	X, 0x9d8 <.LLST18+0x8>
    7daa:	54e4      	mov	Cx, #4
    7dac:	44fe      	asr	X, #2
    7dae:	1ffe      	djnz	Cx, 0x7dac <.L2+0x6>
    7db0:	2203      	add	X, [S-4]
    7db2:	5ed8 1332 	mov	0x1332 <_calib_vsmf>, X

00007db6 <.LM9>:
    calib_vsmf.simple.gain = EE_GET(GAIN_VSMF);
    7db6:	52d8 1334 	mov	0x1334 <.LLST24>, A

00007dba <.LM10>:
    calib_vsmf.gain_low_t = EE_GET(GAINLO_VSMF);
    7dba:	6605      	lod	YL, [S-6]
    7dbc:	46d8 1336 	mov	0x1336 <.LLST24+0x2>, YL

00007dc0 <.LM11>:
    calib_vsmf.gain_high_t = EE_GET(GAINHI_VSMF);
    7dc0:	6601      	lod	YL, [S-2]
    7dc2:	46d8 1337 	mov	0x1337 <.LLST24+0x3>, YL

00007dc6 <.LM12>:
    calib_vsmf.simple.gain = EE_GET(VSM_FILT_GAIN);
    calib_vsmf.gain_low_t = 0;
    calib_vsmf.gain_high_t = 0;
#endif

    if (calib_vsmf.simple.gain == 0u)
    7dc6:	ac00      	cmp	A, #0
    7dc8:	1d04      	jne	0x7dd2 <.L1>

00007dca <.LM13>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsmf.simple.gain = 164u;              /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7dca:	72da 00a4 	lod	A, #164
    7dce:	52d8 1334 	mov	0x1334 <.LLST24>, A

00007dd2 <.L1>:
    }
}
    7dd2:	5407      	ret	#8

00007dd4 <_conv_shunt_current_init>:
calib_data_t calib_current;

void conv_shunt_current_init(void)
{
#if defined(EE_O_CURR_GET)
    calib_current.simple.offset = EE_GET(O_CURR) + 512;
    7dd4:	72d8 09dc 	lod	A, 0x9dc <.LASF1599+0x3>
    7dd8:	7ee2      	lod	X, A
    7dda:	54e4      	mov	Cx, #4
    7ddc:	44fe      	asr	X, #2
    7dde:	1ffe      	djnz	Cx, 0x7ddc <_conv_shunt_current_init+0x8>
    7de0:	22da 0200 	add	X, #512
    7de4:	5ed8 133e 	mov	0x133e <_calib_current>, X

00007de8 <.LM3>:
    calib_current.simple.gain = EE_GET(GAIN_CURR);
    7de8:	d400      	and	AH, #0
    7dea:	52d8 1340 	mov	0x1340 <_calib_current+0x2>, A

00007dee <.LM4>:
    calib_current.gain_low_t = EE_GET(GAINLO_CURR);
    7dee:	72d8 09e0 	lod	A, 0x9e0 <.LASF1599+0x7>
    7df2:	42d8 1342 	mov	0x1342 <_calib_current+0x4>, AL

00007df6 <.LM5>:
    calib_current.gain_high_t = EE_GET(GAINHI_CURR);
    7df6:	0ea7      	lod	C, ML.7
    7df8:	4ad8 4313 	mov	0x1343 <_calib_current+0x5>, AH

00007dfc <.LM6>:
    calib_current.simple.offset = EE_GET(CURR_OFFS) + 512;
    calib_current.simple.gain = EE_GET(CURR_GAIN);
    calib_current.gain_low_t = 0;
    calib_current.gain_high_t = 0;
#endif
}
    7dfc:	5401      	ret

00007dfe <_conv_shunt_current>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    7dfe:	aad8 133e 	sub	A, 0x133e <_calib_current>

00007e02 <.LBB16>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7e02:	7ed8 1340 	lod	X, 0x1340 <_calib_current+0x2>
    7e06:	36da 00ff 	and	X, #255

00007e0a <.LM10>:

    __asm__ __volatile__ (
    7e0a:	4833      	muls	YA, A, X

00007e0c <.LBE16>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    7e0c:	4cb2 0000 	cmp	YA, #0
    7e10:	0000 
    7e12:	1e84      	jsge	0x7e1c <.L4>
    7e14:	4cc0      	mov	D, YA
    7e16:	4c0a 001f 	addu	D, #31
    7e1a:	4c80      	mov	YA, D

00007e1c <.L4>:
    7e1c:	48b4      	asr	YA, #5

00007e1e <.LBE14>:
{
    /* MLX81330: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^6
     * MLX81332: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^5
     */
    return apply_offset_gain(u16ADC_Value, &calib_current.simple, CURR_GAIN_DIV);
}
    7e1e:	5401      	ret

00007e20 <_Mot_dirChange_check>:
int16_t SensorGetDelta(void)
{
	return sensor.delta;
}
static uint16_t Mot_dirChange_check(void)
{
    7e20:	72d8 12b4 	lod	A, 0x12b4 <.LLST32+0x5>

00007e24 <.LM2>:
	uint16_t flag = 0;
#if C_MOT_POLE_POLAR == 0
	if (motor.direction == C_DIR_CW)
#else
	if (motor.direction == C_DIR_CCW)
    7e24:	7ed8 12a6 	lod	X, 0x12a6 <.LLST31+0xa>
    7e28:	2c02      	cmp	X, #2
    7e2a:	1d03      	jne	0x7e32 <.L2>

00007e2c <.LBB32>:
#endif
	{
		if (motor.pos.Delta < 0)
    7e2c:	4442      	rl	A
    7e2e:	b401      	and	A, #1
    7e30:	5401      	ret

00007e32 <.L2>:
			flag = 1;
    7e32:	ac00      	cmp	A, #0
    7e34:	5cb2      	ssg	A

00007e36 <.LBE32>:
	{
		if (motor.pos.Delta > 0)
			flag = 1;
	}
	return (flag);
}
    7e36:	5401      	ret

00007e38 <_MotRequestHardStop>:
#include "eeprom_app.h"
#include <lib_softio.h>

void MotRequestHardStop(void)
{
	motor.requestStop = 1;
    7e38:	7001      	lod	A, #1
    7e3a:	52d8 12a2 	mov	0x12a2 <.LLST31+0x6>, A

00007e3e <.LM8>:
}
    7e3e:	5401      	ret

00007e40 <_MotClearHardStop>:
void MotClearHardStop(void)
{
	motor.requestStop = 0;
    7e40:	7000      	lod	A, #0
    7e42:	52d8 12a2 	mov	0x12a2 <.LLST31+0x6>, A

00007e46 <.LM11>:
}
    7e46:	5401      	ret

00007e48 <_MotSetTargetPosition>:
	if (targetPos > (360 * C_GMR_ANGLE_SCALE_FACTOR))
	{
		targetPos -= (360 * C_GMR_ANGLE_SCALE_FACTOR);
	}
#endif
	motor.pos.target = targetPos;
    7e48:	52d8 12b0 	mov	0x12b0 <.LLST32+0x1>, A

00007e4c <.LM14>:
	if (motor.pos.target >= motor.pos.current)
    7e4c:	7ed8 12ae 	lod	X, 0x12ae <.LASF1845+0x5>
    7e50:	2ee2      	cmp	X, A
    7e52:	1f0f      	jsg	0x7e72 <.L7>

00007e54 <.LM15>:
	{
		diff = motor.pos.target - motor.pos.current;
    7e54:	7ae2      	lod	Y, A
    7e56:	eaee      	sub	Y, X
    7e58:	7ee6      	lod	X, Y

00007e5a <.L8>:
	}
	else
	{
		diff = motor.pos.current - motor.pos.target;
	}
	if ((motor.pos.target != motor.pos.lastTarget) || (diff > (int16_t)C_MOT_ON_HYSTERISYS))
    7e5a:	7ad8 12b2 	lod	Y, 0x12b2 <.LLST32+0x3>
    7e5e:	eee2      	cmp	Y, A
    7e60:	1d02      	jne	0x7e66 <.L9>

00007e62 <.LM17>:
    7e62:	2c0a      	cmp	X, #10
    7e64:	1b05      	jsle	0x7e70 <.L6>

00007e66 <.L9>:
	{
		motor.pos.newTarget = 1;
    7e66:	6401      	lod	YL, #1
    7e68:	46d8 12b6 	mov	0x12b6 <.LLST32+0x7>, YL

00007e6c <.LM19>:
		motor.pos.lastTarget = motor.pos.target;
    7e6c:	52d8 12b2 	mov	0x12b2 <.LLST32+0x3>, A

00007e70 <.L6>:
	}
}
    7e70:	5401      	ret

00007e72 <.L7>:
	{
		diff = motor.pos.target - motor.pos.current;
	}
	else
	{
		diff = motor.pos.current - motor.pos.target;
    7e72:	2ae2      	sub	X, A

00007e74 <.LVL5>:
    7e74:	07f2      	jmp	0x7e5a <.L8>

00007e76 <_MotGetCurrentPosition>:
	return motor.pos.target;
}
int16_t MotGetCurrentPosition(void)
{
	return motor.pos.current;
}
    7e76:	72d8 12ae 	lod	A, 0x12ae <.LASF1845+0x5>
    7e7a:	5401      	ret

00007e7c <_MotClearStallFlag>:
}
/*
type 0 : all clear
*/
void MotClearStallFlag(uint16_t type)
{
    7e7c:	7ae2      	lod	Y, A

00007e7e <.LM41>:
	if (type == 0)
    7e7e:	1d03      	jne	0x7e86 <.L18>

00007e80 <.LM42>:
	{
		motor.stall.flag = 0;
    7e80:	42d8 12d0 	mov	0x12d0 <.LASF2051+0x4>, AL
    7e84:	5401      	ret

00007e86 <.L18>:
    7e86:	62d8 12d0 	lod	AL, 0x12d0 <.LASF2051+0x4>

00007e8a <.LM43>:
	}
	else if (type == 1)
    7e8a:	ec01      	cmp	Y, #1
    7e8c:	1d04      	jne	0x7e96 <.L20>

00007e8e <.LM44>:
	{
		motor.stall.flag &= (~STALL_MASK_TEMPORARY);
    7e8e:	94fe      	and	AL, #-2

00007e90 <.L21>:
	}
	else
	{
		motor.stall.flag &= (~STALL_MASK_PERMENT);
    7e90:	42d8 12d0 	mov	0x12d0 <.LASF2051+0x4>, AL

00007e94 <.LM46>:
	}
}
    7e94:	5401      	ret

00007e96 <.L20>:
	{
		motor.stall.flag &= (~STALL_MASK_TEMPORARY);
	}
	else
	{
		motor.stall.flag &= (~STALL_MASK_PERMENT);
    7e96:	94fd      	and	AL, #-3
    7e98:	07fb      	jmp	0x7e90 <.L21>

00007e9a <_MotClearFaultFlag>:
/*
type 0 : all clear
*/
void MotClearFaultFlag(uint16_t type)
{
	if (type == 0)
    7e9a:	ac00      	cmp	A, #0
    7e9c:	1d07      	jne	0x7eac <.L23>

00007e9e <.LM50>:
	{
		motor.fault.flag = 0;
    7e9e:	42d8 12dc 	mov	0x12dc <.LASF1639+0x4>, AL

00007ea2 <.LM51>:
		g_e8OverCurrent = 0;
    7ea2:	42d8 11d2 	mov	0x11d2 <_g_e8OverCurrent>, AL

00007ea6 <.LM52>:
		g_e8ShortOcc = 0;
    7ea6:	52d8 11d4 	mov	0x11d4 <_g_e8ShortOcc>, A
    7eaa:	5401      	ret

00007eac <.L23>:
	}
	else if (type == 1)
    7eac:	ac01      	cmp	A, #1
    7eae:	1d06      	jne	0x7ebc <.L25>

00007eb0 <.LM54>:
	{
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_OPEN);
    7eb0:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>

00007eb4 <.LVL14>:
    7eb4:	94fe      	and	AL, #-2

00007eb6 <.L27>:
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_SHORT);
	}
	else if (type == 3)
	{
		g_e8OverCurrent = 0;
		motor.fault.flag &= (~FAULT_MASK_OVER_CURRENT);
    7eb6:	42d8 12dc 	mov	0x12dc <.LASF1639+0x4>, AL

00007eba <.L22>:
	}
	else
	{
	}
}
    7eba:	5401      	ret

00007ebc <.L25>:
	}
	else if (type == 1)
	{
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_OPEN);
	}
	else if (type == 2)
    7ebc:	ac02      	cmp	A, #2
    7ebe:	1d07      	jne	0x7ece <.L26>

00007ec0 <.LM58>:
	{
		g_e8ShortOcc = 0;
    7ec0:	7000      	lod	A, #0

00007ec2 <.LVL16>:
    7ec2:	52d8 11d4 	mov	0x11d4 <_g_e8ShortOcc>, A

00007ec6 <.LM59>:
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_SHORT);
    7ec6:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    7eca:	94ef      	and	AL, #-17
    7ecc:	07f4      	jmp	0x7eb6 <.L27>

00007ece <.L26>:
	}
	else if (type == 3)
    7ece:	ac03      	cmp	A, #3
    7ed0:	1d74      	jne	0x7eba <.L22>

00007ed2 <.LM61>:
	{
		g_e8OverCurrent = 0;
    7ed2:	6000      	lod	AL, #0

00007ed4 <.LVL18>:
    7ed4:	42d8 11d2 	mov	0x11d2 <_g_e8OverCurrent>, AL

00007ed8 <.LM62>:
		motor.fault.flag &= (~FAULT_MASK_OVER_CURRENT);
    7ed8:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    7edc:	94bf      	and	AL, #-65
    7ede:	07eb      	jmp	0x7eb6 <.L27>

00007ee0 <_MotGetState>:
	}
}
tMotState MotGetState(void)
{
	return motor.state;
}
    7ee0:	72d8 129a 	lod	A, 0x129a <_motor>
    7ee4:	5401      	ret

00007ee6 <_MotGetStallState>:
uint8_t MotGetStallState(void)
{
	return motor.stall.flag;
    7ee6:	62d8 12d0 	lod	AL, 0x12d0 <.LASF2051+0x4>
    7eea:	5cf2      	usex	A

00007eec <.LM67>:
}
    7eec:	5401      	ret

00007eee <_MotGetFaultState>:

uint8_t MotGetFaultState(void)
{
	return motor.fault.flag;
    7eee:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    7ef2:	5cf2      	usex	A

00007ef4 <.LM70>:
}
    7ef4:	5401      	ret

00007ef6 <_SensorGetState>:
uint8_t SensorGetState(void)
{
	return sensor.moving;
    7ef6:	72d8 128e 	lod	A, 0x128e <_sensor>
    7efa:	5cf2      	usex	A

00007efc <.LM73>:
}
    7efc:	5401      	ret

00007efe <_app_mot_init>:
}

void app_mot_init(void)
{

	motor.state = MOTION_STOPPED;
    7efe:	7801      	lod	Y, #1
    7f00:	5ad8 129a 	mov	0x129a <_motor>, Y

00007f04 <.LM87>:
	motor.lastState = MOTION_STOPPED;
    7f04:	5ad8 129c 	mov	0x129c <.LLST31>, Y

00007f08 <.LM88>:
	motor.initStatus = 1;
    7f08:	0ea7      	lod	C, ML.7
    7f0a:	5ad8 129e 	mov	0x129e <.LLST31+0x2>, Y

00007f0e <.LM89>:
	motor.elapsedTime = 0;
    7f0e:	7000      	lod	A, #0
    7f10:	52d8 12a0 	mov	0x12a0 <.LLST31+0x4>, A

00007f14 <.LM90>:
	motor.direction = C_DIR_NONE;
    7f14:	0ea7      	lod	C, ML.7
    7f16:	52d8 12a6 	mov	0x12a6 <.LLST31+0xa>, A

00007f1a <.LM91>:
	motor.lastDirection = C_DIR_NONE;
    7f1a:	52d8 12a8 	mov	0x12a8 <.LLST31+0xc>, A

00007f1e <.LM92>:
	motor.runTimeOut = (5 * 1000);
    7f1e:	7eda 1388 	lod	X, #5000
    7f22:	0ea7      	lod	C, ML.7
    7f24:	5ed8 12aa 	mov	0x12aa <.LASF1845+0x1>, X

00007f28 <.LM93>:
	motor.pos.target = 0;
    7f28:	52d8 12b0 	mov	0x12b0 <.LLST32+0x1>, A

00007f2c <.LM94>:
	motor.pos.lastTarget = 0;
    7f2c:	52d8 12b2 	mov	0x12b2 <.LLST32+0x3>, A

00007f30 <.LM95>:
	motor.pos.current = 0;
    7f30:	0ea7      	lod	C, ML.7
    7f32:	52d8 12ae 	mov	0x12ae <.LASF1845+0x5>, A

00007f36 <.LM96>:
	motor.pos.newTarget = 0;
    7f36:	52d8 12b6 	mov	0x12b6 <.LLST32+0x7>, A

00007f3a <.LM97>:
	motor.pos.posReached = 0;
    7f3a:	5ad8 12b8 	mov	0x12b8 <.LLST32+0x9>, Y

00007f3e <.LM98>:
	motor.out.enable = 0;
	motor.out.duty = 0;
	motor.out.maxDuty = C_MOT_MAXDUTY_SET;
	motor.out.minDuty = C_MOT_MINDUTY_SET;
	motor.softStart.enable = 1u;
    7f3e:	0ea7      	lod	C, ML.7
    7f40:	7eda 0733 	lod	X, #1843
    7f44:	5ed8 12ba 	mov	0x12ba <.LLST32+0xb>, X

00007f48 <.LM99>:
	motor.softStart.outThreshold = (C_MOT_MAXDUTY_SET * 0.9f);
    7f48:	7c66      	lod	X, #102
    7f4a:	0ea7      	lod	C, ML.7
    7f4c:	5ed8 12bc 	mov	0x12bc <.LASF1024+0x1>, X

00007f50 <.LM100>:
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0027f);/*300ms=6*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.002f);/*400ms=4*/
	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0016f);/*500ms=3*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0015f);/*533ms*/
#else
	motor.softStart.accDuty = (C_MOT_MAXDUTY_SET * 0.05f);
    7f50:	5ad8 12be 	mov	0x12be <.LASF1024+0x3>, Y

00007f54 <.LM101>:
#endif
	motor.softStop.enable = 1u;
	motor.softStop.completed = 0;
    7f54:	7c28      	lod	X, #40
    7f56:	0ea7      	lod	C, ML.7
    7f58:	5ed8 12c0 	mov	0x12c0 <.LASF1024+0x5>, X

00007f5c <.LM102>:
	motor.softStop.inThreshold = (4 * C_GMR_ANGLE_SCALE_FACTOR);
    7f5c:	7c14      	lod	X, #20
    7f5e:	5ed8 12c2 	mov	0x12c2 <.LASF1024+0x7>, X

00007f62 <.LM103>:
#if SOFTSTART_TEST_ENABLE
	motor.softStop.dccDuty = (C_MOT_MAXDUTY_SET * 0.0016f);
#else
	motor.softStop.dccDuty = (C_MOT_MAXDUTY_SET * 0.01f);
    7f62:	0ea7      	lod	C, ML.7
    7f64:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

00007f68 <.LM104>:
	motor.pos.target = 0;
	motor.pos.lastTarget = 0;
	motor.pos.current = 0;
	motor.pos.newTarget = 0;
	motor.pos.posReached = 0;
	motor.out.enable = 0;
    7f68:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

00007f6c <.LM105>:
	motor.out.duty = 0;
    7f6c:	7eda 0800 	lod	X, #2048
    7f70:	0ea7      	lod	C, ML.7
    7f72:	5ed8 12c8 	mov	0x12c8 <.LASF1024+0xd>, X

00007f76 <.LM106>:
	motor.out.maxDuty = C_MOT_MAXDUTY_SET;
    7f76:	7eda 0200 	lod	X, #512
    7f7a:	5ed8 12ca 	mov	0x12ca <.LASF1024+0xf>, X

00007f7e <.LM107>:
#if SOFTSTART_TEST_ENABLE
	motor.softStop.dccDuty = (C_MOT_MAXDUTY_SET * 0.0016f);
#else
	motor.softStop.dccDuty = (C_MOT_MAXDUTY_SET * 0.01f);
#endif
	motor.stall.flag = 0;
    7f7e:	0ea7      	lod	C, ML.7
    7f80:	42d8 12d0 	mov	0x12d0 <.LASF2051+0x4>, AL

00007f84 <.LM108>:
	motor.stall.maskTimer = 0;
    7f84:	52d8 12d2 	mov	0x12d2 <.LASF2063>, A

00007f88 <.LM109>:
	motor.stall.threshold = 800; /* 1000mA -> 800mA */
    7f88:	7eda 0320 	lod	X, #800
    7f8c:	0ea7      	lod	C, ML.7
    7f8e:	5ed8 12d8 	mov	0x12d8 <.LASF1639>, X

00007f92 <.LM110>:

	motor.fault.flag = 0;
    7f92:	7eda 0100 	lod	X, #256
    7f96:	5ed8 12dc 	mov	0x12dc <.LASF1639+0x4>, X

00007f9a <.LM111>:
	motor.fault.openEnable = 1;
	motor.fault.ocEnable = 1;
    7f9a:	0ea7      	lod	C, ML.7
    7f9c:	46d8 12de 	mov	0x12de <.LASF1639+0x6>, YL

00007fa0 <.LM112>:
	motor.fault.ocDetectCnt = 0;
    7fa0:	52d8 12e2 	mov	0x12e2 <.LASF1639+0xa>, A

00007fa4 <.LM113>:
	motor.fault.openDetectCheck = 0;
    7fa4:	42d8 12e4 	mov	0x12e4 <.LLST33+0x1>, AL

00007fa8 <.LM114>:
	motor.fault.openDetectCnt = 0;
    7fa8:	0ea7      	lod	C, ML.7
    7faa:	52d8 12e6 	mov	0x12e6 <.LLST33+0x3>, A

00007fae <.LM115>:

	sensor.delay = 0;
    7fae:	42d8 1290 	mov	0x1290 <_sensor+0x2>, AL

00007fb2 <.LM116>:
	sensor.delta = 0;
    7fb2:	52d8 1294 	mov	0x1294 <_sensor+0x6>, A

00007fb6 <.LM117>:
	sensor.moving = C_STATUS_OFF_;
    7fb6:	0ea7      	lod	C, ML.7
    7fb8:	52d8 128e 	mov	0x128e <_sensor>, A

00007fbc <.LM118>:
	sensor.lastDeg = 0;
    7fbc:	52d8 1298 	mov	0x1298 <_sensor+0xa>, A

00007fc0 <.LM119>:
}
    7fc0:	5401      	ret

00007fc2 <_app_motor_task>:

/* called by every 1ms */
void app_motor_task(void)
{
    7fc2:	5803      	inc	S, #4

00007fc4 <.LCFI0>:
	tMotState next_state = motor.state;
	uint16_t voltage = get_valve_voltage();
    7fc4:	82db 3537 	callf	0x6a6e <_get_valve_voltage>

00007fc8 <.LVL24>:
    7fc8:	5203      	mov	[S-4], A

00007fca <.LM122>:

	#if LIN_DEBUG_ENABLE
	g_u16DebugData[1] = motor.state;	
    7fca:	72d8 129a 	lod	A, 0x129a <_motor>

00007fce <.LVL26>:
    7fce:	52d8 11bc 	mov	0x11bc <_g_u16DebugData+0x2>, A

00007fd2 <.LM123>:
	g_u16DebugData[2] = motor.stall.flag;
    7fd2:	66d8 12d0 	lod	YL, 0x12d0 <.LASF2051+0x4>
    7fd6:	5cf6      	usex	Y
    7fd8:	5a01      	mov	[S-2], Y
    7fda:	5ad8 11be 	mov	0x11be <_g_u16DebugData+0x4>, Y

00007fde <.LBB53>:

STATIC INLINE bool softio_set(GpioIo_t IO)
{
    bool success = false;
    if(IO <= MAXIO_INDEX) {
        IO_HOST(PORT_IO_OUT_SOFT, IO_OUT_SOFT) |= ((uint16_t)0x01u << (uint16_t)IO);
    7fde:	7ed8 01e6 	lod	X, 0x1e6 <_PORT_IO_OUT_SOFT>

00007fe2 <.LBE53>:
	#endif


	if(motor.state == MOTION_STALL)	softio_set(DEBUG_PIN_7);
    7fe2:	ac06      	cmp	A, #6
    7fe4:	1d11      	jne	0x8008 <.L39>

00007fe6 <.LM126>:
    7fe6:	26da 0080 	or	X, #128
    7fea:	5ed8 01e6 	mov	0x1e6 <_PORT_IO_OUT_SOFT>, X
    7fee:	7c00      	lod	X, #0

00007ff0 <.LBB57>:

static tMotState motor_state_STALLED(void)
{
	tMotState next_state = MOTION_STALL;

	if (motor.initStatus)
    7ff0:	0ea7      	lod	C, ML.7
    7ff2:	7ad8 129e 	lod	Y, 0x129e <.LLST31+0x2>
    7ff6:	1901      	je	0x7ffa <.L41>
    7ff8:	0170      	jmp	0x82da <.L40>

00007ffa <.L41>:
	{
		motor.initStatus = 0;
		motor.out.enable = 0;
	}
	motor.holdTime = 0;
    7ffa:	5ed8 12ac 	mov	0x12ac <.LASF1845+0x3>, X

00007ffe <.LM129>:
	motor.out.duty = 0;
    7ffe:	5ed8 12c6 	mov	0x12c6 <.LASF1024+0xb>, X

00008002 <.LM130>:
	if (motor.stall.flag == 0u)
    8002:	7a01      	lod	Y, [S-2]
    8004:	1913      	je	0x802c <.L132>
    8006:	0039      	jmp	0x807a <.L42>

00008008 <.L39>:

STATIC INLINE bool softio_clr(GpioIo_t IO)
{
    bool success = false;
    if(IO <= MAXIO_INDEX) {
        IO_HOST(PORT_IO_OUT_SOFT, IO_OUT_SOFT) &= ~((uint16_t)0x01u << (uint16_t)IO);
    8008:	36da ff7f 	and	X, #65407
    800c:	5ed8 01e6 	mov	0x1e6 <_PORT_IO_OUT_SOFT>, X

00008010 <.LBE60>:


	if(motor.state == MOTION_STALL)	softio_set(DEBUG_PIN_7);
	else							softio_clr(DEBUG_PIN_7);	
	/*** state machine control ***/
	switch (motor.state)
    8010:	ac07      	cmp	A, #7
    8012:	1e0c      	jug	0x802c <.L132>
    8014:	4422      	asl	A
    8016:	7ee2      	lod	X, A
    8018:	22da 5d36 	add	X, #23862
    801c:	76f8      	jmp	[X]

0000801e <.L43>:
}

static tMotState motor_state_INIT(void)
{
	tMotState next_state = MOTION_INIT;
	if (motor.initStatus)
    801e:	72d8 129e 	lod	A, 0x129e <.LLST31+0x2>
    8022:	1d01      	jne	0x8026 <.LM134>
    8024:	0156      	jmp	0x82d2 <.L51>

00008026 <.LM134>:
	{
		motor.initStatus = 0;
    8026:	7000      	lod	A, #0
    8028:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

0000802c <.L132>:
	}
	motor.out.duty = 0;
	if (motor.fault.flag == 0u)
	{
		DIAGNOSTIC_Reset();
		next_state = MOTION_STOPPED;
    802c:	7001      	lod	A, #1
    802e:	0025      	jmp	0x807a <.L42>

00008030 <.L45>:
    8030:	7000      	lod	A, #0

00008032 <.LBB67>:

static tMotState motor_state_STOPPED(void)
{
	tMotState next_state = MOTION_STOPPED;
	uint16_t rState = 0;
	if (motor.initStatus)
    8032:	7ed8 129e 	lod	X, 0x129e <.LLST31+0x2>
    8036:	1902      	je	0x803c <.L52>

00008038 <.LM137>:
	{
		motor.initStatus = 0;
    8038:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

0000803c <.L52>:
	}

	motor.out.enable = 0;
    803c:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

00008040 <.LM139>:
	motor.out.duty = 0;
    8040:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

00008044 <.LM140>:
	motor.pos.posReached = 0;
    8044:	42d8 12b7 	mov	0x12b7 <.LLST32+0x8>, AL

00008048 <.LM141>:
	if (motor.requestStop != 0)
    8048:	0ea7      	lod	C, ML.7
    804a:	7ad8 12a2 	lod	Y, 0x12a2 <.LLST31+0x6>
    804e:	1901      	je	0x8052 <.LM142>
    8050:	00e7      	jmp	0x8220 <.L53>

00008052 <.LM142>:
	{
	}
	else if (motor.pos.newTarget)
    8052:	62d8 12b6 	lod	AL, 0x12b6 <.LLST32+0x7>
    8056:	1d01      	jne	0x805a <.LM143>
    8058:	00e3      	jmp	0x8220 <.L53>

0000805a <.LM143>:
	{
		motor.pos.newTarget = 0;
    805a:	46d8 12b6 	mov	0x12b6 <.LLST32+0x7>, YL

0000805e <.LM144>:
#if C_MOT_POLE_POLAR == 0
		if (motor.pos.Delta > 0)
#else
		if (motor.pos.Delta < 0)
    805e:	72d8 12b4 	lod	A, 0x12b4 <.LLST32+0x5>
    8062:	1981      	jn	0x8066 <.LM145>
    8064:	0072      	jmp	0x814a <.L54>

00008066 <.LM145>:
#endif
		{
			motor.direction = C_DIR_CW;
    8066:	7001      	lod	A, #1

00008068 <.L131>:
		}
		else
		{
			motor.direction = C_DIR_CCW;
    8068:	52d8 12a6 	mov	0x12a6 <.LLST31+0xa>, A

0000806c <.LM147>:
	{
	}

	if (rState != 0)
	{
		pwm_Start(motor.direction, 0u);
    806c:	5cf2      	usex	A
    806e:	54ca 0000 	pushw	#0

00008072 <.LCFI1>:
    8072:	82db 4e93 	callf	0x9d26 <_pwm_Start>
    8076:	5c01      	dec	S, #2

00008078 <.L62>:
motor.softStart.outThreshold = 90%
ACC duration = (90-10)/5/1ms = 16ms
*/
static tMotState motor_state_ACC(void) /*20250714*/
{
	tMotState next_state = MOTION_ACC;
    8078:	7002      	lod	A, #2

0000807a <.L42>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    807a:	7ed8 129a 	lod	X, 0x129a <_motor>
    807e:	2ee2      	cmp	X, A
    8080:	1d01      	jne	0x8084 <.L92>
    8082:	00ce      	jmp	0x8220 <.L53>

00008084 <.L92>:
	{
		motor.lastState = motor.state;
    8084:	5ed8 129c 	mov	0x129c <.LLST31>, X

00008088 <.LM151>:
		motor.state = next_state;
    8088:	52d8 129a 	mov	0x129a <_motor>, A

0000808c <.LM152>:
		motor.initStatus = 1u;
    808c:	7001      	lod	A, #1

0000808e <.LVL40>:
    808e:	0ea7      	lod	C, ML.7
    8090:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

00008094 <.LM153>:
		motor.elapsedTime = 0;
    8094:	7000      	lod	A, #0

00008096 <.L133>:
	}
	else
	{
		if (motor.elapsedTime < 0xFFFFu)
			motor.elapsedTime += 1u;
    8096:	52d8 12a0 	mov	0x12a0 <.LLST31+0x4>, A

0000809a <.L74>:
	}
	if (motor.out.enable != 0)
    809a:	72d8 12c4 	lod	A, 0x12c4 <.LASF1024+0x9>
    809e:	1d01      	jne	0x80a2 <.LM156>
    80a0:	0192      	jmp	0x83c6 <.L75>

000080a2 <.LM156>:
	{
		if (sensor.delay > 0)
    80a2:	62d8 1290 	lod	AL, 0x1290 <_sensor+0x2>
    80a6:	1903      	je	0x80ae <.L76>

000080a8 <.LM157>:
		{
			sensor.delay -= 1;
    80a8:	80ff      	add	AL, #-1
    80aa:	42d8 1290 	mov	0x1290 <_sensor+0x2>, AL

000080ae <.L76>:
		}
		if (sensor.delay == 0)
    80ae:	62d8 1290 	lod	AL, 0x1290 <_sensor+0x2>
    80b2:	1d05      	jne	0x80be <.L77>

000080b4 <.LM159>:
		{
			sensor.filterPeriod += 1;
    80b4:	62d8 1291 	lod	AL, 0x1291 <_sensor+0x3>
    80b8:	8001      	add	AL, #1
    80ba:	42d8 1291 	mov	0x1291 <_sensor+0x3>, AL

000080be <.L77>:
		}

		if (voltage <= 950)
    80be:	7203      	lod	A, [S-4]
    80c0:	aeda 03b6 	cmp	A, #950
    80c4:	1a01      	jule	0x80c8 <.LM161>
    80c6:	011f      	jmp	0x8306 <.L78>

000080c8 <.LM161>:
		{
			sensor.thd = 10;
    80c8:	700a      	lod	A, #10
    80ca:	52d8 1296 	mov	0x1296 <_sensor+0x8>, A

000080ce <.LM162>:
			motor.stall.halfThd = 550;
    80ce:	72da 0226 	lod	A, #550
    80d2:	0ea7      	lod	C, ML.7
    80d4:	52d8 12d6 	mov	0x12d6 <.LASF2063+0x4>, A

000080d8 <.LM163>:
			motor.stall.threshold = 650;
    80d8:	72da 028a 	lod	A, #650
    80dc:	52d8 12d8 	mov	0x12d8 <.LASF1639>, A

000080e0 <.LM164>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.35);
    80e0:	0ea7      	lod	C, ML.7
    80e2:	72da 02cc 	lod	A, #716

000080e6 <.L134>:
		else if (voltage <= 1050)
		{
			sensor.thd = 11;
			motor.stall.halfThd = 600;
			motor.stall.threshold = 700;
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.32);
    80e6:	52d8 12ca 	mov	0x12ca <.LASF1024+0xf>, A

000080ea <.L79>:
		sensor.delta = 0;
		sensor.moving = C_STATUS_OFF_;
		sensor.lastDeg = motor.pos.current;
	}

	if (sensor.filterPeriod >= 20) /*20msec*/
    80ea:	62d8 1291 	lod	AL, 0x1291 <_sensor+0x3>
    80ee:	8c13      	cmp	AL, #19
    80f0:	1f01      	jsg	0x80f4 <.LM167>
    80f2:	018d      	jmp	0x840e <.L38>

000080f4 <.LM167>:
	{
		sensor.filterPeriod = 0;
    80f4:	6000      	lod	AL, #0
    80f6:	42d8 1291 	mov	0x1291 <_sensor+0x3>, AL

000080fa <.LM168>:
		if (motor.pos.current > sensor.lastDeg)
    80fa:	7ed8 12ae 	lod	X, 0x12ae <.LASF1845+0x5>
    80fe:	0ea7      	lod	C, ML.7
    8100:	72d8 1298 	lod	A, 0x1298 <_sensor+0xa>
    8104:	2ee2      	cmp	X, A
    8106:	1f01      	jsg	0x810a <.LM169>
    8108:	016f      	jmp	0x83e8 <.L86>

0000810a <.LM169>:
		{
			sensor.delta = motor.pos.current - sensor.lastDeg;
    810a:	7aee      	lod	Y, X
    810c:	eae2      	sub	Y, A
    810e:	72e6      	lod	A, Y

00008110 <.L135>:
		}
		else
		{
			sensor.delta = sensor.lastDeg - motor.pos.current;
    8110:	52d8 1294 	mov	0x1294 <_sensor+0x6>, A

00008114 <.LM171>:
		}

		sensor.lastDeg = motor.pos.current;
    8114:	5ed8 1298 	mov	0x1298 <_sensor+0xa>, X
    8118:	62d8 1292 	lod	AL, 0x1292 <_sensor+0x4>
    811c:	5ce2      	ssex	A

0000811e <.LM172>:

		if (sensor.delta >= sensor.thd)
    811e:	7ed8 1294 	lod	X, 0x1294 <_sensor+0x6>
    8122:	2ed8 1296 	cmp	X, 0x1296 <_sensor+0x8>
    8126:	1e81      	jsge	0x812a <.LM173>
    8128:	0161      	jmp	0x83ec <.L88>

0000812a <.LM173>:
		{
			if (sensor.filterCnt < 3)
    812a:	ac02      	cmp	A, #2
    812c:	1f03      	jsg	0x8134 <.L89>

0000812e <.LM174>:
				sensor.filterCnt++;
    812e:	8001      	add	AL, #1

00008130 <.L136>:
		}
		else
		{
			if (sensor.filterCnt > -3)
				sensor.filterCnt--;
    8130:	42d8 1292 	mov	0x1292 <_sensor+0x4>, AL

00008134 <.L89>:
		}
		if (sensor.filterCnt >= 2)
    8134:	7eda 128e 	lod	X, #4750
    8138:	62d8 1292 	lod	AL, 0x1292 <_sensor+0x4>
    813c:	5ce2      	ssex	A
    813e:	ac01      	cmp	A, #1
    8140:	1f01      	jsg	0x8144 <.LM177>
    8142:	0159      	jmp	0x83f6 <.L90>

00008144 <.LM177>:
		{
			sensor.moving = C_STATUS_RUN;
    8144:	7001      	lod	A, #1

00008146 <.L137>:
		}
		else if (sensor.filterCnt <= -2)
		{

			sensor.moving = C_STATUS_STOP;
    8146:	52f8      	mov	[X], A

00008148 <.LM179>:
		}
		else
		{
		}
	}
}
    8148:	5405      	ret	#6

0000814a <.L54>:
		{
			motor.direction = C_DIR_CW;
		}
		else
		{
			motor.direction = C_DIR_CCW;
    814a:	7002      	lod	A, #2
    814c:	078d      	jmp	0x8068 <.L131>

0000814e <.L46>:
*/
static tMotState motor_state_ACC(void) /*20250714*/
{
	tMotState next_state = MOTION_ACC;
	uint16_t u16diff;
	if (motor.initStatus)
    814e:	72d8 129e 	lod	A, 0x129e <.LLST31+0x2>
    8152:	190b      	je	0x816a <.L56>

00008154 <.LM182>:
	{
		motor.initStatus = 0;
    8154:	7000      	lod	A, #0
    8156:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

0000815a <.LM183>:
		motor.out.enable = 1;
    815a:	7001      	lod	A, #1
    815c:	0ea7      	lod	C, ML.7
    815e:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

00008162 <.LM184>:
		motor.out.duty = C_MOT_STARTDUTY_SET;
    8162:	72da 00cc 	lod	A, #204
    8166:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

0000816a <.L56>:
	}

	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    816a:	72d8 12a2 	lod	A, 0x12a2 <.LLST31+0x6>
    816e:	1901      	je	0x8172 <.LASF1645>
    8170:	00b0      	jmp	0x82d2 <.L51>
    8172:	62d8 12b7 	lod	AL, 0x12b7 <.LLST32+0x8>
    8176:	1901      	je	0x817a <.LM186>
    8178:	00ac      	jmp	0x82d2 <.L51>

0000817a <.LM186>:
	{
		next_state = MOTION_STOPPED;
	}
	else
	{
		if (motor.pos.Delta >= 0)
    817a:	7ed8 12b4 	lod	X, 0x12b4 <.LLST32+0x5>

0000817e <.LM187>:
		{
			u16diff = motor.pos.Delta;
    817e:	1d81      	jnn	0x8182 <.L138>
    8180:	5cce      	neg	X

00008182 <.L138>:
    8182:	7ad8 12c0 	lod	Y, 0x12c0 <.LASF1024+0x5>

00008186 <.LM188>:
		}
		else
		{
			u16diff = -motor.pos.Delta;
		}
		if (motor.softStart.enable)
    8186:	72d8 12b8 	lod	A, 0x12b8 <.LLST32+0x9>
    818a:	1918      	je	0x81bc <.L59>
    818c:	72d8 12c6 	lod	A, 0x12c6 <.LASF1024+0xb>
    8190:	a2d8 12bc 	add	A, 0x12bc <.LASF1024+0x1>

00008194 <.LM189>:
		{
			if (u16diff <= motor.softStop.inThreshold)
			{
				motor.out.duty += motor.softStart.accDuty;
    8194:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

00008198 <.LM190>:
		{
			u16diff = -motor.pos.Delta;
		}
		if (motor.softStart.enable)
		{
			if (u16diff <= motor.softStop.inThreshold)
    8198:	2ee6      	cmp	X, Y
    819a:	1e09      	jug	0x81ae <.L60>

0000819c <.LM191>:
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.out.minDuty)
    819c:	7ed8 12ca 	lod	X, 0x12ca <.LASF1024+0xf>

000081a0 <.LVL45>:
    81a0:	2ee2      	cmp	X, A
    81a2:	1a01      	jule	0x81a6 <.L61>
    81a4:	0769      	jmp	0x8078 <.L62>

000081a6 <.L61>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    81a6:	7ed8 129a 	lod	X, 0x129a <_motor>

000081aa <.LM193>:
			if (u16diff <= motor.softStop.inThreshold)
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.out.minDuty)
				{
					next_state = MOTION_DEC;
    81aa:	7004      	lod	A, #4
    81ac:	076b      	jmp	0x8084 <.L92>

000081ae <.L60>:
				}
			}
			else
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.softStart.outThreshold)
    81ae:	7ed8 12ba 	lod	X, 0x12ba <.LLST32+0xb>

000081b2 <.LVL48>:
    81b2:	2ee2      	cmp	X, A
    81b4:	1a01      	jule	0x81b8 <.LM195>
    81b6:	0760      	jmp	0x8078 <.L62>

000081b8 <.LM195>:
				{
					next_state = MOTION_RUNNING;
    81b8:	7003      	lod	A, #3
    81ba:	075f      	jmp	0x807a <.L42>

000081bc <.L59>:
			}
		}
		else
		{

			if (u16diff <= motor.softStop.inThreshold)
    81bc:	2ee6      	cmp	X, Y
    81be:	1a01      	jule	0x81c2 <.LM197>
    81c0:	011e      	jmp	0x83fe <.L63>

000081c2 <.LM197>:
			{
				motor.out.duty += motor.softStart.accDuty;
    81c2:	72d8 12c6 	lod	A, 0x12c6 <.LASF1024+0xb>
    81c6:	a2d8 12bc 	add	A, 0x12bc <.LASF1024+0x1>
    81ca:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

000081ce <.LM198>:
				if (motor.out.duty >= motor.softStart.outThreshold)
    81ce:	0ea7      	lod	C, ML.7
    81d0:	aed8 12ba 	cmp	A, 0x12ba <.LLST32+0xb>
    81d4:	1c68      	jnc	0x81a6 <.L61>
    81d6:	0750      	jmp	0x8078 <.L62>

000081d8 <.L47>:
}
static tMotState motor_state_RUNNING(void)
{
	tMotState next_state = MOTION_RUNNING;
	uint16_t u16diff;
	if (motor.initStatus)
    81d8:	72d8 129e 	lod	A, 0x129e <.LLST31+0x2>
    81dc:	1907      	je	0x81ec <.L64>

000081de <.LM200>:
	{
		motor.initStatus = 0;
    81de:	7000      	lod	A, #0
    81e0:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

000081e4 <.LM201>:
		motor.out.enable = 1;
    81e4:	7001      	lod	A, #1
    81e6:	0ea7      	lod	C, ML.7
    81e8:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

000081ec <.L64>:
	}
#if DUTY_ADJUST_ENABLE == 0
	motor.out.duty = C_MOT_MAXDUTY_SET;
    81ec:	72da 0800 	lod	A, #2048
    81f0:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

000081f4 <.LM203>:
#else
	motor.out.duty = motor.out.maxDuty;
#endif
	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    81f4:	72d8 12a2 	lod	A, 0x12a2 <.LLST31+0x6>
    81f8:	1901      	je	0x81fc <.LASF1232+0x4>
    81fa:	006b      	jmp	0x82d2 <.L51>
    81fc:	62d8 12b7 	lod	AL, 0x12b7 <.LLST32+0x8>
    8200:	1901      	je	0x8204 <.LM204>
    8202:	0067      	jmp	0x82d2 <.L51>

00008204 <.LM204>:
	{

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
    8204:	160d      	call	0x7e20 <_Mot_dirChange_check>
    8206:	ac00      	cmp	A, #0
    8208:	1901      	je	0x820c <.LM205>
    820a:	00fd      	jmp	0x8406 <.L65>

0000820c <.LM205>:
	}
#endif
	else
	{

		if (motor.softStop.enable)
    820c:	62d8 12be 	lod	AL, 0x12be <.LASF1024+0x3>
    8210:	1907      	je	0x8220 <.L53>

00008212 <.LM206>:
			}
			else
			{
				u16diff = -motor.pos.Delta;
			}
			if (u16diff <= motor.softStop.inThreshold)
    8212:	72d8 12b4 	lod	A, 0x12b4 <.LLST32+0x5>
    8216:	1d81      	jnn	0x821a <.L139>
    8218:	5cc2      	neg	A

0000821a <.L139>:
    821a:	aed8 12c0 	cmp	A, 0x12c0 <.LASF1024+0x5>
    821e:	1a43      	jule	0x81a6 <.L61>

00008220 <.L53>:
		motor.initStatus = 1u;
		motor.elapsedTime = 0;
	}
	else
	{
		if (motor.elapsedTime < 0xFFFFu)
    8220:	72d8 12a0 	lod	A, 0x12a0 <.LLST31+0x4>
    8224:	acff      	cmp	A, #-1
    8226:	1d01      	jne	0x822a <.LM208>
    8228:	0738      	jmp	0x809a <.L74>

0000822a <.LM208>:
			motor.elapsedTime += 1u;
    822a:	a001      	add	A, #1
    822c:	0734      	jmp	0x8096 <.L133>

0000822e <.L48>:
}
static tMotState motor_state_DCC(void)
{
	tMotState next_state = MOTION_DEC;
	uint16_t u16diff = 0;
	if (motor.initStatus)
    822e:	72d8 129e 	lod	A, 0x129e <.LLST31+0x2>
    8232:	1909      	je	0x8246 <.L68>

00008234 <.LM210>:
	{
		motor.initStatus = 0;
    8234:	7000      	lod	A, #0
    8236:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

0000823a <.LM211>:
		motor.out.enable = 1;
    823a:	7c01      	lod	X, #1
    823c:	0ea7      	lod	C, ML.7
    823e:	5ed8 12c4 	mov	0x12c4 <.LASF1024+0x9>, X

00008242 <.LM212>:
		motor.softStop.completed = 0;
    8242:	42d8 12bf 	mov	0x12bf <.LASF1024+0x4>, AL

00008246 <.L68>:
	}

	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    8246:	72d8 12a2 	lod	A, 0x12a2 <.LLST31+0x6>
    824a:	1901      	je	0x824e <.LASF43+0x6>
    824c:	0042      	jmp	0x82d2 <.L51>
    824e:	62d8 12b7 	lod	AL, 0x12b7 <.LLST32+0x8>
    8252:	1901      	je	0x8256 <.LM214>
    8254:	003e      	jmp	0x82d2 <.L51>

00008256 <.LM214>:
	{

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
    8256:	15e4      	call	0x7e20 <_Mot_dirChange_check>
    8258:	7ae2      	lod	Y, A
    825a:	1901      	je	0x825e <.LM215>
    825c:	00d4      	jmp	0x8406 <.L65>

0000825e <.LM215>:
	{
		next_state = MOTION_PAUSE;
	}
	else
	{
		if (motor.softStop.completed == 0)
    825e:	62d8 12bf 	lod	AL, 0x12bf <.LASF1024+0x4>
    8262:	1d16      	jne	0x8290 <.L69>

00008264 <.LM216>:
			{
				motor.out.duty = motor.out.minDuty;

			}
#else
			if (motor.pos.Delta >= 0)
    8264:	7ad8 12b4 	lod	Y, 0x12b4 <.LLST32+0x5>

00008268 <.LM217>:
			{
				u16diff = motor.pos.Delta;
    8268:	1d81      	jnn	0x826c <.L140>
    826a:	5cc6      	neg	Y

0000826c <.L140>:
			}
			else
			{
				u16diff = -motor.pos.Delta;
			}
			motor.out.duty -= ((u16diff >> 1) + motor.softStop.dccDuty);
    826c:	72d8 12c6 	lod	A, 0x12c6 <.LASF1024+0xb>
    8270:	aad8 12c2 	sub	A, 0x12c2 <.LASF1024+0x7>
    8274:	5201      	mov	[S-2], A
    8276:	72e6      	lod	A, Y
    8278:	4432      	lsr	A
    827a:	7ee2      	lod	X, A
    827c:	7201      	lod	A, [S-2]
    827e:	aaee      	sub	A, X
    8280:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

00008284 <.LM219>:
			if (motor.out.duty < motor.out.minDuty)
    8284:	7ed8 12ca 	lod	X, 0x12ca <.LASF1024+0xf>
    8288:	aeee      	cmp	A, X
    828a:	1c02      	jnc	0x8290 <.L69>

0000828c <.LM220>:
			{
				motor.out.duty = motor.out.minDuty;
    828c:	5ed8 12c6 	mov	0x12c6 <.LASF1024+0xb>, X

00008290 <.L69>:
			}
#endif
		}
		if (sensor.moving == C_STATUS_STOP)
    8290:	72d8 128e 	lod	A, 0x128e <_sensor>
    8294:	ac02      	cmp	A, #2
    8296:	1d0c      	jne	0x82b0 <.L95>

00008298 <.LM222>:
		{

			motor.softStop.completed = 1;
    8298:	6001      	lod	AL, #1
    829a:	42d8 12bf 	mov	0x12bf <.LASF1024+0x4>, AL

0000829e <.LM223>:
			motor.out.duty += ((u16diff >> 1) + motor.softStop.dccDuty);
    829e:	72d8 12c6 	lod	A, 0x12c6 <.LASF1024+0xb>
    82a2:	0ea7      	lod	C, ML.7
    82a4:	a2d8 12c2 	add	A, 0x12c2 <.LASF1024+0x7>
    82a8:	4436      	lsr	Y

000082aa <.LVL59>:
    82aa:	e2e2      	add	Y, A
    82ac:	5ad8 12c6 	mov	0x12c6 <.LASF1024+0xb>, Y

000082b0 <.L95>:

	return next_state;
}
static tMotState motor_state_DCC(void)
{
	tMotState next_state = MOTION_DEC;
    82b0:	7004      	lod	A, #4
    82b2:	06e3      	jmp	0x807a <.L42>

000082b4 <.L49>:
    82b4:	7000      	lod	A, #0

000082b6 <.LBB83>:
}
static tMotState motor_state_PAUSE(void)
{
	tMotState next_state = MOTION_PAUSE;

	if (motor.initStatus)
    82b6:	7ed8 129e 	lod	X, 0x129e <.LLST31+0x2>
    82ba:	1904      	je	0x82c4 <.L72>

000082bc <.LM226>:
	{
		motor.initStatus = 0;
    82bc:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

000082c0 <.LM227>:
		motor.out.enable = 0;
    82c0:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

000082c4 <.L72>:
	}
	motor.out.duty = 0;
    82c4:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

000082c8 <.LM229>:
	if (motor.elapsedTime > 100u)
    82c8:	72d8 12a0 	lod	A, 0x12a0 <.LLST31+0x4>
    82cc:	ac64      	cmp	A, #100
    82ce:	1e01      	jug	0x82d2 <.L51>
    82d0:	07a7      	jmp	0x8220 <.L53>

000082d2 <.L51>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    82d2:	7ed8 129a 	lod	X, 0x129a <_motor>

000082d6 <.LM231>:
		motor.out.enable = 0;
	}
	motor.out.duty = 0;
	if (motor.elapsedTime > 100u)
	{
		next_state = MOTION_STOPPED;
    82d6:	7001      	lod	A, #1
    82d8:	06d5      	jmp	0x8084 <.L92>

000082da <.L40>:
{
	tMotState next_state = MOTION_STALL;

	if (motor.initStatus)
	{
		motor.initStatus = 0;
    82da:	5ed8 129e 	mov	0x129e <.LLST31+0x2>, X

000082de <.LM233>:
		motor.out.enable = 0;
    82de:	5ed8 12c4 	mov	0x12c4 <.LASF1024+0x9>, X
    82e2:	068b      	jmp	0x7ffa <.L41>

000082e4 <.L50>:
    82e4:	7000      	lod	A, #0

000082e6 <.LM234>:
}
static tMotState motor_state_FAULT(void)
{
	tMotState next_state = MOTION_FAULT;

	if (motor.initStatus)
    82e6:	7ed8 129e 	lod	X, 0x129e <.LLST31+0x2>
    82ea:	1904      	je	0x82f4 <.L73>

000082ec <.LM235>:
	{
		motor.initStatus = 0;
    82ec:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

000082f0 <.LM236>:
		motor.out.enable = 0;
    82f0:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

000082f4 <.L73>:
	}
	motor.out.duty = 0;
    82f4:	52d8 12c6 	mov	0x12c6 <.LASF1024+0xb>, A

000082f8 <.LM238>:
	if (motor.fault.flag == 0u)
    82f8:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    82fc:	1d02      	jne	0x8302 <.L97>

000082fe <.LM239>:
	{
		DIAGNOSTIC_Reset();
    82fe:	1274      	call	0x87e8 <_DIAGNOSTIC_Reset>
    8300:	0695      	jmp	0x802c <.L132>

00008302 <.L97>:

	return next_state;
}
static tMotState motor_state_FAULT(void)
{
	tMotState next_state = MOTION_FAULT;
    8302:	7007      	lod	A, #7
    8304:	06ba      	jmp	0x807a <.L42>

00008306 <.L78>:
			sensor.thd = 10;
			motor.stall.halfThd = 550;
			motor.stall.threshold = 650;
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.35);
		}
		else if (voltage <= 1050)
    8306:	7203      	lod	A, [S-4]
    8308:	aeda 041a 	cmp	A, #1050
    830c:	1e10      	jug	0x832e <.L80>

0000830e <.LM242>:
		{
			sensor.thd = 11;
    830e:	700b      	lod	A, #11
    8310:	52d8 1296 	mov	0x1296 <_sensor+0x8>, A

00008314 <.LM243>:
			motor.stall.halfThd = 600;
    8314:	72da 0258 	lod	A, #600
    8318:	0ea7      	lod	C, ML.7
    831a:	52d8 12d6 	mov	0x12d6 <.LASF2063+0x4>, A

0000831e <.LM244>:
			motor.stall.threshold = 700;
    831e:	72da 02bc 	lod	A, #700
    8322:	52d8 12d8 	mov	0x12d8 <.LASF1639>, A

00008326 <.LM245>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.32);
    8326:	0ea7      	lod	C, ML.7
    8328:	72da 028f 	lod	A, #655
    832c:	06dc      	jmp	0x80e6 <.L134>

0000832e <.L80>:
		}
		else if (voltage <= 1150)
    832e:	7203      	lod	A, [S-4]
    8330:	aeda 047e 	cmp	A, #1150
    8334:	1e10      	jug	0x8356 <.L81>

00008336 <.LM247>:
		{
			sensor.thd = 12;
    8336:	700c      	lod	A, #12
    8338:	52d8 1296 	mov	0x1296 <_sensor+0x8>, A

0000833c <.LM248>:
			motor.stall.halfThd = 650;
    833c:	72da 028a 	lod	A, #650
    8340:	0ea7      	lod	C, ML.7
    8342:	52d8 12d6 	mov	0x12d6 <.LASF2063+0x4>, A

00008346 <.LM249>:
			motor.stall.threshold = 750;
    8346:	72da 02ee 	lod	A, #750
    834a:	52d8 12d8 	mov	0x12d8 <.LASF1639>, A

0000834e <.LM250>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.29);
    834e:	0ea7      	lod	C, ML.7
    8350:	72da 0251 	lod	A, #593
    8354:	06c8      	jmp	0x80e6 <.L134>

00008356 <.L81>:
		}
		else if (voltage <= 1250)
    8356:	7203      	lod	A, [S-4]
    8358:	aeda 04e2 	cmp	A, #1250
    835c:	1e10      	jug	0x837e <.L82>

0000835e <.LM252>:
		{
			sensor.thd = 14;
    835e:	700e      	lod	A, #14
    8360:	52d8 1296 	mov	0x1296 <_sensor+0x8>, A

00008364 <.LM253>:
			motor.stall.halfThd = 700;
    8364:	72da 02bc 	lod	A, #700
    8368:	0ea7      	lod	C, ML.7
    836a:	52d8 12d6 	mov	0x12d6 <.LASF2063+0x4>, A

0000836e <.LM254>:
			motor.stall.threshold = 800;
    836e:	72da 0320 	lod	A, #800
    8372:	52d8 12d8 	mov	0x12d8 <.LASF1639>, A

00008376 <.LM255>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.25);
    8376:	0ea7      	lod	C, ML.7
    8378:	72da 0200 	lod	A, #512
    837c:	06b4      	jmp	0x80e6 <.L134>

0000837e <.L82>:
		}
		else if (voltage <= 1450)
    837e:	7203      	lod	A, [S-4]
    8380:	aeda 05aa 	cmp	A, #1450
    8384:	1e10      	jug	0x83a6 <.L83>

00008386 <.LM257>:
		{
			sensor.thd = 16;
    8386:	7010      	lod	A, #16
    8388:	52d8 1296 	mov	0x1296 <_sensor+0x8>, A

0000838c <.LM258>:
			motor.stall.halfThd = 800;
    838c:	72da 0320 	lod	A, #800
    8390:	0ea7      	lod	C, ML.7
    8392:	52d8 12d6 	mov	0x12d6 <.LASF2063+0x4>, A

00008396 <.LM259>:
			motor.stall.threshold = 900;
    8396:	72da 0384 	lod	A, #900
    839a:	52d8 12d8 	mov	0x12d8 <.LASF1639>, A

0000839e <.LM260>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.21);
    839e:	0ea7      	lod	C, ML.7
    83a0:	72da 01ae 	lod	A, #430
    83a4:	06a0      	jmp	0x80e6 <.L134>

000083a6 <.L83>:
		}
		else
		{
			sensor.thd = 17;
    83a6:	7011      	lod	A, #17
    83a8:	52d8 1296 	mov	0x1296 <_sensor+0x8>, A

000083ac <.LM262>:
			motor.stall.halfThd = 900;
    83ac:	72da 0384 	lod	A, #900
    83b0:	0ea7      	lod	C, ML.7
    83b2:	52d8 12d6 	mov	0x12d6 <.LASF2063+0x4>, A

000083b6 <.LM263>:
			motor.stall.threshold = 1000;
    83b6:	72da 03e8 	lod	A, #1000
    83ba:	52d8 12d8 	mov	0x12d8 <.LASF1639>, A

000083be <.LM264>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.18);
    83be:	0ea7      	lod	C, ML.7
    83c0:	72da 0170 	lod	A, #368
    83c4:	0690      	jmp	0x80e6 <.L134>

000083c6 <.L75>:
		}
	}
	else
	{
		sensor.delay = 50;
    83c6:	7eda 0a32 	lod	X, #2610
    83ca:	5ed8 1290 	mov	0x1290 <_sensor+0x2>, X

000083ce <.LM266>:
		sensor.filterPeriod = 10;
    83ce:	42d8 1292 	mov	0x1292 <_sensor+0x4>, AL

000083d2 <.LM267>:
		sensor.filterCnt = 0;
		sensor.delta = 0;
    83d2:	0ea7      	lod	C, ML.7
    83d4:	52d8 1294 	mov	0x1294 <_sensor+0x6>, A

000083d8 <.LM268>:
		sensor.moving = C_STATUS_OFF_;
    83d8:	52d8 128e 	mov	0x128e <_sensor>, A

000083dc <.LM269>:
		sensor.lastDeg = motor.pos.current;
    83dc:	72d8 12ae 	lod	A, 0x12ae <.LASF1845+0x5>
    83e0:	0ea7      	lod	C, ML.7
    83e2:	52d8 1298 	mov	0x1298 <_sensor+0xa>, A
    83e6:	0681      	jmp	0x80ea <.L79>

000083e8 <.L86>:
		{
			sensor.delta = motor.pos.current - sensor.lastDeg;
		}
		else
		{
			sensor.delta = sensor.lastDeg - motor.pos.current;
    83e8:	aaee      	sub	A, X
    83ea:	0692      	jmp	0x8110 <.L135>

000083ec <.L88>:
			if (sensor.filterCnt < 3)
				sensor.filterCnt++;
		}
		else
		{
			if (sensor.filterCnt > -3)
    83ec:	acfe      	cmp	A, #-2
    83ee:	1e81      	jsge	0x83f2 <.LM272>
    83f0:	06a1      	jmp	0x8134 <.L89>

000083f2 <.LM272>:
				sensor.filterCnt--;
    83f2:	80ff      	add	AL, #-1
    83f4:	069d      	jmp	0x8130 <.L136>

000083f6 <.L90>:
		}
		if (sensor.filterCnt >= 2)
		{
			sensor.moving = C_STATUS_RUN;
		}
		else if (sensor.filterCnt <= -2)
    83f6:	acff      	cmp	A, #-1
    83f8:	1e8a      	jsge	0x840e <.L38>

000083fa <.LM274>:
		{

			sensor.moving = C_STATUS_STOP;
    83fa:	7002      	lod	A, #2
    83fc:	06a4      	jmp	0x8146 <.L137>

000083fe <.L63>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    83fe:	7ed8 129a 	lod	X, 0x129a <_motor>

00008402 <.LM276>:
					next_state = MOTION_DEC;
				}
			}
			else
			{
				next_state = MOTION_RUNNING;
    8402:	7003      	lod	A, #3
    8404:	063f      	jmp	0x8084 <.L92>

00008406 <.L65>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    8406:	7ed8 129a 	lod	X, 0x129a <_motor>

0000840a <.LM278>:

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
	{
		next_state = MOTION_PAUSE;
    840a:	7005      	lod	A, #5
    840c:	063b      	jmp	0x8084 <.L92>

0000840e <.L38>:
		}
		else
		{
		}
	}
}
    840e:	5405      	ret	#6

00008410 <_motor_ctrl_handler>:

/* called by every 100us */
void motor_ctrl_handler(void)
{
    8410:	5807      	inc	S, #8

00008412 <.LCFI3>:
	uint16_t diff;

	adc_raw_update();
    8412:	82db 3cf2 	callf	0x79e4 <_adc_raw_update>

00008416 <.LM282>:
	motor.pos.current = calculate_gmr_angle();
    8416:	82db 3d7f 	callf	0x7afe <_calculate_gmr_angle>
    841a:	52d8 12ae 	mov	0x12ae <.LASF1845+0x5>, A

0000841e <.LM283>:

	motor.pos.Delta = (int16_t)(motor.pos.target - motor.pos.current);
    841e:	7ed8 12b0 	lod	X, 0x12b0 <.LLST32+0x1>
    8422:	2ae2      	sub	X, A
    8424:	72ee      	lod	A, X
    8426:	5ed8 12b4 	mov	0x12b4 <.LLST32+0x5>, X

0000842a <.LM284>:
	if (motor.pos.Delta >= 0)
	{
		diff = motor.pos.Delta;
    842a:	ac00      	cmp	A, #0
    842c:	1d81      	jnn	0x8430 <.L207>
    842e:	5cc2      	neg	A

00008430 <.L207>:
	else
	{
		diff = -motor.pos.Delta;
	}

	if (diff <= (int16_t)C_MOT_OFF_HYSTERISYS)
    8430:	ac03      	cmp	A, #3
    8432:	1e08      	jug	0x8444 <.L144>

00008434 <.LM286>:
	{
		motor.out.enable = 0;
    8434:	7000      	lod	A, #0

00008436 <.LVL73>:
    8436:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

0000843a <.LM287>:
		motor.pos.posReached = 1;
		motor.pos.newTarget = 0;
    843a:	72da 0100 	lod	A, #256
    843e:	0ea7      	lod	C, ML.7
    8440:	52d8 12b6 	mov	0x12b6 <.LLST32+0x7>, A

00008444 <.L144>:
	else
	{
	}

	/* motor stall diagnostics */
	if (motor.out.enable)
    8444:	72d8 12c4 	lod	A, 0x12c4 <.LASF1024+0x9>
    8448:	1d01      	jne	0x844c <.LBB119>
    844a:	0109      	jmp	0x865e <.L145>

0000844c <.LBB119>:
 *
 * \return fault flag
 */
static void MotorStallDiag(void) /*100usec */
{
	uint16_t current = get_valve_motCurrent();
    844c:	82db 353d 	callf	0x6a7a <_get_valve_motCurrent>
    8450:	7ae2      	lod	Y, A

00008452 <.LM290>:

	if (motor.stall.maskTimer >= STALL_DETECT_TIMEOUT) /*100msec*/
    8452:	72d8 12d2 	lod	A, 0x12d2 <.LASF2063>

00008456 <.LVL76>:
    8456:	ac09      	cmp	A, #9
    8458:	1e01      	jug	0x845c <.LVL76+0x6>
    845a:	00fa      	jmp	0x8650 <.L146>
    845c:	72d8 12da 	lod	A, 0x12da <.LASF1639+0x2>

00008460 <.LM291>:
	{
		
		if (((current >= motor.stall.halfThd) && (current < motor.stall.threshold)) && (sensor.delta < sensor.thd) && (sensor.delta > 3))
    8460:	eed8 12d6 	cmp	Y, 0x12d6 <.LASF2063+0x4>
    8464:	1c01      	jnc	0x8468 <.LASF2083+0x5>
    8466:	00e5      	jmp	0x8632 <.L147>
    8468:	eed8 12d8 	cmp	Y, 0x12d8 <.LASF1639>
    846c:	1801      	jc	0x8470 <.LASF2083+0xd>
    846e:	00e1      	jmp	0x8632 <.L147>
    8470:	7ed8 1294 	lod	X, 0x1294 <_sensor+0x6>
    8474:	2ed8 1296 	cmp	X, 0x1296 <_sensor+0x8>
    8478:	1a81      	jsl	0x847c <.LASF2113+0x3>
    847a:	00db      	jmp	0x8632 <.L147>
    847c:	2c03      	cmp	X, #3
    847e:	1f01      	jsg	0x8482 <.LM292>
    8480:	00d8      	jmp	0x8632 <.L147>

00008482 <.LM292>:
		{
			motor.stall.obstrCnt += 1;
    8482:	a001      	add	A, #1

00008484 <.L204>:
		}
		else
		{
			if (motor.stall.obstrCnt > 0)
			{
				motor.stall.obstrCnt -= 1;
    8484:	52d8 12da 	mov	0x12da <.LASF1639+0x2>, A

00008488 <.L148>:
			{
				clear_fail_safe_retry_cnt(MOT_ABSTALL_ERROR);
			}
		}

		if (motor.stall.obstrCnt >= 500u)	//50ms
    8488:	72d8 12da 	lod	A, 0x12da <.LASF1639+0x2>
    848c:	aeda 01f3 	cmp	A, #499
    8490:	1a1b      	jule	0x84c8 <.L151>

00008492 <.LM295>:
		{
			if (get_valve_mode() != VALVE_CALIBRATION)
    8492:	5a03      	mov	[S-4], Y
    8494:	82db 3534 	callf	0x6a68 <_get_valve_mode>
    8498:	7a03      	lod	Y, [S-4]
    849a:	ac05      	cmp	A, #5
    849c:	1915      	je	0x84c8 <.L151>

0000849e <.LM296>:
			{
				motor.stall.flag |= STALL_MASK_TEMPORARY;
    849e:	62d8 12d0 	lod	AL, 0x12d0 <.LASF2051+0x4>
    84a2:	8401      	or	AL, #1
    84a4:	42d8 12d0 	mov	0x12d0 <.LASF2051+0x4>, AL

000084a8 <.LM297>:

				u16EventState = MOT_ABSTALL_ERROR;
    84a8:	7005      	lod	A, #5
    84aa:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000084ae <.LM298>:
				u16EventValue = (uint16_t)(current >> 3);
				u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    84ae:	0ea7      	lod	C, ML.7
    84b0:	72d8 12a0 	lod	A, 0x12a0 <.LLST31+0x4>
    84b4:	9400      	and	AL, #0
    84b6:	5201      	mov	[S-2], A

000084b8 <.LM299>:
			if (get_valve_mode() != VALVE_CALIBRATION)
			{
				motor.stall.flag |= STALL_MASK_TEMPORARY;

				u16EventState = MOT_ABSTALL_ERROR;
				u16EventValue = (uint16_t)(current >> 3);
    84b8:	72e6      	lod	A, Y
    84ba:	44b2      	lsr	A, #2
    84bc:	4432      	lsr	A
    84be:	7ee2      	lod	X, A

000084c0 <.LM300>:
				u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    84c0:	7201      	lod	A, [S-2]
    84c2:	a6ee      	or	A, X
    84c4:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000084c8 <.L151>:
    84c8:	72d8 12d4 	lod	A, 0x12d4 <.LASF2063+0x2>

000084cc <.LM301>:
			}
		}

		if ((current >= motor.stall.threshold) && (sensor.moving == C_STATUS_STOP))
    84cc:	eed8 12d8 	cmp	Y, 0x12d8 <.LASF1639>
    84d0:	1c01      	jnc	0x84d4 <.LM301+0x8>
    84d2:	00b9      	jmp	0x8646 <.L153>
    84d4:	7ed8 128e 	lod	X, 0x128e <_sensor>
    84d8:	2c02      	cmp	X, #2
    84da:	1901      	je	0x84de <.LM302>
    84dc:	00b4      	jmp	0x8646 <.L153>

000084de <.LM302>:
		{

			motor.stall.stallCnt += 1;
    84de:	a001      	add	A, #1

000084e0 <.L205>:
		}
		else
		{

			if (motor.stall.stallCnt > 0)
				motor.stall.stallCnt -= 1;
    84e0:	52d8 12d4 	mov	0x12d4 <.LASF2063+0x2>, A

000084e4 <.L154>:
		}
		if (motor.stall.stallCnt >= 5000u)
    84e4:	72d8 12d4 	lod	A, 0x12d4 <.LASF2063+0x2>
    84e8:	aeda 1387 	cmp	A, #4999
    84ec:	1a14      	jule	0x8516 <.L155>

000084ee <.LM305>:
		{
			motor.stall.flag |= STALL_MASK_PERMENT;
    84ee:	62d8 12d0 	lod	AL, 0x12d0 <.LASF2051+0x4>
    84f2:	8402      	or	AL, #2
    84f4:	42d8 12d0 	mov	0x12d0 <.LASF2051+0x4>, AL

000084f8 <.LM306>:
			motor.stall.stallCnt = 0;
    84f8:	7000      	lod	A, #0
    84fa:	52d8 12d4 	mov	0x12d4 <.LASF2063+0x2>, A

000084fe <.LM307>:
			u16EventState = MOT_STALL_FAULT;
    84fe:	0ea7      	lod	C, ML.7
    8500:	700a      	lod	A, #10
    8502:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00008506 <.LM308>:
			u16EventValue = (uint16_t)(current >> 3);
			u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    8506:	72d8 12a0 	lod	A, 0x12a0 <.LLST31+0x4>
    850a:	9400      	and	AL, #0

0000850c <.LM309>:
		if (motor.stall.stallCnt >= 5000u)
		{
			motor.stall.flag |= STALL_MASK_PERMENT;
			motor.stall.stallCnt = 0;
			u16EventState = MOT_STALL_FAULT;
			u16EventValue = (uint16_t)(current >> 3);
    850c:	44b6      	lsr	Y, #2
    850e:	4436      	lsr	Y

00008510 <.LM310>:
			u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    8510:	e6e2      	or	Y, A
    8512:	5ad8 10b4 	mov	0x10b4 <_u16EventValue>, Y

00008516 <.L155>:
	}
	else
	{
		motor.stall.maskTimer = 0;
	}
	if (motor.stall.flag != 0u)
    8516:	7ada 129a 	lod	Y, #4762
    851a:	62d8 12d0 	lod	AL, 0x12d0 <.LASF2051+0x4>
    851e:	1911      	je	0x8542 <.L157>

00008520 <.LM312>:
	{
		motor.out.enable = 0;
    8520:	7c00      	lod	X, #0
    8522:	5ed8 12c4 	mov	0x12c4 <.LASF1024+0x9>, X

00008526 <.LM313>:
		if (motor.state != MOTION_STALL)
    8526:	72f0      	lod	A, [Y]
    8528:	5201      	mov	[S-2], A
    852a:	ac06      	cmp	A, #6
    852c:	190a      	je	0x8542 <.L157>

0000852e <.LM314>:
		{
			motor.initStatus = 1u;
    852e:	7001      	lod	A, #1
    8530:	52d8 129e 	mov	0x129e <.LLST31+0x2>, A

00008534 <.LM315>:
			motor.elapsedTime = 0;
    8534:	5ed8 12a0 	mov	0x12a0 <.LLST31+0x4>, X

00008538 <.LM316>:
			motor.lastState = motor.state;
    8538:	7201      	lod	A, [S-2]
    853a:	52d8 129c 	mov	0x129c <.LLST31>, A

0000853e <.LM317>:
			motor.state = MOTION_STALL;
    853e:	7006      	lod	A, #6
    8540:	52f0      	mov	[Y], A

00008542 <.L157>:


static void MotorFaultDiag(void)
{
#if OVER_CURRENT_TEST	
	uint16_t current = get_valve_motCurrent();
    8542:	82db 353d 	callf	0x6a7a <_get_valve_motCurrent>
    8546:	7ee2      	lod	X, A

00008548 <.LM319>:
	{
		current = get_valve_motCurrent();
	}
#endif
	/* open check */
	if (motor.state == MOTION_RUNNING)
    8548:	72d8 129a 	lod	A, 0x129a <_motor>

0000854c <.LVL81>:
    854c:	ac03      	cmp	A, #3
    854e:	1901      	je	0x8552 <.LM320>
    8550:	008f      	jmp	0x8670 <.L164>

00008552 <.LM320>:
	{
		if (!(motor.fault.flag & FAULT_MASK_PHASE_A_OPEN))
    8552:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    8556:	4206      	mov	[S-7], AL
    8558:	9401      	and	AL, #1
    855a:	1901      	je	0x855e <.LM321>
    855c:	0089      	jmp	0x8670 <.L164>

0000855e <.LM321>:
		{
			if (!motor.fault.openDetectCheck)
    855e:	62d8 12e4 	lod	AL, 0x12e4 <.LLST33+0x1>
    8562:	1901      	je	0x8566 <.LASF1016+0x1>
    8564:	007f      	jmp	0x8664 <.L160>
    8566:	66e0      	lod	YL, AL
    8568:	5cf6      	usex	Y

0000856a <.LM322>:
			{
				if ((current <= OPEN_DETECT_CURRENT) && (sensor.moving == C_STATUS_STOP))
    856a:	2c14      	cmp	X, #20
    856c:	1a01      	jule	0x8570 <.LM322+0x6>
    856e:	0083      	jmp	0x8676 <.L206>
    8570:	72d8 128e 	lod	A, 0x128e <_sensor>
    8574:	ac02      	cmp	A, #2
    8576:	1901      	je	0x857a <.LBB124>
    8578:	007e      	jmp	0x8676 <.L206>

0000857a <.LBB124>:
void setFaultDetect(uint8_t tFault, uint8_t tDetectCheck, uint8_t tDetectCnt)
{
	switch (tFault)
	{
	case FAULT_OPEN :
		motor.fault.openDetectCheck = tDetectCheck;
    857a:	6001      	lod	AL, #1
    857c:	42d8 12e4 	mov	0x12e4 <.LLST33+0x1>, AL

00008580 <.LM324>:
		motor.fault.openDetectCnt = tDetectCnt;
    8580:	5ad8 12e6 	mov	0x12e6 <.LLST33+0x3>, Y

00008584 <.L162>:
	{
		setFaultDetect(FAULT_OPEN, CLEAR, CLEAR);
	}

	/* overcurrent check */
	if (motor.out.enable)
    8584:	72d8 12c4 	lod	A, 0x12c4 <.LASF1024+0x9>
    8588:	1d01      	jne	0x858c <.LASF1274+0x2>
    858a:	00a4      	jmp	0x86d4 <.L171>
    858c:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    8590:	4207      	mov	[S-8], AL

00008592 <.LM326>:
	{
		if (!(motor.fault.flag & FAULT_MASK_OVER_CURRENT))
    8592:	9440      	and	AL, #64
    8594:	1901      	je	0x8598 <.LM327>
    8596:	00c1      	jmp	0x871a <.L166>

00008598 <.LM327>:
		{
			if (!motor.fault.ocDetectCheck)
    8598:	62d8 12e0 	lod	AL, 0x12e0 <.LASF1639+0x8>
    859c:	4206      	mov	[S-7], AL
    859e:	1901      	je	0x85a2 <.LASF2124+0x5>
    85a0:	0096      	jmp	0x86ce <.L167>
    85a2:	66e0      	lod	YL, AL
    85a4:	5cf6      	usex	Y

000085a6 <.LM328>:
			{
				if(current >= OVER_CURRNET_DETECT_CURRENT)	
    85a6:	2eda 05db 	cmp	X, #1499
    85aa:	1e01      	jug	0x85ae <.LBB126>
    85ac:	0083      	jmp	0x86b4 <.L168>

000085ae <.LBB126>:
		motor.fault.openDetectCheck = tDetectCheck;
		motor.fault.openDetectCnt = tDetectCnt;
		break;

	case FAULT_OC :
		motor.fault.ocDetectCheck = tDetectCheck;
    85ae:	6001      	lod	AL, #1
    85b0:	42d8 12e0 	mov	0x12e0 <.LASF1639+0x8>, AL

000085b4 <.LM330>:
		motor.fault.ocDetectCnt = tDetectCnt;
    85b4:	5ad8 12e2 	mov	0x12e2 <.LASF1639+0xa>, Y

000085b8 <.L169>:
	{
		setFaultDetect(FAULT_OC, CLEAR, CLEAR);
	}

	/* short/oc check */
	if (g_e8ShortOcc == C_ERR_SHORT_VDS)
    85b8:	72d8 11d4 	lod	A, 0x11d4 <_g_e8ShortOcc>
    85bc:	ac02      	cmp	A, #2
    85be:	1d13      	jne	0x85e6 <.L172>

000085c0 <.LM332>:
	{
		motor.fault.flag |= FAULT_MASK_PHASE_A_SHORT;
    85c0:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    85c4:	8410      	or	AL, #16
    85c6:	42d8 12dc 	mov	0x12dc <.LASF1639+0x4>, AL

000085ca <.LM333>:

		u16EventState = MOT_SHORT_FAULT;
    85ca:	700b      	lod	A, #11
    85cc:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000085d0 <.LM334>:
		u16EventValue = (uint16_t)(current >> 3);
		u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    85d0:	0ea7      	lod	C, ML.7
    85d2:	7ad8 12a0 	lod	Y, 0x12a0 <.LLST31+0x4>
    85d6:	f6da ff00 	and	Y, #65280

000085da <.LM335>:
	if (g_e8ShortOcc == C_ERR_SHORT_VDS)
	{
		motor.fault.flag |= FAULT_MASK_PHASE_A_SHORT;

		u16EventState = MOT_SHORT_FAULT;
		u16EventValue = (uint16_t)(current >> 3);
    85da:	72ee      	lod	A, X
    85dc:	44b2      	lsr	A, #2
    85de:	4432      	lsr	A

000085e0 <.LM336>:
		u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    85e0:	a6e6      	or	A, Y
    85e2:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000085e6 <.L172>:
			motor.state = MOTION_STALL;
		}
	}
	/* motor fault diagnostics */
	MotorFaultDiag();
	if (motor.fault.flag != 0)
    85e6:	7ada 129a 	lod	Y, #4762
    85ea:	62d8 12dc 	lod	AL, 0x12dc <.LASF1639+0x4>
    85ee:	1914      	je	0x8618 <.L173>

000085f0 <.LM338>:
	{
		motor.holdTime = 0;
    85f0:	7000      	lod	A, #0
    85f2:	52d8 12ac 	mov	0x12ac <.LASF1845+0x3>, A

000085f6 <.LM339>:
		motor.out.enable = 0;
    85f6:	52d8 12c4 	mov	0x12c4 <.LASF1024+0x9>, A

000085fa <.LM340>:
		if (motor.state != MOTION_FAULT)
    85fa:	7ef0      	lod	X, [Y]
    85fc:	5e01      	mov	[S-2], X
    85fe:	2c07      	cmp	X, #7
    8600:	1d01      	jne	0x8604 <.LM341>
    8602:	0093      	jmp	0x872a <.L174>

00008604 <.LM341>:
		{
			motor.initStatus = 1u;
    8604:	7c01      	lod	X, #1
    8606:	5ed8 129e 	mov	0x129e <.LLST31+0x2>, X

0000860a <.LM342>:
			motor.elapsedTime = 0;
    860a:	52d8 12a0 	mov	0x12a0 <.LLST31+0x4>, A

0000860e <.LM343>:
			motor.lastState = motor.state;
    860e:	7201      	lod	A, [S-2]
    8610:	52d8 129c 	mov	0x129c <.LLST31>, A

00008614 <.LM344>:
			motor.state = MOTION_FAULT;
    8614:	7007      	lod	A, #7
    8616:	52f0      	mov	[Y], A

00008618 <.L173>:
		}
	}

	if (motor.out.enable)
    8618:	72d8 12c4 	lod	A, 0x12c4 <.LASF1024+0x9>
    861c:	1d01      	jne	0x8620 <.LM346>
    861e:	0085      	jmp	0x872a <.L174>

00008620 <.LM346>:
	{
		/* 16384 = 0% */
		pwm_SetDutyCycle(motor.direction, motor.out.duty);
    8620:	72d8 12a6 	lod	A, 0x12a6 <.LLST31+0xa>
    8624:	5cf2      	usex	A
    8626:	7ed8 12c6 	lod	X, 0x12c6 <.LASF1024+0xb>
    862a:	5edf      	push	X

0000862c <.LCFI4>:
    862c:	82db 4e72 	callf	0x9ce4 <_pwm_SetDutyCycle>

00008630 <.LCFI5>:
    8630:	540b      	ret	#12

00008632 <.L147>:
		{
			motor.stall.obstrCnt += 1;
		}
		else
		{
			if (motor.stall.obstrCnt > 0)
    8632:	ac00      	cmp	A, #0
    8634:	1902      	je	0x863a <.L149>

00008636 <.LM348>:
			{
				motor.stall.obstrCnt -= 1;
    8636:	a0ff      	add	A, #-1
    8638:	0725      	jmp	0x8484 <.L204>

0000863a <.L149>:
			}
			else
			{
				clear_fail_safe_retry_cnt(MOT_ABSTALL_ERROR);
    863a:	7005      	lod	A, #5
    863c:	5a03      	mov	[S-4], Y
    863e:	82db 325a 	callf	0x64b4 <_clear_fail_safe_retry_cnt>

00008642 <.LVL88>:
    8642:	7a03      	lod	Y, [S-4]
    8644:	0721      	jmp	0x8488 <.L148>

00008646 <.L153>:
			motor.stall.stallCnt += 1;
		}
		else
		{

			if (motor.stall.stallCnt > 0)
    8646:	ac00      	cmp	A, #0
    8648:	1d01      	jne	0x864c <.LM351>
    864a:	074c      	jmp	0x84e4 <.L154>

0000864c <.LM351>:
				motor.stall.stallCnt -= 1;
    864c:	a0ff      	add	A, #-1
    864e:	0748      	jmp	0x84e0 <.L205>

00008650 <.L146>:
			u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
		}
	}
	else
	{
		motor.stall.stallCnt = 0;
    8650:	7000      	lod	A, #0
    8652:	52d8 12d4 	mov	0x12d4 <.LASF2063+0x2>, A

00008656 <.LM353>:
		motor.stall.obstrCnt = 0;
    8656:	52d8 12da 	mov	0x12da <.LASF1639+0x2>, A
    865a:	0ea7      	lod	C, ML.7
    865c:	075c      	jmp	0x8516 <.L155>

0000865e <.L145>:
	{
		MotorStallDiag();
	}
	else
	{
		motor.stall.maskTimer = 0;
    865e:	52d8 12d2 	mov	0x12d2 <.LASF2063>, A
    8662:	0759      	jmp	0x8516 <.L155>

00008664 <.L160>:
					setFaultDetect(FAULT_OPEN, CLEAR, CLEAR);
				}
			}
			else
			{
				if ((current > OPEN_DETECT_CURRENT) || (sensor.moving != C_STATUS_STOP))
    8664:	2c14      	cmp	X, #20
    8666:	1e04      	jug	0x8670 <.L164>
    8668:	72d8 128e 	lod	A, 0x128e <_sensor>
    866c:	ac02      	cmp	A, #2
    866e:	1907      	je	0x867e <.L163>

00008670 <.L164>:
void setFaultDetect(uint8_t tFault, uint8_t tDetectCheck, uint8_t tDetectCnt)
{
	switch (tFault)
	{
	case FAULT_OPEN :
		motor.fault.openDetectCheck = tDetectCheck;
    8670:	6000      	lod	AL, #0
    8672:	42d8 12e4 	mov	0x12e4 <.LLST33+0x1>, AL

00008676 <.L206>:
		motor.fault.openDetectCnt = tDetectCnt;
    8676:	7000      	lod	A, #0
    8678:	52d8 12e6 	mov	0x12e6 <.LLST33+0x3>, A
    867c:	0783      	jmp	0x8584 <.L162>

0000867e <.L163>:
				{
					setFaultDetect(FAULT_OPEN, CLEAR, CLEAR);
				}
				else
				{
					if (motor.fault.openDetectCnt >= OPEN_DETECT_TIMEOUT)
    867e:	72d8 12e6 	lod	A, 0x12e6 <.LLST33+0x3>
    8682:	aeda 01f3 	cmp	A, #499
    8686:	1e01      	jug	0x868a <.LM359>
    8688:	077d      	jmp	0x8584 <.L162>

0000868a <.LM359>:
					{
						if (motor.fault.openEnable)
    868a:	62d8 12de 	lod	AL, 0x12de <.LASF1639+0x6>
    868e:	1970      	je	0x8670 <.L164>

00008690 <.LM360>:
						{
							motor.fault.flag |= FAULT_MASK_PHASE_A_OPEN;
    8690:	6206      	lod	AL, [S-7]
    8692:	8401      	or	AL, #1
    8694:	42d8 12dc 	mov	0x12dc <.LASF1639+0x4>, AL

00008698 <.LM361>:
							u16EventState = MOT_OPEN_FAULT;
    8698:	700c      	lod	A, #12
    869a:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000869e <.LM362>:
							u16EventValue = (uint16_t)(current >> 3);
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    869e:	0ea7      	lod	C, ML.7
    86a0:	72d8 12a0 	lod	A, 0x12a0 <.LLST31+0x4>
    86a4:	9400      	and	AL, #0

000086a6 <.LM363>:
					{
						if (motor.fault.openEnable)
						{
							motor.fault.flag |= FAULT_MASK_PHASE_A_OPEN;
							u16EventState = MOT_OPEN_FAULT;
							u16EventValue = (uint16_t)(current >> 3);
    86a6:	7aee      	lod	Y, X
    86a8:	44b6      	lsr	Y, #2
    86aa:	4436      	lsr	Y

000086ac <.LM364>:
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    86ac:	a6e6      	or	A, Y
    86ae:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A
    86b2:	07de      	jmp	0x8670 <.L164>

000086b4 <.L168>:
				{
					setFaultDetect(FAULT_OC, SET, CLEAR);
				}
				else
				{
					clear_fail_safe_retry_cnt(MOT_OC_ERROR);
    86b4:	7004      	lod	A, #4
    86b6:	5a03      	mov	[S-4], Y
    86b8:	5e05      	mov	[S-6], X
    86ba:	82db 325a 	callf	0x64b4 <_clear_fail_safe_retry_cnt>

000086be <.LBB130>:
		motor.fault.openDetectCheck = tDetectCheck;
		motor.fault.openDetectCnt = tDetectCnt;
		break;

	case FAULT_OC :
		motor.fault.ocDetectCheck = tDetectCheck;
    86be:	6206      	lod	AL, [S-7]
    86c0:	42d8 12e0 	mov	0x12e0 <.LASF1639+0x8>, AL

000086c4 <.LM367>:
		motor.fault.ocDetectCnt = tDetectCnt;
    86c4:	7a03      	lod	Y, [S-4]
    86c6:	5ad8 12e2 	mov	0x12e2 <.LASF1639+0xa>, Y
    86ca:	7e05      	lod	X, [S-6]
    86cc:	0775      	jmp	0x85b8 <.L169>

000086ce <.L167>:
					setFaultDetect(FAULT_OC, CLEAR, CLEAR);
				}
			}
			else
			{
				if(current < OVER_CURRNET_DETECT_CURRENT)
    86ce:	2eda 05db 	cmp	X, #1499
    86d2:	1e08      	jug	0x86e4 <.L170>

000086d4 <.L171>:
		motor.fault.openDetectCheck = tDetectCheck;
		motor.fault.openDetectCnt = tDetectCnt;
		break;

	case FAULT_OC :
		motor.fault.ocDetectCheck = tDetectCheck;
    86d4:	6000      	lod	AL, #0
    86d6:	42d8 12e0 	mov	0x12e0 <.LASF1639+0x8>, AL

000086da <.LM370>:
		motor.fault.ocDetectCnt = tDetectCnt;
    86da:	7000      	lod	A, #0
    86dc:	0ea7      	lod	C, ML.7
    86de:	52d8 12e2 	mov	0x12e2 <.LASF1639+0xa>, A
    86e2:	076a      	jmp	0x85b8 <.L169>

000086e4 <.L170>:
				{
					setFaultDetect(FAULT_OC, CLEAR, CLEAR);
				}
				else
				{
					if (motor.fault.ocDetectCnt >= OVER_CURRNET_DETECT_TIMEOUT)
    86e4:	72d8 12e2 	lod	A, 0x12e2 <.LASF1639+0xa>
    86e8:	aeda 012b 	cmp	A, #299
    86ec:	1e01      	jug	0x86f0 <.LM372>
    86ee:	0764      	jmp	0x85b8 <.L169>

000086f0 <.LM372>:
					{
						if(motor.fault.ocEnable)
    86f0:	62d8 12dd 	lod	AL, 0x12dd <.LASF1639+0x5>
    86f4:	196f      	je	0x86d4 <.L171>

000086f6 <.LM373>:
						{
							motor.fault.flag |= FAULT_MASK_OVER_CURRENT;
    86f6:	6207      	lod	AL, [S-8]
    86f8:	8440      	or	AL, #64
    86fa:	42d8 12dc 	mov	0x12dc <.LASF1639+0x4>, AL

000086fe <.LM374>:
							u16EventState = MOT_OC_ERROR;
    86fe:	7004      	lod	A, #4
    8700:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00008704 <.LM375>:
							u16EventValue = (uint16_t)(current >> 3);
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    8704:	0ea7      	lod	C, ML.7
    8706:	72d8 12a0 	lod	A, 0x12a0 <.LLST31+0x4>
    870a:	9400      	and	AL, #0

0000870c <.LM376>:
					{
						if(motor.fault.ocEnable)
						{
							motor.fault.flag |= FAULT_MASK_OVER_CURRENT;
							u16EventState = MOT_OC_ERROR;
							u16EventValue = (uint16_t)(current >> 3);
    870c:	7aee      	lod	Y, X
    870e:	44b6      	lsr	Y, #2
    8710:	4436      	lsr	Y

00008712 <.LM377>:
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    8712:	a6e6      	or	A, Y
    8714:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A
    8718:	07dd      	jmp	0x86d4 <.L171>

0000871a <.L166>:
				}
			}
		}
		else
		{
			if(current <= OVER_CURRNET_DETECT_CURRENT)	
    871a:	2eda 05dc 	cmp	X, #1500
    871e:	1e5a      	jug	0x86d4 <.L171>

00008720 <.LM379>:
			{
				motor.fault.flag &= ~FAULT_MASK_OVER_CURRENT;
    8720:	6207      	lod	AL, [S-8]
    8722:	94bf      	and	AL, #-65
    8724:	42d8 12dc 	mov	0x12dc <.LASF1639+0x4>, AL
    8728:	07d5      	jmp	0x86d4 <.L171>

0000872a <.L174>:
		/* 16384 = 0% */
		pwm_SetDutyCycle(motor.direction, motor.out.duty);
	}
	else
	{
		if (motor.elapsedTime >= 1000u)
    872a:	72d8 12a0 	lod	A, 0x12a0 <.LLST31+0x4>
    872e:	aeda 03e7 	cmp	A, #999
    8732:	1a03      	jule	0x873a <.L176>

00008734 <.LM381>:
		{
			pwm_Off();
    8734:	82db 4eac 	callf	0x9d58 <_pwm_Off>
    8738:	5409      	ret	#10

0000873a <.L176>:
		}
		else
		{
			pwm_Stop();
    873a:	82db 4e9c 	callf	0x9d38 <_pwm_Stop>

0000873e <.LM383>:
		}
	}
}
    873e:	5409      	ret	#10

00008740 <_diagnostic_Init>:
void diagnostic_Init(void)
{
    /* Disable hardware protection for over-temperature, under-voltage
     * Hardware protection is enabled in case of OC, VDS(LS), VDS(HS), OV_VS, OVT
     */
    IO_SET(PORT_DRV1_PROT, DIS_UV_VDDA, 1u, DIS_UV_VDDAF, 1u, DIS_UV_VS, 1u);
    8740:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    8744:	a6da 02a0 	or	A, #672
    8748:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

0000874c <.LM5>:

    /*
     * Connect the phase to GND in case of VDS(HS),
     */
    IO_SET(PORT_DRV1_PROT,
    874c:	0ea7      	lod	C, ML.7
    874e:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    8752:	b6da abfa 	and	A, #44026
    8756:	c404      	or	AH, #4
    8758:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

0000875c <.LM6>:
           0, /* high */
           OC_PM,
           PROTECTION_MODE_TRISTATE);

    /* Set/enable UV & OV debounce circuitry */
    IO_SET(PORT_SUPP_CFG, UV_VS_FILT_SEL, 1u); /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    875c:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    8760:	8408      	or	AL, #8
    8762:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00008766 <.LM7>:
    IO_SET(PORT_SUPP_CFG, OV_VS_FILT_SEL, 1u); /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    8766:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    876a:	8410      	or	AL, #16
    876c:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00008770 <.LM8>:

    /* Under/Over voltage detection levels */
    IO_SET(PORT_MISC_OUT, PRUV_VS, vsuv6V);
    8770:	72d8 01f2 	lod	A, 0x1f2 <_PORT_MISC_OUT>
    8774:	b6da fe3f 	and	A, #65087
    8778:	8480      	or	AL, #-128
    877a:	52d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, A

0000877e <.LM9>:
    //    IO_SET(PORT_MISC_OUT, PRUV_VS, vsuv9V);
    //    IO_SET(PORT_MISC_OUT, PROV_VS, vsov22V);
    IO_SET(PORT_MISC_OUT, PROV_VS, vsov24V);
    877e:	62d8 01f3 	lod	AL, 0x1f3 <_PORT_MISC_OUT+0x1>
    8782:	94f9      	and	AL, #-7
    8784:	8402      	or	AL, #2
    8786:	42d8 01f3 	mov	0x1f3 <_PORT_MISC_OUT+0x1>, AL

0000878a <.LM10>:

    uint16_t u16trim_high = EE_GET(TRIM_CSA_CL_HIGH); // 2A Threshold from calibration data
    uint16_t u16trim_low = EE_GET(TRIM_CSA_CL_LOW);   // 1.5A Trheshold from calibration data

    IO_SET(TRIM3_DRV, TRIM_CSA_CL, u16trim_high); // HW OC threshold ,2A
    878a:	62d8 09f0 	lod	AL, 0x9f0 <.LASF1600+0x9>
    878e:	42d8 020c 	mov	0x20c <_TRIM3_DRV>, AL

00008792 <.LM11>:
			STEP2_INC , 1U) ; 	/* STEP_INC = 1 */
    IO_SET (PORT_SSCM2_CONF , SSCM2_EN , 1u ) ; /* Enable the spread spectrum modulation */
#endif
    // VDDA output voltage level
    // Default : 3.3V output
    IO_SET(PORT_MISC_OUT, SWITCH_VDDA_TO_5V, VDDA_OUTPUT_LEVEL); /* 5V output*/
    8792:	0ea7      	lod	C, ML.7
    8794:	62d8 01f2 	lod	AL, 0x1f2 <_PORT_MISC_OUT>
    8798:	94df      	and	AL, #-33
    879a:	42d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, AL

0000879e <.LM12>:
    Itc_Enable(UV_VS);		//Under Voltage_ISR Enable
    Itc_Enable(OV_VS);		//Over Voltage Enable
    Itc_Enable(OVC);		//Over Current_ISR Enable
    Itc_Enable(OVT);		//Over Temperature_ISR Enable
#endif
}
    879e:	5401      	ret

000087a0 <_diagnostic_Start>:
/**
 * Clear over current, VDS and OV pending flag(s)
 */
void diagnostic_Start(void)
{
    IO_SET(PORT_DRV1_PROT, DIS_OC, 1u); /* clear MEM flag */
    87a0:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    87a4:	8408      	or	AL, #8
    87a6:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

000087aa <.LM22>:
    //IO_SET(PORT_DRV1_PROT, DIS_OC, 0u); /* re-enable hardware protection */

    IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 1u); /* clear MEM flag */
    87aa:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    87ae:	8420      	or	AL, #32
    87b0:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000087b4 <.LM23>:
    IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 0u); /* re-enable hardware protection */
    87b4:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    87b8:	94df      	and	AL, #-33
    87ba:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000087be <.LM24>:

    IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u); /* clear MEM flag */
    87be:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    87c2:	8408      	or	AL, #8
    87c4:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000087c8 <.LM25>:
    IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u); /* re-enable hardware protection */
    87c8:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    87cc:	94f7      	and	AL, #-9
    87ce:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000087d2 <.LM26>:

    IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u); /* clear MEM flag */
    87d2:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    87d6:	8402      	or	AL, #2
    87d8:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000087dc <.LM27>:
    IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u); /* re-enable hardware protection */
    87dc:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    87e0:	94fd      	and	AL, #-3
    87e2:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000087e6 <.LM28>:
}
    87e6:	5401      	ret

000087e8 <_DIAGNOSTIC_Reset>:
/**
 * Clear over current, VDS and OC pending flag(s)
 */
void DIAGNOSTIC_Reset(void)
{
    IO_SET(PORT_DRV1_PROT, DIS_OC, 1u); /* clear OVC_MEM flag */
    87e8:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    87ec:	8408      	or	AL, #8
    87ee:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

000087f2 <.LM31>:
    IO_SET(PORT_DRV1_PROT, DIS_OC, 0u); /* re-enable OVC hardware protection */
    87f2:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    87f6:	94f7      	and	AL, #-9
    87f8:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

000087fc <.LM32>:

    IO_SET(PORT_DRV1_PROT, DIS_OV_HS_VDS, 1u); /* clear OV_HS_VDS_MEM flag */
    87fc:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    8800:	8420      	or	AL, #32
    8802:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

00008806 <.LM33>:
    IO_SET(PORT_DRV1_PROT, DIS_OV_HS_VDS, 0u); /* re-enable HS-VDS hardware protection */
    8806:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    880a:	94df      	and	AL, #-33
    880c:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

00008810 <.LM34>:
}
    8810:	5401      	ret

00008812 <_diagnostic_IsUVPending>:
 */
bool diagnostic_IsUVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_SUPP_IN, UV_VS_IT) ? true : false;
    8812:	72d8 01e0 	lod	A, 0x1e0 <_PORT_SUPP_IN>

00008816 <.LM37>:
        ENTER_SECTION(ATOMIC_SYSTEM_MODE);
        Itc_Enable(UV_VS);
        EXIT_SECTION();
    }
#endif
    return bRetVal;
    8816:	9404      	and	AL, #4
    8818:	5ca2      	sne	A

0000881a <.LM38>:
}
    881a:	5401      	ret

0000881c <_diagnostic_IsOVPending>:
 */
bool diagnostic_IsOVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OV_VS_MEM) ? true : false;
    881c:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

00008820 <.LM41>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u);  /* clear MEM flag */
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u);  /* re-enable hardware protection */
    }
#endif
    return bRetVal;
    8820:	9402      	and	AL, #2
    8822:	5ca2      	sne	A

00008824 <.LM42>:
}
    8824:	5401      	ret

00008826 <_diagnostic_IsOVTPending>:
 */
bool diagnostic_IsOVTPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OVT_MEM) ? true : false;
    8826:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

0000882a <.LM45>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u);  /* clear MEM flag */
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u);  /* re-enable hardware protection */
    }
#endif
    return bRetVal;
    882a:	b401      	and	A, #1

0000882c <.LM46>:
}
    882c:	5401      	ret

0000882e <_diagnostic_IsVDSPending>:
 */
bool diagnostic_IsVDSPending(void)
{
    bool bRetVal;

    bRetVal = (IO_GET(PORT_DIAG_IN, OV_HS_VDS_MEM) || IO_GET(PORT_DIAG_IN, OV_LS_VDS_MEM)) ? true : false;
    882e:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    8832:	b6da 03c0 	and	A, #960
    8836:	1d06      	jne	0x8844 <.L12>

00008838 <.LM53>:
    8838:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    883c:	b6da 3c00 	and	A, #15360
    8840:	5ca2      	sne	A
    8842:	5401      	ret

00008844 <.L12>:
    8844:	7001      	lod	A, #1

00008846 <.LM55>:

    return bRetVal;
}
    8846:	5401      	ret

00008848 <__UV_VS_INT>:

/**
 * Under voltage interrupt
 */
INTERRUPT void _UV_VS_INT(void)
{
    8848:	5edf      	push	X

0000884a <.LCFI0>:
    884a:	5adf      	push	Y

0000884c <.LCFI1>:
    884c:	52df      	push	A

0000884e <.LCFI2>:
    884e:	4c83      	push	D

00008850 <.LCFI3>:
    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(UV_VS);
    8850:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    8854:	947f      	and	AL, #127
    8856:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

0000885a <.LM58>:

    /* Call application callback (save data to EEPROM, log error, etc) */
    EVENT_UnderVoltage();
    885a:	82db 4d59 	callf	0x9ab2 <_EVENT_UnderVoltage>

0000885e <.LM59>:
}
    885e:	4cc3      	pop	D

00008860 <.LCFI4>:
    8860:	72cf      	pop	A

00008862 <.LCFI5>:
    8862:	7acf      	pop	Y

00008864 <.LCFI6>:
    8864:	7ecf      	pop	X

00008866 <.LCFI7>:
    8866:	72cb      	pop	M
    8868:	5401      	ret

0000886a <__OV_VS_INT>:

/**
 * Over voltage interrupt
 */
INTERRUPT void _OV_VS_INT(void)
{
    886a:	52df      	push	A

0000886c <.LCFI8>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OV_VS);
    886c:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    8870:	94fb      	and	AL, #-5
    8872:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00008876 <.LM62>:

    /* Call application callback (save data to EEPROM, log error, etc) */
    //    EVENT_OverVoltage();
}
    8876:	72cf      	pop	A

00008878 <.LCFI9>:
    8878:	72cb      	pop	M
    887a:	5401      	ret

0000887c <__OVT_INT>:

/**
 * Over Temperature interrupt
 */
INTERRUPT void _OVT_INT(void)
{
    887c:	52df      	push	A

0000887e <.LCFI10>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OVT);
    887e:	62d8 006d 	lod	AL, 0x6d <__mlx4_cst_tables_ram_size+0xf>
    8882:	94fb      	and	AL, #-5
    8884:	42d8 006d 	mov	0x6d <__mlx4_cst_tables_ram_size+0xf>, AL

00008888 <.LM65>:
}
    8888:	72cf      	pop	A

0000888a <.LCFI11>:
    888a:	72cb      	pop	M
    888c:	5401      	ret

0000888e <__OVC_INT>:

/**
 * Over Current interrupt
 */
INTERRUPT void _OVC_INT(void)
{
    888e:	52df      	push	A

00008890 <.LCFI12>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OVC);
    8890:	62d8 006d 	lod	AL, 0x6d <__mlx4_cst_tables_ram_size+0xf>
    8894:	94f7      	and	AL, #-9
    8896:	42d8 006d 	mov	0x6d <__mlx4_cst_tables_ram_size+0xf>, AL

0000889a <.LM68>:
}
    889a:	72cf      	pop	A

0000889c <.LCFI13>:
    889c:	72cb      	pop	M
    889e:	5401      	ret

000088a0 <_eeprom_Init>:

/**
 * Module initialization
 */
bool eeprom_Init(void)
{
    88a0:	5801      	inc	S, #2

000088a2 <.LCFI0>:
    bool retval = true;

    unirom_Init();
    88a2:	82db 507b 	callf	0xa0f6 <_unirom_Init>

000088a6 <.LM3>:

    if (!unirom_LoadUserConfig())
    88a6:	82db 507c 	callf	0xa0f8 <_unirom_LoadUserConfig>
    88aa:	7ae2      	lod	Y, A
    88ac:	1d06      	jne	0x88ba <.L2>

000088ae <.LM4>:
    {
        (void)unirom_ResetUserConfig(&eeprom_defaults);
    88ae:	72da 5d46 	lod	A, #23878
    88b2:	5a01      	mov	[S-2], Y
    88b4:	82db 50d9 	callf	0xa1b2 <_unirom_ResetUserConfig>
    88b8:	7a01      	lod	Y, [S-2]

000088ba <.L2>:

        retval = false;
    }

    return retval;
}
    88ba:	72e6      	lod	A, Y
    88bc:	5403      	ret	#4

000088be <_eeprom_ReadLINconfig>:
 * @param[in]  length  the number of configuration words to read
 * @retval  true  valid configuration found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadLINconfig(uint8_t *config, uint8_t length)
{
    88be:	6603      	lod	YL, [S-4]
    88c0:	5cf6      	usex	Y

000088c2 <.LM7>:
    bool retval = false;
    retval = unirom_ReadPage(0u, config, length);
    88c2:	5adf      	push	Y

000088c4 <.LCFI1>:
    88c4:	52df      	push	A

000088c6 <.LCFI2>:
    88c6:	7000      	lod	A, #0

000088c8 <.LVL7>:
    88c8:	82db 514c 	callf	0xa298 <_unirom_ReadPage>

000088cc <.LCFI3>:

    return retval;
}
    88cc:	5405      	ret	#6

000088ce <_eeprom_ReadValveConfig>:
 * @param[out]  position  the position
 * @retval  true  valid position found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadValveConfig(valve_config_t *config)
{
    88ce:	5809      	inc	S, #10

000088d0 <.LCFI7>:
    88d0:	7ae2      	lod	Y, A

000088d2 <.LM18>:
    bool retval = false;
    uint8_t bytes[sizeof(valve_config_t)];
    (void)unirom_ReadPage(1u, &bytes[0], sizeof(valve_config_t));
    88d2:	54ca 0006 	pushw	#6

000088d6 <.LCFI8>:
    88d6:	72ef      	lod	A, S

000088d8 <.LVL18>:
    88d8:	a0f4      	add	A, #-12
    88da:	52df      	push	A

000088dc <.LCFI9>:
    88dc:	7001      	lod	A, #1
    88de:	5a07      	mov	[S-8], Y
    88e0:	82db 514c 	callf	0xa298 <_unirom_ReadPage>

000088e4 <.LM19>:

    config->E1DATA0 = (uint16_t)(bytes[0] + ((uint16_t)bytes[1] << 8));
    88e4:	620c      	lod	AL, [S-13]
    88e6:	6800      	lod	AH, #0
    88e8:	72e4      	swap	A
    88ea:	5205      	mov	[S-6], A
    88ec:	620d      	lod	AL, [S-14]
    88ee:	5cf2      	usex	A
    88f0:	7ee2      	lod	X, A
    88f2:	7205      	lod	A, [S-6]
    88f4:	a2ee      	add	A, X
    88f6:	7a07      	lod	Y, [S-8]
    88f8:	52f0      	mov	[Y], A

000088fa <.LM20>:
    config->E1DATA1 = (uint16_t)(bytes[2] + ((uint16_t)bytes[3] << 8));
    88fa:	620a      	lod	AL, [S-11]
    88fc:	6800      	lod	AH, #0
    88fe:	72e4      	swap	A
    8900:	5205      	mov	[S-6], A
    8902:	620b      	lod	AL, [S-12]
    8904:	5cf2      	usex	A
    8906:	7ee2      	lod	X, A
    8908:	7205      	lod	A, [S-6]
    890a:	a2ee      	add	A, X
    890c:	52f2      	mov	[Y+2], A

0000890e <.LM21>:
    config->E1DATA2 = (uint16_t)(bytes[4] + ((uint16_t)bytes[5] << 8));
    890e:	6208      	lod	AL, [S-9]
    8910:	6800      	lod	AH, #0
    8912:	72e4      	swap	A
    8914:	5205      	mov	[S-6], A
    8916:	6209      	lod	AL, [S-10]
    8918:	5cf2      	usex	A
    891a:	7ee2      	lod	X, A
    891c:	7205      	lod	A, [S-6]
    891e:	a2ee      	add	A, X
    8920:	52f4      	mov	[Y+4], A

00008922 <.LM22>:

    retval = true;

    return retval;
}
    8922:	7001      	lod	A, #1

00008924 <.LCFI10>:
    8924:	540f      	ret	#16

00008926 <_eeprom_WriteValveConfig>:
 * @param[out]  config  the configuration array to be stored
 * @retval  true  the configuration is correctly stored
 * @retval  false  otherwise
 */
bool eeprom_WriteValveConfig(valve_config_t *config)
{
    8926:	5805      	inc	S, #6

00008928 <.LCFI11>:
    8928:	7ee2      	lod	X, A

0000892a <.LM24>:
    bool retval = true;
    uint8_t bytes[sizeof(valve_config_t)];

    bytes[0] = (uint8_t)((uint16_t)config->E1DATA0 & 0xFF);
    892a:	7af8      	lod	Y, [X]
    892c:	4605      	mov	[S-6], YL

0000892e <.LM25>:
    bytes[1] = (uint8_t)(((uint16_t)config->E1DATA0 >> 8) & 0xFF);
    892e:	4e04      	mov	[S-5], YH

00008930 <.LM26>:
    bytes[2] = (uint8_t)((uint16_t)config->E1DATA1 & 0xFF);
    8930:	7afa      	lod	Y, [X+2]
    8932:	4603      	mov	[S-4], YL

00008934 <.LM27>:
    bytes[3] = (uint8_t)(((uint16_t)config->E1DATA1 >> 8) & 0xFF);
    8934:	4e02      	mov	[S-3], YH

00008936 <.LM28>:
    bytes[4] = (uint8_t)((uint16_t)config->E1DATA2 & 0xFF);
    8936:	72fc      	lod	A, [X+4]

00008938 <.LVL23>:
    8938:	4201      	mov	[S-2], AL

0000893a <.LM29>:
    bytes[5] = (uint8_t)(((uint16_t)config->E1DATA2 >> 8) & 0xFF);
    893a:	4a00      	mov	[S-1], AH

0000893c <.LM30>:

    (void)unirom_WritePage(1u, &bytes[0], sizeof(valve_config_t));
    893c:	54ca 0006 	pushw	#6

00008940 <.LCFI12>:
    8940:	72ef      	lod	A, S
    8942:	a0f8      	add	A, #-8
    8944:	52df      	push	A

00008946 <.LCFI13>:
    8946:	7001      	lod	A, #1
    8948:	82db 5112 	callf	0xa224 <_unirom_WritePage>

0000894c <.LM31>:
    return retval;
}
    894c:	7001      	lod	A, #1

0000894e <.LCFI14>:
    894e:	540b      	ret	#12

00008950 <_eeprom_ReadDiagConfig>:
 *
 * @retval  true  valid position found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadDiagConfig(valve_config_t *config)
{
    8950:	5809      	inc	S, #10

00008952 <.LCFI15>:
    8952:	7ae2      	lod	Y, A

00008954 <.LM33>:
    bool retval = false;
    uint8_t bytes[sizeof(valve_config_t)];
    (void)unirom_ReadPage(2u, &bytes[0], sizeof(valve_config_t));
    8954:	54ca 0006 	pushw	#6

00008958 <.LCFI16>:
    8958:	72ef      	lod	A, S

0000895a <.LVL27>:
    895a:	a0f4      	add	A, #-12
    895c:	52df      	push	A

0000895e <.LCFI17>:
    895e:	7002      	lod	A, #2
    8960:	5a07      	mov	[S-8], Y
    8962:	82db 514c 	callf	0xa298 <_unirom_ReadPage>

00008966 <.LM34>:

    config->E1DATA0 = (uint16_t)(bytes[0] + ((uint16_t)bytes[1] << 8));
    8966:	620c      	lod	AL, [S-13]
    8968:	6800      	lod	AH, #0
    896a:	72e4      	swap	A
    896c:	5205      	mov	[S-6], A
    896e:	620d      	lod	AL, [S-14]
    8970:	5cf2      	usex	A
    8972:	7ee2      	lod	X, A
    8974:	7205      	lod	A, [S-6]
    8976:	a2ee      	add	A, X
    8978:	7a07      	lod	Y, [S-8]
    897a:	52f0      	mov	[Y], A

0000897c <.LM35>:
    config->E1DATA1 = (uint16_t)(bytes[2] + ((uint16_t)bytes[3] << 8));
    897c:	620a      	lod	AL, [S-11]
    897e:	6800      	lod	AH, #0
    8980:	72e4      	swap	A
    8982:	5205      	mov	[S-6], A
    8984:	620b      	lod	AL, [S-12]
    8986:	5cf2      	usex	A
    8988:	7ee2      	lod	X, A
    898a:	7205      	lod	A, [S-6]
    898c:	a2ee      	add	A, X
    898e:	52f2      	mov	[Y+2], A

00008990 <.LM36>:
    config->E1DATA2 = (uint16_t)(bytes[4] + ((uint16_t)bytes[5] << 8));
    8990:	6208      	lod	AL, [S-9]
    8992:	6800      	lod	AH, #0
    8994:	72e4      	swap	A
    8996:	5205      	mov	[S-6], A
    8998:	6209      	lod	AL, [S-10]
    899a:	5cf2      	usex	A
    899c:	7ee2      	lod	X, A
    899e:	7205      	lod	A, [S-6]
    89a0:	a2ee      	add	A, X
    89a2:	52f4      	mov	[Y+4], A

000089a4 <.LM37>:

    retval = true;

    return retval;
}
    89a4:	7001      	lod	A, #1

000089a6 <.LCFI18>:
    89a6:	540f      	ret	#16

000089a8 <_eeprom_WriteDiagConfig>:
bool eeprom_WriteDiagConfig(valve_config_t *config)
{
    89a8:	5805      	inc	S, #6

000089aa <.LCFI19>:
    89aa:	7ee2      	lod	X, A

000089ac <.LM39>:
    bool retval = true;
    uint8_t bytes[sizeof(valve_config_t)];

    bytes[0] = (uint8_t)((uint16_t)config->E1DATA0 & 0xFF);
    89ac:	7af8      	lod	Y, [X]
    89ae:	4605      	mov	[S-6], YL

000089b0 <.LM40>:
    bytes[1] = (uint8_t)(((uint16_t)config->E1DATA0 >> 8) & 0xFF);
    89b0:	4e04      	mov	[S-5], YH

000089b2 <.LM41>:
    bytes[2] = (uint8_t)((uint16_t)config->E1DATA1 & 0xFF);
    89b2:	7afa      	lod	Y, [X+2]
    89b4:	4603      	mov	[S-4], YL

000089b6 <.LM42>:
    bytes[3] = (uint8_t)(((uint16_t)config->E1DATA1 >> 8) & 0xFF);
    89b6:	4e02      	mov	[S-3], YH

000089b8 <.LM43>:
    bytes[4] = (uint8_t)((uint16_t)config->E1DATA2 & 0xFF);
    89b8:	72fc      	lod	A, [X+4]

000089ba <.LVL32>:
    89ba:	4201      	mov	[S-2], AL

000089bc <.LM44>:
    bytes[5] = (uint8_t)(((uint16_t)config->E1DATA2 >> 8) & 0xFF);
    89bc:	4a00      	mov	[S-1], AH

000089be <.LM45>:

    (void)unirom_WritePage(2u, &bytes[0], sizeof(valve_config_t));
    89be:	54ca 0006 	pushw	#6

000089c2 <.LCFI20>:
    89c2:	72ef      	lod	A, S
    89c4:	a0f8      	add	A, #-8
    89c6:	52df      	push	A

000089c8 <.LCFI21>:
    89c8:	7002      	lod	A, #2
    89ca:	82db 5112 	callf	0xa224 <_unirom_WritePage>

000089ce <.LM46>:
    return retval;
}
    89ce:	7001      	lod	A, #1

000089d0 <.LCFI22>:
    89d0:	540b      	ret	#12

000089d2 <_valve_gmr_write>:
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    valve_gmr_data.E1DATA0 = data1;
    89d2:	7eda 134a 	lod	X, #4938
    89d6:	52f8      	mov	[X], A

000089d8 <.LM55>:
    else
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    89d8:	7203      	lod	A, [S-4]

000089da <.LM56>:
    valve_gmr_data.E1DATA0 = data1;
    valve_gmr_data.E1DATA1 = data2;
    89da:	52d8 134c 	mov	0x134c <.LASF1850>, A

000089de <.LM57>:
    else
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    89de:	7205      	lod	A, [S-6]

000089e0 <.LM58>:
    valve_gmr_data.E1DATA0 = data1;
    valve_gmr_data.E1DATA1 = data2;
    valve_gmr_data.E1DATA2 = data3;
    89e0:	52d8 134e 	mov	0x134e <.LASF1850+0x2>, A

000089e4 <.LM59>:
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    89e4:	72ee      	lod	A, X
    89e6:	179f      	call	0x8926 <_eeprom_WriteValveConfig>

000089e8 <.LBB6>:
}
void eeprom_StoreUserDataConfig(uint16_t index)
{
    if (index == 1)
    {
        (void)unirom_StorePage(1u);
    89e8:	7001      	lod	A, #1
    89ea:	76da 50ee 	jmpf	0xa1dc <_unirom_StorePage>

000089ee <_valve_diag_write>:
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    valve_diag_data.E1DATA0 = data1;
    89ee:	7eda 1344 	lod	X, #4932
    89f2:	52f8      	mov	[X], A

000089f4 <.LM64>:
    valve_gmr_data.E1DATA2 = data3;
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    89f4:	7203      	lod	A, [S-4]

000089f6 <.LM65>:
    valve_diag_data.E1DATA0 = data1;
    valve_diag_data.E1DATA1 = data2;
    89f6:	52d8 1346 	mov	0x1346 <_valve_diag_data+0x2>, A

000089fa <.LM66>:
    valve_gmr_data.E1DATA2 = data3;
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    89fa:	7205      	lod	A, [S-6]

000089fc <.LM67>:
    valve_diag_data.E1DATA0 = data1;
    valve_diag_data.E1DATA1 = data2;
    valve_diag_data.E1DATA2 = data3;
    89fc:	52d8 1348 	mov	0x1348 <.LLST25+0x1>, A

00008a00 <.LM68>:
    (void)eeprom_WriteDiagConfig(&valve_diag_data);
    8a00:	72ee      	lod	A, X
    8a02:	17d2      	call	0x89a8 <_eeprom_WriteDiagConfig>

00008a04 <.LBB8>:
    {
        (void)unirom_StorePage(1u);
    }
    else if (index == 2)
    {
        (void)unirom_StorePage(2u);
    8a04:	7002      	lod	A, #2
    8a06:	76da 50ee 	jmpf	0xa1dc <_unirom_StorePage>

00008a0a <_FILTER_AVG_CalcMovAvg>:
 * @brief add a value in the AVG buffer and calculates the moving average
 * @param a_pHandler The handle (pointer to FILTER_AVG_Object_t structure) to the FILTER_AVG object
 * @param a_u16NewValue A new value to add to the moving-average buffer
 */
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    8a0a:	580d      	inc	S, #14

00008a0c <.LCFI1>:
    8a0c:	5205      	mov	[S-6], A

00008a0e <.LM13>:
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    8a0e:	7ae2      	lod	Y, A
    8a10:	e00a      	add	Y, #10
    8a12:	72f0      	lod	A, [Y]

00008a14 <.LVL5>:
    8a14:	4422      	asl	A
    8a16:	7e05      	lod	X, [S-6]
    8a18:	7efe      	lod	X, [X+6]
    8a1a:	22e2      	add	X, A
    8a1c:	5e07      	mov	[S-8], X

00008a1e <.LM14>:
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    8a1e:	7e05      	lod	X, [S-6]

00008a20 <.LVL7>:
    8a20:	2008      	add	X, #8
    8a22:	5e0d      	mov	[S-14], X
    8a24:	72f8      	lod	A, [X]
    8a26:	5201      	mov	[S-2], A
    8a28:	a0ff      	add	A, #-1
    8a2a:	7ef0      	lod	X, [Y]
    8a2c:	2001      	add	X, #1
    8a2e:	b6ee      	and	A, X
    8a30:	52f0      	mov	[Y], A

00008a32 <.LM15>:
 * @brief add a value in the AVG buffer and calculates the moving average
 * @param a_pHandler The handle (pointer to FILTER_AVG_Object_t structure) to the FILTER_AVG object
 * @param a_u16NewValue A new value to add to the moving-average buffer
 */
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    8a32:	7211      	lod	A, [S-18]

00008a34 <.LM16>:
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    uint16_t u16Oldest = *pu16Element;
    a_pHandler->u32MovAvgxN -= u16Oldest;  /* Subtract oldest raw element */
    a_pHandler->u32MovAvgxN += (uint32_t)a_u16NewValue;  /* Add newest raw element */
    8a34:	4cc8      	movu	D, A
    8a36:	7a05      	lod	Y, [S-6]
    8a38:	72f2      	lod	A, [Y+2]
    8a3a:	7af4      	lod	Y, [Y+4]
    8a3c:	4c00      	add	D, YA

00008a3e <.LM17>:
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    uint16_t u16Oldest = *pu16Element;
    a_pHandler->u32MovAvgxN -= u16Oldest;  /* Subtract oldest raw element */
    8a3e:	7a07      	lod	Y, [S-8]
    8a40:	4ced      	movu	YA, [Y]

00008a42 <.LM18>:
    a_pHandler->u32MovAvgxN += (uint32_t)a_u16NewValue;  /* Add newest raw element */
    8a42:	4c10      	sub	D, YA
    8a44:	7e05      	lod	X, [S-6]
    8a46:	2002      	add	X, #2
    8a48:	4c87      	mov	[X], D

00008a4a <.LM19>:
    *pu16Element = (uint16_t)a_u16NewValue;  /* Overwrite oldest with newest element */
    8a4a:	7211      	lod	A, [S-18]

00008a4c <.LVL10>:
    8a4c:	7a07      	lod	Y, [S-8]

00008a4e <.LVL11>:
    8a4e:	52f0      	mov	[Y], A

00008a50 <.LBB4>:
MATHLIB_INLINE_STATIC __inline__ uint16_t divU16_U32byU16(uint32_t dividend, uint16_t divisor)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a50:	7e0d      	lod	X, [S-14]
    8a52:	7ef8      	lod	X, [X]
    8a54:	5e07      	mov	[S-8], X
    8a56:	4c80      	mov	YA, D
    8a58:	4c63      	divu	YA, X
    8a5a:	4c63      	divu	YA, X

00008a5c <.LBE4>:
    a_pHandler->u16MovAvg = divU16_U32byU16(a_pHandler->u32MovAvgxN, a_pHandler->u16Size);
    8a5c:	7a05      	lod	Y, [S-6]
    8a5e:	52f0      	mov	[Y], A

00008a60 <.LM22>:
}
    8a60:	540f      	ret	#16

00008a62 <_Generic_INT>:
}

#ifndef HAS_SW_EXPLICIT_FAIL_INFO
/* Generic interrupt handler */
WEAK_INTERRUPT void Generic_INT(void)
{
    8a62:	5edf      	push	X

00008a64 <.LCFI0>:
    8a64:	5adf      	push	Y

00008a66 <.LCFI1>:
    8a66:	52df      	push	A

00008a68 <.LCFI2>:
    8a68:	4c83      	push	D

00008a6a <.LBB8>:
}

STATIC INLINE void ErrH_FatalInformed(ErrH_Identifier information)
{
    UNUSED(information);
    _fatal();
    8a6a:	82db 1b23 	callf	0x3646 <__fatal>

00008a6e <_fw_mls_ErrorDetected>:

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    8a6e:	5803      	inc	S, #4

00008a70 <.LCFI0>:
    8a70:	5203      	mov	[S-4], A

00008a72 <.LBB76>:
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    8a72:	62d8 13f5 	lod	AL, 0x13f5 <_ld_ErrorDetectedMultipleHandler+0x3>

00008a76 <.LVL2>:
    8a76:	1915      	je	0x8aa2 <.L2>
    8a78:	7000      	lod	A, #0
    8a7a:	5201      	mov	[S-2], A

00008a7c <.L3>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    8a7c:	7201      	lod	A, [S-2]
    8a7e:	4422      	asl	A
    8a80:	7ed8 13f2 	lod	X, 0x13f2 <_ld_ErrorDetectedMultipleHandler>
    8a84:	22e2      	add	X, A
    8a86:	7203      	lod	A, [S-4]
    8a88:	7af8      	lod	Y, [X]
    8a8a:	0001      	jmp	0x8a8e <.L13>

00008a8c <.L12>:
    8a8c:	76e6      	jmp	Y

00008a8e <.L13>:
    8a8e:	17fe      	call	0x8a8c <.L12>

00008a90 <.LM4>:
    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    8a90:	6201      	lod	AL, [S-2]
    8a92:	8001      	add	AL, #1
    8a94:	66e0      	lod	YL, AL

00008a96 <.LVL5>:
    8a96:	5cf2      	usex	A

00008a98 <.LVL6>:
    8a98:	5201      	mov	[S-2], A
    8a9a:	62d8 13f5 	lod	AL, 0x13f5 <_ld_ErrorDetectedMultipleHandler+0x3>
    8a9e:	8ee8      	cmp	AL, YL
    8aa0:	1e6d      	jug	0x8a7c <.L3>

00008aa2 <.L2>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    }
	if (g_u8LinErrorCnt < 0xFFu)
    8aa2:	62d8 1187 	lod	AL, 0x1187 <_g_u8LinErrorCnt>
    8aa6:	66e0      	lod	YL, AL
    8aa8:	5cf6      	usex	Y
    8aaa:	eeda 00ff 	cmp	Y, #255
    8aae:	1903      	je	0x8ab6 <.L4>

00008ab0 <.LM6>:
	{
		g_u8LinErrorCnt++;
    8ab0:	8001      	add	AL, #1
    8ab2:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

00008ab6 <.L4>:
	}
	g_u8LinErrorCode=error;
    8ab6:	6603      	lod	YL, [S-4]
    8ab8:	46d8 1186 	mov	0x1186 <_g_u8LinErrorCode>, YL

00008abc <.LM8>:
}
    8abc:	5405      	ret	#6

00008abe <_fw_mls_Init>:
#include "io.h"

/** Set the MLX4 clock divider on top of MLX16 clock */
STATIC INLINE void mls_SetMlx4ClockDivider(void)
{
    IO_SET(COLIN, SPEED, (uint16_t)LIN_CLK_DIV);
    8abe:	62d8 01bc 	lod	AL, 0x1bc <_COLIN+0x10>
    8ac2:	94f8      	and	AL, #-8
    8ac4:	42d8 01bc 	mov	0x1bc <_COLIN+0x10>, AL

00008ac8 <.LBE77>:

void fw_mls_Init(void)
{
    mls_SetMlx4ClockDivider();
#if ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0
    ml_InitLinEventTable(&fwlinEventTable);
    8ac8:	72da 1168 	lod	A, #4456
    8acc:	82db 20b9 	callf	0x4172 <_ml_InitLinEventTable>

00008ad0 <.LM12>:
#endif /* ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0 */

    /* Initialize LIN TL */
    ld_RequestMultipleHandler.eventHandlerBuffer = ld_RequestMHBuffer;
    8ad0:	72da 1162 	lod	A, #4450
    8ad4:	0ea7      	lod	C, ML.7
    8ad6:	52d8 13ea 	mov	0x13ea <_ld_RequestMultipleHandler>, A

00008ada <.LM13>:
    ld_RequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8ada:	7003      	lod	A, #3
    8adc:	52d8 13ec 	mov	0x13ec <_ld_RequestMultipleHandler+0x2>, A

00008ae0 <.LM14>:
    ld_RequestMultipleHandler.eventsCount = 0u;
    ld_ResponseTransmittedMultipleHandler.eventHandlerBuffer = ld_ResponseTransmittedMHBuffer;
    8ae0:	0ea7      	lod	C, ML.7
    8ae2:	7eda 115c 	lod	X, #4444
    8ae6:	5ed8 13e6 	mov	0x13e6 <_ld_ResponseTransmittedMultipleHandler>, X

00008aea <.LM15>:
    ld_ResponseTransmittedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8aea:	52d8 13e8 	mov	0x13e8 <_ld_ResponseTransmittedMultipleHandler+0x2>, A

00008aee <.LM16>:
    ld_ResponseTransmittedMultipleHandler.eventsCount = 0u;
    ld_FunctionalRequestMultipleHandler.eventHandlerBuffer = ld_FunctionalRequestMHBuffer;
    8aee:	0ea7      	lod	C, ML.7
    8af0:	7eda 1156 	lod	X, #4438
    8af4:	5ed8 13ee 	mov	0x13ee <_ld_FunctionalRequestMultipleHandler>, X

00008af8 <.LM17>:
    ld_FunctionalRequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8af8:	52d8 13f0 	mov	0x13f0 <_ld_FunctionalRequestMultipleHandler+0x2>, A

00008afc <.LM18>:
    ld_FunctionalRequestMultipleHandler.eventsCount = 0u;
    ld_ErrorDetectedMultipleHandler.eventHandlerBuffer = ld_ErrorDetectedMHBuffer;
    8afc:	0ea7      	lod	C, ML.7
    8afe:	7eda 1150 	lod	X, #4432
    8b02:	5ed8 13f2 	mov	0x13f2 <_ld_ErrorDetectedMultipleHandler>, X

00008b06 <.LM19>:
    ld_ErrorDetectedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8b06:	52d8 13f4 	mov	0x13f4 <_ld_ErrorDetectedMultipleHandler+0x2>, A

00008b0a <.LM20>:
    ld_ErrorDetectedMultipleHandler.eventsCount = 0u;

    Itc_Clear(COLIN_LIN);
    8b0a:	0ea7      	lod	C, ML.7
    8b0c:	6002      	lod	AL, #2
    8b0e:	42d8 0055 	mov	0x55 <.Lframe0+0x1>, AL

00008b12 <.LM21>:
    Itc_SetPrio(COLIN_LIN, MLS_IRQ_PRIO);
    8b12:	62d8 008d 	lod	AL, 0x8d <.LASF1529+0x1>
    8b16:	94f3      	and	AL, #-13
    8b18:	8408      	or	AL, #8
    8b1a:	42d8 008d 	mov	0x8d <.LASF1529+0x1>, AL

00008b1e <.LM22>:
    Itc_Enable(COLIN_LIN);
    8b1e:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    8b22:	8402      	or	AL, #2
    8b24:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00008b28 <.LM23>:
}
    8b28:	5401      	ret

00008b2a <_fw_mls_TransportLayerInit>:

void fw_mls_TransportLayerInit(void)
{
    ldt_Init(&ldt_TL_data,
    8b2a:	54ca 13ee 	pushw	#5102

00008b2e <.LCFI1>:
    8b2e:	54ca 13e6 	pushw	#5094

00008b32 <.LCFI2>:
    8b32:	54ca 13ea 	pushw	#5098

00008b36 <.LCFI3>:
    8b36:	0ea7      	lod	C, ML.7
    8b38:	54ca 0000 	pushw	#0

00008b3c <.LCFI4>:
    8b3c:	72da 1350 	lod	A, #4944
    8b40:	82db 1fb0 	callf	0x3f60 <_ldt_Init>

00008b44 <.LM26>:

#if FW_LIN_TL_FUNCTIONAL_NAD_FIX == 1
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_ResponseTransmitted, fw_mls_ldt_CustomResponseTransmitted);
#endif

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
    8b44:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    8b48:	2016      	add	X, #22
    8b4a:	72da 4537 	lod	A, #17719
    8b4e:	52f8      	mov	[X], A

00008b50 <.LCFI5>:
}
    8b50:	5409      	ret	#10

00008b52 <__COLIN_LIN_INT>:
#endif /* FW_LIN_TL_FUNCTIONAL_NAD_FIX */

/** LIN interrupt handler
 */
__attribute__((interrupt)) void _COLIN_LIN_INT(void)
{
    8b52:	5edf      	push	X

00008b54 <.LCFI6>:
    8b54:	5adf      	push	Y

00008b56 <.LCFI7>:
    8b56:	52df      	push	A

00008b58 <.LCFI8>:
    8b58:	4c83      	push	D

00008b5a <.LCFI9>:
    ml_LinInterruptHandler();
    8b5a:	82db 20d0 	callf	0x41a0 <_ml_LinInterruptHandler>

00008b5e <.LM30>:
}
    8b5e:	4cc3      	pop	D

00008b60 <.LCFI10>:
    8b60:	72cf      	pop	A

00008b62 <.LCFI11>:
    8b62:	7acf      	pop	Y

00008b64 <.LCFI12>:
    8b64:	7ecf      	pop	X

00008b66 <.LCFI13>:
    8b66:	72cb      	pop	M
    8b68:	5401      	ret

00008b6a <_fw_lepm_ResponseTransmitted>:
STATIC bool fw_lepm_ResponseTransmitted(LINDiagTransfer_t* transfer)
{
    (void)transfer;

#if HAS_PPM_EPM == 1
    if (lepmFlag == true) {
    8b6a:	62d8 1188 	lod	AL, 0x1188 <_lepmFlag>

00008b6e <.LVL1>:
    8b6e:	1904      	je	0x8b78 <.L2>

00008b70 <.LM3>:
        MLX16_RESET_SIGNED((uint16_t)C_CHIP_STATE_PPM_CMD_EPM);
    8b70:	72da b065 	lod	A, #45157
    8b74:	82db 1503 	callf	0x2a06 <_MLX16_RESET_SIGNED>

00008b78 <.L2>:
    8b78:	62d8 1189 	lod	AL, 0x1189 <_isAwaitingResponseTransmitted>
    8b7c:	5cf2      	usex	A

00008b7e <.LM4>:
        return true;
    } else {
        /* The event is intended for the next LIN TL subscribers */
        return false;
    }
}
    8b7e:	5401      	ret

00008b80 <_fw_lepm_Init>:
}

void fw_lepm_Init(void)
{
    /* LIN TL */
    (void)ldt_SubscribeMultipleHandler(&ld_RequestMultipleHandler, fw_lepm_Request);
    8b80:	54ca 45d0 	pushw	#17872

00008b84 <.LCFI0>:
    8b84:	72da 13ea 	lod	A, #5098
    8b88:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008b8c <.LM7>:
    (void)ldt_SubscribeMultipleHandler(&ld_ResponseTransmittedMultipleHandler, fw_lepm_ResponseTransmitted);
    8b8c:	54ca 45b5 	pushw	#17845

00008b90 <.LCFI1>:
    8b90:	72da 13e6 	lod	A, #5094
    8b94:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008b98 <.LM8>:

    /* LIN EPM specific */
#if HAS_PPM_EPM == 1
    lepmFlag = false;
    8b98:	6000      	lod	AL, #0
    8b9a:	42d8 1188 	mov	0x1188 <_lepmFlag>, AL

00008b9e <.LCFI2>:
#endif
}
    8b9e:	5405      	ret	#6

00008ba0 <_fw_lepm_Request>:
    /* Always allow enter programming mode by default */
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    8ba0:	5807      	inc	S, #8

00008ba2 <.LCFI3>:
    8ba2:	5205      	mov	[S-6], A

00008ba4 <.LM13>:
     *   returns PLTF_VERSION + TYPE
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
    8ba4:	7ae2      	lod	Y, A
    8ba6:	62f0      	lod	AL, [Y]

00008ba8 <.LVL7>:
    8ba8:	8cb2      	cmp	AL, #-78
    8baa:	1902      	je	0x8bb0 <.L6>

00008bac <.L25>:
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    bool isAnswerExpected = false;
    8bac:	7000      	lod	A, #0
    8bae:	0055      	jmp	0x8c5a <.L7>

00008bb0 <.L6>:
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
        if (transfer->request.dataLen <= LE_MIN_RBI_DATA_LEN) {
    8bb0:	7e05      	lod	X, [S-6]
    8bb2:	72fa      	lod	A, [X+2]
    8bb4:	ac05      	cmp	A, #5
    8bb6:	1e7a      	jug	0x8bac <.L25>

00008bb8 <.LBB20>:

            fw_lepm_ReadByIdProdIdReq_t* pProdIdReq = (fw_lepm_ReadByIdProdIdReq_t*)transfer->request.data;

            if ((pProdIdReq->supp_id == LE_MLX_SUPPLIER_ID)) {
    8bb8:	7aee      	lod	Y, X

00008bba <.LVL11>:
    8bba:	e005      	add	Y, #5
    8bbc:	7ee6      	lod	X, Y
    8bbe:	66f8      	lod	YL, [X]
    8bc0:	6ef9      	lod	YH, [X+1]
    8bc2:	ec13      	cmp	Y, #19
    8bc4:	1d73      	jne	0x8bac <.L25>

00008bc6 <.LM17>:
                switch (pProdIdReq->id) {
    8bc6:	7a05      	lod	Y, [S-6]
    8bc8:	62f4      	lod	AL, [Y+4]
    8bca:	8c34      	cmp	AL, #52
    8bcc:	1d01      	jne	0x8bd0 <.LASF1091+0x3>
    8bce:	0048      	jmp	0x8c60 <.L9>
    8bd0:	66e0      	lod	YL, AL
    8bd2:	5cf6      	usex	Y
    8bd4:	ec35      	cmp	Y, #53
    8bd6:	1d01      	jne	0x8bda <.LASF167+0x1>
    8bd8:	005a      	jmp	0x8c8e <.L10>
    8bda:	ec33      	cmp	Y, #51
    8bdc:	1d67      	jne	0x8bac <.L25>

00008bde <.LM18>:
                    case LE_MLX_SPECIAL_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8bde:	7a05      	lod	Y, [S-6]
    8be0:	e007      	add	Y, #7
    8be2:	62f0      	lod	AL, [Y]
    8be4:	6af1      	lod	AH, [Y+1]
    8be6:	94bf      	and	AL, #-65
    8be8:	aeda cabc 	cmp	A, #51900
    8bec:	1d17      	jne	0x8c1c <.L12>

00008bee <.LBB21>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8bee:	72da 00f2 	lod	A, #242
    8bf2:	7e05      	lod	X, [S-6]
    8bf4:	42f8      	mov	[X], AL

00008bf6 <.LM20>:
    transfer->response.dataLen = 5u;
    8bf6:	7005      	lod	A, #5
    8bf8:	52fa      	mov	[X+2], A

00008bfa <.LM21>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    8bfa:	72d8 0a36 	lod	A, 0xa36 <.LLST12+0x1>
    8bfe:	6400      	lod	YL, #0
    8c00:	42fc      	mov	[X+4], AL
    8c02:	4afd      	mov	[X+5], AH

00008c04 <.LM22>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    8c04:	72ee      	lod	A, X
    8c06:	a006      	add	A, #6
    8c08:	7ee2      	lod	X, A
    8c0a:	46f8      	mov	[X], YL

00008c0c <.LVL15>:
    8c0c:	46f9      	mov	[X+1], YL

00008c0e <.LM23>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    8c0e:	7e05      	lod	X, [S-6]
    8c10:	2008      	add	X, #8
    8c12:	72da 00ff 	lod	A, #255

00008c16 <.L27>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    8c16:	42f8      	mov	[X], AL

00008c18 <.L26>:
                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
                            || (pProdIdReq->func_id ==
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            fw_lepm_PreparePatchRevResponse(transfer);
                            isAnswerExpected = true;
    8c18:	7001      	lod	A, #1
    8c1a:	001f      	jmp	0x8c5a <.L7>

00008c1c <.L12>:
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            /* Prepare response with product identifiers */
                            fw_lepm_PrepareProdResponse(transfer);
                            isAnswerExpected = true;
#if HAS_PPM_EPM == 1
                        } else if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_ENTER_PPM_MODE)
    8c1c:	aeda cabd 	cmp	A, #51901
    8c20:	1d45      	jne	0x8bac <.L25>

00008c22 <.LM27>:
                                   || (pProdIdReq->func_id ==
                                       fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_ENTER_PPM_MODE))) {
                            if (fw_lepm_ApplicationStop()) {
    8c22:	11e0      	call	0x8fe4 <_fw_lepm_ApplicationStop>
    8c24:	ac00      	cmp	A, #0
    8c26:	1942      	je	0x8bac <.L25>

00008c28 <.LM28>:
                                /* Set PPM mode flag */
                                lepmFlag = true;
    8c28:	6401      	lod	YL, #1
    8c2a:	46d8 1188 	mov	0x1188 <_lepmFlag>, YL

00008c2e <.LBB26>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8c2e:	7ada 00f2 	lod	Y, #242
    8c32:	7e05      	lod	X, [S-6]
    8c34:	46f8      	mov	[X], YL

00008c36 <.LM30>:
    transfer->response.dataLen = 5u;
    8c36:	7805      	lod	Y, #5
    8c38:	5afa      	mov	[X+2], Y

00008c3a <.LM31>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    8c3a:	7ad8 0a36 	lod	Y, 0xa36 <.LLST12+0x1>
    8c3e:	46fc      	mov	[X+4], YL
    8c40:	4efd      	mov	[X+5], YH

00008c42 <.LM32>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    8c42:	7aee      	lod	Y, X
    8c44:	e006      	add	Y, #6
    8c46:	5a03      	mov	[S-4], Y
    8c48:	6400      	lod	YL, #0
    8c4a:	7e03      	lod	X, [S-4]
    8c4c:	46f8      	mov	[X], YL

00008c4e <.LVL21>:
    8c4e:	7e03      	lod	X, [S-4]
    8c50:	46f9      	mov	[X+1], YL

00008c52 <.LM33>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    8c52:	7e05      	lod	X, [S-6]
    8c54:	2008      	add	X, #8
    8c56:	64ff      	lod	YL, #-1
    8c58:	46f8      	mov	[X], YL

00008c5a <.L7>:
        /* ignore other diagnostic messages */
    }

    /* If MLS device ID response is prepared then it's true;
     * in the case of new application specific request after - it's false */
    isAwaitingResponseTransmitted = isAnswerExpected;
    8c5a:	42d8 1189 	mov	0x1189 <_isAwaitingResponseTransmitted>, AL

00008c5e <.LM35>:
    return isAnswerExpected;
}
    8c5e:	5409      	ret	#10

00008c60 <.L9>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PLTF_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8c60:	7a05      	lod	Y, [S-6]
    8c62:	e007      	add	Y, #7
    8c64:	62f0      	lod	AL, [Y]
    8c66:	6af1      	lod	AH, [Y+1]
    8c68:	94bf      	and	AL, #-65
    8c6a:	aeda cabc 	cmp	A, #51900
    8c6e:	1901      	je	0x8c72 <.LM37>
    8c70:	079d      	jmp	0x8bac <.L25>

00008c72 <.LM37>:
}

STATIC void fw_lepm_PreparePltfRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8c72:	72da 00f2 	lod	A, #242
    8c76:	7a05      	lod	Y, [S-6]
    8c78:	42f0      	mov	[Y], AL

00008c7a <.LM38>:
    transfer->response.dataLen = LE_PLTF_REV_RES_DATA_LENGTH;
    8c7a:	7005      	lod	A, #5
    8c7c:	52f2      	mov	[Y+2], A
    8c7e:	7ada 0101 	lod	Y, #257
    8c82:	7e05      	lod	X, [S-6]
    8c84:	5afc      	mov	[X+4], Y

00008c86 <.LM39>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    8c86:	7804      	lod	Y, #4
    8c88:	5afe      	mov	[X+6], Y

00008c8a <.LM40>:
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    8c8a:	2008      	add	X, #8
    8c8c:	07c4      	jmp	0x8c16 <.L27>

00008c8e <.L10>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8c8e:	7a05      	lod	Y, [S-6]
    8c90:	e007      	add	Y, #7
    8c92:	62f0      	lod	AL, [Y]
    8c94:	6af1      	lod	AH, [Y+1]
    8c96:	94bf      	and	AL, #-65
    8c98:	aeda cabc 	cmp	A, #51900
    8c9c:	1901      	je	0x8ca0 <.LBB29>
    8c9e:	0786      	jmp	0x8bac <.L25>

00008ca0 <.LBB29>:
}

STATIC void fw_lepm_PreparePatchRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8ca0:	72da 00f2 	lod	A, #242
    8ca4:	7a05      	lod	Y, [S-6]
    8ca6:	42f0      	mov	[Y], AL

00008ca8 <.LM43>:
    transfer->response.dataLen = LE_PATCH_REV_RES_DATA_LENGTH;
    8ca8:	7002      	lod	A, #2
    8caa:	52f2      	mov	[Y+2], A

00008cac <.LM44>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8cac:	72d8 0042 	lod	A, 0x42 <.LLST2+0x6>
    8cb0:	d43f      	and	AH, #63
    8cb2:	aeda 0410 	cmp	A, #1040
    8cb6:	190c      	je	0x8cd0 <.L13>

00008cb8 <.LM45>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8cb8:	72d8 0046 	lod	A, 0x46 <.LLST2+0xa>
    8cbc:	d43f      	and	AH, #63

00008cbe <.LM46>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8cbe:	aeda 0410 	cmp	A, #1040
    8cc2:	1906      	je	0x8cd0 <.L13>

00008cc4 <.LM47>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
    8cc4:	72d8 004a 	lod	A, 0x4a <.LLST2+0xe>
    8cc8:	d43f      	and	AH, #63

00008cca <.LM48>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8cca:	aeda 0410 	cmp	A, #1040
    8cce:	1d07      	jne	0x8cde <.L14>

00008cd0 <.L13>:
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
        pPatchRevResp->identifier = EE_HOST(PATCH_CRC);
    8cd0:	7300      	lod	A, ep:0x0 <__bss_dp_size>
    8cd2:	7e05      	lod	X, [S-6]
    8cd4:	42fc      	mov	[X+4], AL
    8cd6:	6000      	lod	AL, #0
    8cd8:	72e4      	swap	A
    8cda:	42fd      	mov	[X+5], AL
    8cdc:	079d      	jmp	0x8c18 <.L26>

00008cde <.L14>:
    } else {
        pPatchRevResp->identifier = 0xFFFFu;
    8cde:	7e05      	lod	X, [S-6]
    8ce0:	2004      	add	X, #4
    8ce2:	60ff      	lod	AL, #-1
    8ce4:	42f8      	mov	[X], AL

00008ce6 <.LVL32>:
    8ce6:	42f9      	mov	[X+1], AL
    8ce8:	0797      	jmp	0x8c18 <.L26>

00008cea <_fw_low_level_init>:
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}

void fw_low_level_init(void)
{
    if (nvram_CalcCRC((uint16_t*)EE_APP_TRIM_AREA_START, EE_APP_TRIM_AREA_SIZE >> 1) == NVRAM_CORRECT_CRC) {
    8cea:	54ca 0028 	pushw	#40

00008cee <.LCFI0>:
    8cee:	72da 09b0 	lod	A, #2480
    8cf2:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    8cf6:	5c01      	dec	S, #2

00008cf8 <.LCFI1>:
    8cf8:	aeda 00ff 	cmp	A, #255
    8cfc:	1901      	je	0x8d00 <.LM3>
    8cfe:	004f      	jmp	0x8d9e <.L2>

00008d00 <.LM3>:
        /* load trimming data to io registers */
        IO_SET(TRIM1_DRV,
    8d00:	72d8 0208 	lod	A, 0x208 <_TRIM1_DRV>
    8d04:	b6da f000 	and	A, #61440
    8d08:	7ed8 09ec 	lod	X, 0x9ec <.LASF1600+0x5>
    8d0c:	3403      	and	X, #3
    8d0e:	a6ee      	or	A, X
    8d10:	7ed8 09ec 	lod	X, 0x9ec <.LASF1600+0x5>
    8d14:	36da 0ffc 	and	X, #4092
    8d18:	a6ee      	or	A, X
    8d1a:	52d8 0208 	mov	0x208 <_TRIM1_DRV>, A

00008d1e <.LM4>:
               TRIM_DRVSUP, EE_GET(TRIM_DRVSUP),             /* trim output level of driver supply */
               PRE_TRIM_DRVMOD_CPCLK, EE_GET(TRIM_CPCLK));   /* trim frequency of driver clock */
        IO_SET(TRIM2_DRV,
    8d1e:	72d8 020a 	lod	A, 0x20a <_TRIM2_DRV>
    8d22:	b6da fe00 	and	A, #65024
    8d26:	0ea7      	lod	C, ML.7
    8d28:	7ed8 09ee 	lod	X, 0x9ee <.LASF1600+0x7>
    8d2c:	340f      	and	X, #15
    8d2e:	a6ee      	or	A, X
    8d30:	7ed8 09ee 	lod	X, 0x9ee <.LASF1600+0x7>
    8d34:	36da 01f0 	and	X, #496
    8d38:	a6ee      	or	A, X
    8d3a:	52d8 020a 	mov	0x20a <_TRIM2_DRV>, A

00008d3e <.LM5>:
               TRIM_SLWRT, EE_GET(TRIM_SLWRT),               /* trim slewrate / slope of drivers */
               TRIM_CSA_GAIN, EE_GET(TRIM_CSA_GAIN));        /* trim gain of current sense amplifier */
        IO_SET(TRIM3_DRV,
    8d3e:	62d8 09f1 	lod	AL, 0x9f1 <.LASF1600+0xa>
    8d42:	42d8 020c 	mov	0x20c <_TRIM3_DRV>, AL

00008d46 <.LM6>:
               TRIM_CSA_CL, EE_GET(TRIM_CSA_CL_LOW));        /* trim over-current limit of current sense amplifier */
        IO_SET(TRIM_MISC,
    8d46:	0ea7      	lod	C, ML.7
    8d48:	72d8 0206 	lod	A, 0x206 <_TRIM_MISC>
    8d4c:	b6da c000 	and	A, #49152
    8d50:	7ed8 09f2 	lod	X, 0x9f2 <.LASF1600+0xb>
    8d54:	0ea7      	lod	C, ML.7
    8d56:	36da 0fc0 	and	X, #4032
    8d5a:	a6ee      	or	A, X
    8d5c:	7ed8 09f2 	lod	X, 0x9f2 <.LASF1600+0xb>
    8d60:	36da 3000 	and	X, #12288
    8d64:	a6ee      	or	A, X
    8d66:	7ad8 09d0 	lod	Y, 0x9d0 <.LLST18>
    8d6a:	7ae8      	swap	Y
    8d6c:	f43f      	and	Y, #63
    8d6e:	a6e6      	or	A, Y
    8d70:	52d8 0206 	mov	0x206 <_TRIM_MISC>, A

00008d74 <.LM7>:
               TRIM_OTD, EE_GET(TRIM_OTD),                   /* trim over temperature detection */
               TRIM_SDAFILT_IO, EE_GET(TRIM_SDAFILT_IO),     /* trim i2c sda filter/delay time */
               TRIM_LCD_LINAA, EE_GET(LINAA_TRIM_LCD_205));  /* trim linaa current */
        IO_SET(PORT_LINAA2,
    8d74:	62d8 0204 	lod	AL, 0x204 <_PORT_LINAA2>
    8d78:	94f8      	and	AL, #-8
    8d7a:	7ad8 09d0 	lod	Y, 0x9d0 <.LLST18>
    8d7e:	44c6      	rl	Y, #2
    8d80:	f403      	and	Y, #3
    8d82:	86e8      	or	AL, YL
    8d84:	42d8 0204 	mov	0x204 <_PORT_LINAA2>, AL

00008d88 <.LM8>:
               LCD_SEL_LINAA, EE_GET(LINAA_LCD_SEL_205));    /* select adjustment of linaa current */
        IO_SET(PORT_LINAA1,
    8d88:	7ed8 0202 	lod	X, 0x202 <_PORT_LINAA1>
    8d8c:	72d8 09d2 	lod	A, 0x9d2 <.LLST18+0x2>
    8d90:	6000      	lod	AL, #0
    8d92:	72e4      	swap	A
    8d94:	36da fe00 	and	X, #65024
    8d98:	a6ee      	or	A, X
    8d9a:	52d8 0202 	mov	0x202 <_PORT_LINAA1>, A

00008d9e <.L2>:
               LINAA_DIV, EE_GET(LINAA_DIV));                /* linaa amplifier common-mode rejection adjustment */
    } else {
        /* load default values */
    }

    IO_SET(PORT_SUPP_CFG,
    8d9e:	605f      	lod	AL, #95
    8da0:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00008da4 <.LM10>:
           UV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS under voltage */
           OV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS over voltage */
           OVC_FILT_SEL, 0u,                        /* 1-2us filtering for over current */
           OVT_FILT_SEL, 1u);                       /* 100-110us filtering for over temperature */

    IO_SET(PORT_MISC_OUT, SEL_TEMP, 8u);            /* temperature channel selection */
    8da4:	62d8 01f3 	lod	AL, 0x1f3 <_PORT_MISC_OUT+0x1>
    8da8:	940f      	and	AL, #15
    8daa:	8480      	or	AL, #-128
    8dac:	42d8 01f3 	mov	0x1f3 <_PORT_MISC_OUT+0x1>, AL

00008db0 <.LM11>:

    IO_SET(PORT_MISC2_OUT, ENABLE_OTD, 1u);         /* enable over-temperature detector */
    8db0:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    8db4:	8402      	or	AL, #2
    8db6:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

00008dba <.LM12>:

    IO_SET(PORT_DRV1_PROT, OC_PM, 1u);              /* switch drivers to tri-state in case of over-current */
    8dba:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    8dbe:	8404      	or	AL, #4
    8dc0:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

00008dc4 <.LM13>:
}
    8dc4:	5401      	ret

00008dc6 <_fw_premain>:

void fw_premain(void)
{
	/* Initialize watch-dogs, both analogue and digital */
//	WDG_disableIwdIt();
    fw_low_level_init();            /* optionally call more low level initialization */
    8dc6:	1791      	call	0x8cea <_fw_low_level_init>

00008dc8 <.LM16>:

    fw_ram_section_init();          /* RAM initialization */
    8dc8:	100b      	call	0x8de0 <_fw_ram_section_init>

00008dca <.LM17>:
#if defined (HAS_PATCH_COLIN)
    patch_colin_Init();
#endif /* HAS_PATCH_COLIN */

#if defined (HAS_MLS_API)
    fw_mls_Init();                  /* MLX LIN Slave initialization */
    8dca:	1679      	call	0x8abe <_fw_mls_Init>

00008dcc <.LM18>:
#endif /* HAS_MLS_API */

#if defined (HAS_STD_LIN_API) || defined (HAS_MLS_DEVICE_ID) || defined (HAS_MLS_LOADER)
    fw_mls_TransportLayerInit();
    8dcc:	16ae      	call	0x8b2a <_fw_mls_TransportLayerInit>

00008dce <.LM19>:
#endif /* HAS_STD_LIN_API || HAS_MLS_DEVICE_ID || defined (HAS_MLS_LOADER) */

#if defined (HAS_MLS_DEVICE_ID)
    fw_lepm_Init();                 /* MLX LIN device ID initialization */
    8dce:	16d8      	call	0x8b80 <_fw_lepm_Init>

00008dd0 <.LBB6>:
    ac_sel = 0u;
#elif FPLL == 28000
    tmp.u = EE_MS_TRIM7_VALUE;
    ac_sel = 0u;
#elif FPLL == 32000
    tmp.u = EE_MS_TRIM8_VALUE;
    8dd0:	72d8 0a12 	lod	A, 0xa12 <.LLST17+0x3>

00008dd4 <.LM21>:
    ac_sel = 0u;
#else
    #warning "Clock Speed not valid, use 32MHz"
#endif

    SetSystemSpeed(tmp, ac_sel);
    8dd4:	54ca 0000 	pushw	#0

00008dd8 <.LCFI2>:
    8dd8:	82db 5196 	callf	0xa32c <_SetSystemSpeed>

00008ddc <.LBB8>:
        );
}

STATIC INLINE void builtin_mlx16_set_priority(uint8_t level)
{
    __asm__ __volatile__ (
    8ddc:	54f7      	mov	UPr, #7

00008dde <.LBE8>:
    mls_loader_Init();
#endif /* HAS_MLS_LOADER */

    set_Clock_Speed();              /* set clock speed */
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}
    8dde:	5403      	ret	#4

00008de0 <_fw_ram_section_init>:
#if !defined(RAM_APPLICATION)
    uint16_t* r;
#endif /* !RAM_APPLICATION */

    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    8de0:	7ada 101a 	lod	Y, #4122
    8de4:	eeda 101a 	cmp	Y, #4122
    8de8:	1c08      	jnc	0x8dfa <.L2>
    8dea:	7eda 101a 	lod	X, #4122
    8dee:	2ae6      	sub	X, Y
    8df0:	1904      	je	0x8dfa <.L2>
    8df2:	443e      	lsr	X
    8df4:	7000      	lod	A, #0
    8df6:	52d6      	mov	[Y++], A

00008df8 <L0>:
    8df8:	1bfe      	djnz	X, 0x8df6 <.LASF231+0x7>

00008dfa <.L2>:
        *w++ = 0;
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    8dfa:	7ada 10aa 	lod	Y, #4266
    8dfe:	eeda 1452 	cmp	Y, #5202
    8e02:	1c08      	jnc	0x8e14 <.L4>
    8e04:	7eda 1452 	lod	X, #5202
    8e08:	2ae6      	sub	X, Y
    8e0a:	1904      	je	0x8e14 <.L4>
    8e0c:	443e      	lsr	X
    8e0e:	7000      	lod	A, #0
    8e10:	52d6      	mov	[Y++], A

00008e12 <L0>:
    8e12:	1bfe      	djnz	X, 0x8e10 <.LASF1033+0xa>

00008e14 <.L4>:

#if !defined(RAM_APPLICATION)   /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    8e14:	7ada 1012 	lod	Y, #4114
    8e18:	7eda 5b26 	lod	X, #23334

00008e1c <.L26>:
    8e1c:	eeda 101a 	cmp	Y, #4122
    8e20:	1c03      	jnc	0x8e28 <.L6>
    8e22:	0ea7      	lod	C, ML.7
    8e24:	54ce      	movsw	[Y++], [X++]
    8e26:	07fa      	jmp	0x8e1c <.L26>

00008e28 <.L6>:
        *w++ = *r++;
    }

    for (w = &_data_start; w < &_data_end; ) {
    8e28:	7ada 101a 	lod	Y, #4122

00008e2c <.L25>:
    8e2c:	eeda 10aa 	cmp	Y, #4266
    8e30:	1c03      	jnc	0x8e38 <.L8>
    8e32:	0ea7      	lod	C, ML.7
    8e34:	54ce      	movsw	[Y++], [X++]
    8e36:	07fa      	jmp	0x8e2c <.L25>

00008e38 <.L8>:
    }
#endif /* !RAM_APPLICATION */

#if defined (HAS_MLS_API)
    r = &_mlx4_cst_tables_ram_load_start;
    for (w = &_mlx4_cst_tables_ram_start; w < &_mlx4_cst_tables_ram_end; ) {
    8e38:	7eda 0e80 	lod	X, #3712
    8e3c:	2eda 0ede 	cmp	X, #3806
    8e40:	1c07      	jnc	0x8e50 <.L10>
    8e42:	7ada 5a40 	lod	Y, #23104

00008e46 <.L11>:
    8e46:	0ea7      	lod	C, ML.7
    8e48:	54c6      	movsw	[X++], [Y++]
    8e4a:	2eda 0ede 	cmp	X, #3806
    8e4e:	187b      	jc	0x8e46 <.L11>

00008e50 <.L10>:
        *w++ = *r++;
    }

    r = &_mlx4_flash_table_load_start;
    for (w = &_mlx4_flash_table_start; w < &_mlx4_flash_table_end; ) {
    8e50:	7eda 0f00 	lod	X, #3840
    8e54:	2eda 0f88 	cmp	X, #3976
    8e58:	1c07      	jnc	0x8e68 <.L1>
    8e5a:	7ada 5a9e 	lod	Y, #23198

00008e5e <.L13>:
    8e5e:	0ea7      	lod	C, ML.7
    8e60:	54c6      	movsw	[X++], [Y++]
    8e62:	2eda 0f88 	cmp	X, #3976
    8e66:	187b      	jc	0x8e5e <.L13>

00008e68 <.L1>:
        *w++ = *r++;
    }
#endif /* HAS_MLS_API */
}
    8e68:	5401      	ret

00008e6a <_fw_start>:
#include "sys_tools.h"
#endif

STATIC INLINE void Sys_SetStack(const uint16_t* const stackptr)
{
    __asm__ __volatile__ (
    8e6a:	72da 1452 	lod	A, #5202
    8e6e:	52ef      	mov	S, A

00008e70 <.LBB136>:
    return (stack_pointer);
}

STATIC INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    8e70:	7000      	lod	A, #0
    8e72:	52e3      	mov	M, A

00008e74 <.LBE136>:
	}

}
#endif								 
    /* set priorities to lowest level */
    IO_SET(MLX16, ITC_PRIO0, 0xFFFFu);
    8e74:	70ff      	lod	A, #-1
    8e76:	52d8 0088 	mov	0x88 <__mlx4_flash_table_size>, A

00008e7a <.LM5>:
    IO_SET(MLX16, ITC_PRIO1, 0xFFFFu);
    8e7a:	0ea7      	lod	C, ML.7
    8e7c:	52d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, A

00008e80 <.LM6>:
    IO_SET(MLX16, ITC_PRIO2, 0xFFFFu);
    8e80:	52d8 008c 	mov	0x8c <.LASF1529>, A

00008e84 <.LM7>:
    IO_SET(MLX16, ITC_PRIO3, 0xFFFFu);
    8e84:	52d8 008e 	mov	0x8e <.LASF1529+0x2>, A

00008e88 <.LM8>:
    IO_SET(MLX16, ITC_PRIO4, 0xFFFFu);
    8e88:	0ea7      	lod	C, ML.7
    8e8a:	52d8 0090 	mov	0x90 <__data_size>, A

00008e8e <.LM9>:
    IO_SET(MLX16, ITC_PRIO5, 0xFFFFu);
    8e8e:	52d8 0092 	mov	0x92 <__data_size+0x2>, A

00008e92 <.LBB138>:
STATIC INLINE void MotorDriverUVWTSelectSource(DrvCtrlSelect_t drvctrl_u,
                                               DrvCtrlSelect_t drvctrl_v,
                                               DrvCtrlSelect_t drvctrl_w,
                                               DrvCtrlSelect_t drvctrl_t)
{
    IO_SET(PORT_DRV_CTRL,
    8e92:	72da eeee 	lod	A, #61166
    8e96:	0ea7      	lod	C, ML.7
    8e98:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00008e9c <.LBE138>:

    /* all phases in tri-state explicitly */
    MotorDriverUVWTSelectSource(DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE);

    fw_premain();           /* Don't make this functions static to be sure its local variable will not apear before the SP assignment */
    8e9c:	1794      	call	0x8dc6 <_fw_premain>

00008e9e <.LM12>:

    __asm__ ("JMP _main\n\t" ::); /* jump to the main function */
    8e9e:	76da 4cbd 	jmpf	0x997a <_main>

00008ea2 <.LM13>:
}
    8ea2:	5401      	ret

00008ea4 <_ld_AppDiagRequest>:
    {
        transfer->response.respSId = transfer->request.reqSId + 0x40;
    }

    return retVal;
}
    8ea4:	7000      	lod	A, #0

00008ea6 <.LVL1>:
    8ea6:	5401      	ret

00008ea8 <_lin22_Init>:
 *
 * This function initialize the lin module and it will assign
 * the default frame ids to the different messages.
 */
void lin22_Init(void)
{
    8ea8:	5801      	inc	S, #2

00008eaa <.LCFI0>:
    (void)l_sys_init();
    8eaa:	12c2      	call	0x9430 <_l_sys_init>

00008eac <.LM7>:
    (void)l_ifc_init_sl1();
    8eac:	12ea      	call	0x9482 <_l_ifc_init_sl1>

00008eae <.LM8>:

#if 0 //(SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    (void)ld_set_configuration(ifcSlave_1, lin_config, lin_cfg_len);
#else
    (void)ml_Disconnect();
    8eae:	82db 11f0 	callf	0x23e0 <_ml_Disconnect>

00008eb2 <.LBB281>:
    for (uint8_t index = 0u; index < (lin_cfg_len - 1); index++)
    {
        (void)ml_AssignFrameToMessageID(index, lin_config[1 + index]);
    8eb2:	54ca 0092 	pushw	#146

00008eb6 <.LCFI1>:
    8eb6:	7000      	lod	A, #0
    8eb8:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    8ebc:	54ca 0011 	pushw	#17

00008ec0 <.LCFI2>:
    8ec0:	7001      	lod	A, #1
    8ec2:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    8ec6:	54ca 00f0 	pushw	#240

00008eca <.LCFI3>:
    8eca:	7002      	lod	A, #2
    8ecc:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>

00008ed0 <.LBE281>:
    }
    (void)ml_Connect();
    8ed0:	82db 11ee 	callf	0x23dc <_ml_Connect>

00008ed4 <.LM11>:

    ml_ConfiguredNAD = lin_config[0];
    8ed4:	6401      	lod	YL, #1
    8ed6:	46d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, YL

00008eda <.LM12>:
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

#if (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1)
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_AppDiagRequest);
    8eda:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    8ede:	201a      	add	X, #26
    8ee0:	54ca 4752 	pushw	#18258

00008ee4 <.LCFI4>:
    8ee4:	72f8      	lod	A, [X]
    8ee6:	5a09      	mov	[S-10], Y
    8ee8:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008eec <.LM13>:
#endif /* (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1) */

    /* register a timer for SL_LD_N_AS_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINAS, (SL_LD_N_AS_TIMEOUT / TO_N_AS_TIMEOUT_TICKS), REPETITIVE);
    8eec:	54ca 0001 	pushw	#1

00008ef0 <.LCFI5>:
    8ef0:	54ca 0001 	pushw	#1

00008ef4 <.LCFI6>:
    8ef4:	7001      	lod	A, #1
    8ef6:	82db 4f45 	callf	0x9e8a <_swtimer_register>

00008efa <.LM14>:
    swtimer_start(SWTIMER_LINAS);
    8efa:	7001      	lod	A, #1
    8efc:	82db 4f5b 	callf	0x9eb6 <_swtimer_start>

00008f00 <.LM15>:

    /* register a timer for SL_LD_N_CR_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINCR, (SL_LD_N_CR_TIMEOUT / TO_N_CR_TIMEOUT_TICKS), REPETITIVE);
    8f00:	54ca 0001 	pushw	#1

00008f04 <.LCFI7>:
    8f04:	54ca 0001 	pushw	#1

00008f08 <.LCFI8>:
    8f08:	0ea7      	lod	C, ML.7
    8f0a:	7002      	lod	A, #2
    8f0c:	82db 4f45 	callf	0x9e8a <_swtimer_register>

00008f10 <.LM16>:
    swtimer_start(SWTIMER_LINCR);
    8f10:	7002      	lod	A, #2
    8f12:	82db 4f5b 	callf	0x9eb6 <_swtimer_start>

00008f16 <.LM17>:

    /* register a timer for COLIN check timeout */
    swtimer_register(SWTIMER_CHECKCOLIN, COLIN_CHECK_TIMEOUT, REPETITIVE);
    8f16:	54ca 0001 	pushw	#1

00008f1a <.LCFI9>:
    8f1a:	54ca 0bb8 	pushw	#3000

00008f1e <.LCFI10>:
    8f1e:	0ea7      	lod	C, ML.7
    8f20:	7000      	lod	A, #0
    8f22:	82db 4f45 	callf	0x9e8a <_swtimer_register>

00008f26 <.LM18>:
    swtimer_start(SWTIMER_CHECKCOLIN);
    8f26:	7000      	lod	A, #0
    8f28:	82db 4f5b 	callf	0x9eb6 <_swtimer_start>

00008f2c <.LM19>:
#if DEBUG_DB_B2 == 1
    adc_RegisterIRQ2(B2_exit);
#endif
#endif

    bLinActive = true;
    8f2c:	7a15      	lod	Y, [S-22]
    8f2e:	46d8 118c 	mov	0x118c <_bLinActive>, YL

00008f32 <.LM20>:
    bLinTimeoutActive = 0;
    8f32:	6000      	lod	AL, #0
    8f34:	42d8 118b 	mov	0x118b <_bLinTimeoutActive>, AL

00008f38 <.LCFI11>:
}
    8f38:	5417      	ret	#24

00008f3a <_lin22_CheckColin>:
    }
}

/** Check the status of the COLIN module and handle accordingly */
void lin22_CheckColin(void)
{
    8f3a:	5801      	inc	S, #2

00008f3c <.LBB374>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8f3c:	7ae3      	lod	Y, M

00008f3e <.LBB377>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8f3e:	08b2      	clrb	MH.2
    8f40:	08b1      	clrb	MH.1
    8f42:	08b0      	clrb	MH.0

00008f44 <.LBE377>:
    static uint8_t u8ColinErrorState = 0u;
    ml_LinState_t ColinState;

    ENTER_SECTION(ATOMIC_KEEP_MODE);
    ColinState = ml_GetState(ML_CLR_LIN_BUS_ACTIVITY);
    8f44:	7008      	lod	A, #8
    8f46:	5a01      	mov	[S-2], Y
    8f48:	82db 11d3 	callf	0x23a6 <_ml_GetState>

00008f4c <.LBB380>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8f4c:	7a01      	lod	Y, [S-2]
    8f4e:	5ae3      	mov	M, Y

00008f50 <.LBE374>:
    EXIT_SECTION();

    if (ColinState != ml_stINVALID)
    8f50:	acff      	cmp	A, #-1
    8f52:	1912      	je	0x8f78 <.L6>

00008f54 <.LM39>:
    {
        /* COLIN is responding */
        if (COLIN_LINstatus.event_overflow != 0u)
    8f54:	62d8 0e2f 	lod	AL, 0xe2f <.LASF1987+0x9>

00008f58 <.LVL24>:
    8f58:	9408      	and	AL, #8
    8f5a:	1919      	je	0x8f8e <.L5>

00008f5c <.LBB384>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8f5c:	7ae3      	lod	Y, M

00008f5e <.LBB387>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8f5e:	08b2      	clrb	MH.2
    8f60:	08b1      	clrb	MH.1
    8f62:	08b0      	clrb	MH.0

00008f64 <.LBE387>:
        {
            /* command overflow was detected */
            ENTER_SECTION(ATOMIC_KEEP_MODE);
            (void)ml_GetState(ML_CLR_LIN_CMD_OVERFLOW);
    8f64:	7001      	lod	A, #1
    8f66:	5a01      	mov	[S-2], Y
    8f68:	82db 11d3 	callf	0x23a6 <_ml_GetState>

00008f6c <.LBB390>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8f6c:	7a01      	lod	Y, [S-2]
    8f6e:	5ae3      	mov	M, Y

00008f70 <.LBE384>:
            EXIT_SECTION();

            /* do handshake MLX16 <> COLIN */
            ml_SetSLVCMD(0x42u);
    8f70:	7042      	lod	A, #66
    8f72:	82db 1224 	callf	0x2448 <_ml_SetSLVCMD>
    8f76:	5403      	ret	#4

00008f78 <.L6>:
        }
    }
    else
    {
        /* COLIN response time-out */
        u8ColinErrorState++;
    8f78:	62d8 118a 	lod	AL, 0x118a <___u8ColinErrorState_7232>

00008f7c <.LVL30>:
    8f7c:	8001      	add	AL, #1
    8f7e:	42d8 118a 	mov	0x118a <___u8ColinErrorState_7232>, AL

00008f82 <.LM46>:

        if (u8ColinErrorState >= 4u)
    8f82:	8c03      	cmp	AL, #3
    8f84:	1a04      	jule	0x8f8e <.L5>

00008f86 <.LBB394>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    8f86:	5048      	call	fp2:0x40

00008f88 <.LBE397>:
}

STATIC INLINE NO_RETURN void Sys_ResetCpu (void)
{
    (void) mlx16_enter_system_mode_keep_prio();
    IO_SET(RST_CTRL, SOFT_RESET, 1u);    /* Reset happens immediately after writing SOFT_RESET bit */
    8f88:	6283      	lod	AL, io:0x3 <_RST_CTRL+0x1>
    8f8a:	8420      	or	AL, #32
    8f8c:	4283      	mov	io:0x3 <_RST_CTRL+0x1>, AL

00008f8e <.L5>:
        {
            /* COLIN has not been responding to often, lets reset the module */
            Sys_ResetCpu();
        }
    }
}
    8f8e:	5403      	ret	#4

00008f90 <_lin22_BackgroundHandler>:
void lin22_BackgroundHandler(void)
{

#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    l_s_IfcStatus_t status;
    status.word = l_ifc_read_status_sl1();
    8f90:	1282      	call	0x9496 <_l_ifc_read_status_sl1>

00008f92 <.LM52>:
        /* nothing to be done */
    }
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

    /* Check LIN AS-timeout */
    if (swtimer_isTriggered(SWTIMER_LINAS))
    8f92:	7001      	lod	A, #1
    8f94:	82db 4f6c 	callf	0x9ed8 <_swtimer_isTriggered>
    8f98:	ac00      	cmp	A, #0
    8f9a:	1906      	je	0x8fa8 <.L13>

00008f9c <.LM53>:
    {
        ldt_Tick(100u / TO_N_AS_TIMEOUT_TICKS, 0u);
    8f9c:	54ca 0000 	pushw	#0

00008fa0 <.LCFI14>:
    8fa0:	7000      	lod	A, #0
    8fa2:	82db 524c 	callf	0xa498 <_ldt_Tick>
    8fa6:	5c01      	dec	S, #2

00008fa8 <.L13>:
    }

    /* Check LIN CR-timeout */
    if (swtimer_isTriggered(SWTIMER_LINCR))
    8fa8:	7002      	lod	A, #2
    8faa:	82db 4f6c 	callf	0x9ed8 <_swtimer_isTriggered>
    8fae:	ac00      	cmp	A, #0
    8fb0:	1906      	je	0x8fbe <.L14>

00008fb2 <.LM55>:
    {
        ldt_Tick(0u, 100u / TO_N_CR_TIMEOUT_TICKS);
    8fb2:	54ca 0000 	pushw	#0

00008fb6 <.LCFI16>:
    8fb6:	7000      	lod	A, #0
    8fb8:	82db 524c 	callf	0xa498 <_ldt_Tick>
    8fbc:	5c01      	dec	S, #2

00008fbe <.L14>:
    }

    if (swtimer_isTriggered(SWTIMER_CHECKCOLIN))
    8fbe:	7000      	lod	A, #0
    8fc0:	82db 4f6c 	callf	0x9ed8 <_swtimer_isTriggered>
    8fc4:	ac00      	cmp	A, #0
    8fc6:	1901      	je	0x8fca <.L12>

00008fc8 <.LM57>:
    {
        /* check COLIN state */
        lin22_CheckColin();
    8fc8:	17b8      	call	0x8f3a <_lin22_CheckColin>

00008fca <.L12>:
    }
}
    8fca:	5401      	ret

00008fcc <_ld_serial_number_callout>:
 * This function is called by the lin driver on receipt of a
 * read by id 0x00 request.
 * @param[out]  data  pointer to the data to be filled
 */
void ld_serial_number_callout(l_u8 data[4])
{
    8fcc:	7ee2      	lod	X, A

00008fce <.LM60>:
    data[0] = (l_u8)(EE_CHIP_ID_0); /* LSB */
    8fce:	7ada 0a30 	lod	Y, #2608
    8fd2:	0ea7      	lod	C, ML.7
    8fd4:	54c4      	movsb	[X++], [Y++]

00008fd6 <.LM61>:
    data[1] = (l_u8)(EE_CHIP_ID_0 >> 8);
    8fd6:	54c4      	movsb	[X++], [Y++]

00008fd8 <.LM62>:
    data[2] = (l_u8)(EE_CHIP_ID_1);
    8fd8:	7ada 0a32 	lod	Y, #2610
    8fdc:	0ea7      	lod	C, ML.7
    8fde:	54c4      	movsb	[X++], [Y++]

00008fe0 <.LM63>:
    data[3] = (l_u8)(EE_CHIP_ID_1 >> 8); /* MSB */
    8fe0:	54c4      	movsb	[X++], [Y++]

00008fe2 <.LM64>:
}
    8fe2:	5401      	ret

00008fe4 <_fw_lepm_ApplicationStop>:
 * @retval  true   command has been handled successful;
 * @retval  false  command has not been handled successful;
 */
bool fw_lepm_ApplicationStop(void)
{
    adc_Stop();
    8fe4:	82db 3c10 	callf	0x7820 <_adc_Stop>

00008fe8 <.LM67>:
    pwm_Disable();
    8fe8:	82db 4ebc 	callf	0x9d78 <_pwm_Disable>

00008fec <.LM68>:
    swtimer_deinit();
    8fec:	82db 4f2d 	callf	0x9e5a <_swtimer_deinit>

00008ff0 <.LM69>:
    return (true); /* return that the application has stopped */
}
    8ff0:	7001      	lod	A, #1
    8ff2:	5401      	ret

00008ff4 <_lin22_GotoSleep>:
 * This function will never return, after the chip went into sleep mode
 * it will wake up again via a power on sequence.
 */
void lin22_GotoSleep(void)
{
    (void)fw_lepm_ApplicationStop(); /* stop the application */
    8ff4:	17f7      	call	0x8fe4 <_fw_lepm_ApplicationStop>

00008ff6 <.LBB399>:
    8ff6:	5048      	call	fp2:0x40

00008ff8 <.LBB401>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8ff8:	08b2      	clrb	MH.2
    8ffa:	08b1      	clrb	MH.1
    8ffc:	08b0      	clrb	MH.0

00008ffe <.LBB403>:
    SetRstatFlag();
}

STATIC INLINE void disallowWarmReboot(void)
{
    ResetRstatFlag();
    8ffe:	82db 1508 	callf	0x2a10 <_ResetRstatFlag>

00009002 <.LM75>:
    bistHeader = C_CHIP_HEADER_INVALID;
    9002:	7000      	lod	A, #0
    9004:	52d8 17f8 	mov	0x17f8 <_bistHeader>, A

00009008 <.LBB405>:
#endif
	return result;
}
static __attribute__((always_inline)) inline uint16_t IO_AWD__WIN_OPEN_GET (void) {
	register uint16_t result;
	asm volatile (
    9008:	0f7f      	lod	C, io:0x0f.7

0000900a <.LBE407>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    900a:	1c01      	jnc	0x900e <.L28>

0000900c <.LM78>:
        IO_SET(AWD, ACK, 1u);
    900c:	0b76      	setb	io:0x0e.6

0000900e <.L28>:

    disallowWarmReboot(); /* warm reboot is not allowed any more */

    WDG_conditionalAwdRefresh(); /* refresh the timers if they're used */

    IO_SET(SPI, STOP, 1u); /* stop the SPI despite it's running or not */
    900e:	62d8 0132 	lod	AL, 0x132 <_SPI+0xa>
    9012:	94fc      	and	AL, #-4
    9014:	8402      	or	AL, #2
    9016:	42d8 0132 	mov	0x132 <_SPI+0xa>, AL

0000901a <.LM80>:

    //    IO_SET(PORT_MISC2_OUT, WU_IO_EN, 0u);           /* disable wake up on IO0 */
    IO_SET(PORT_MISC2_OUT, WU_IO_EN, 1u); /* enable wake up on IO0 */ // 250702-3 Support Sleep by IO0.
    901a:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    901e:	8401      	or	AL, #1
    9020:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

00009024 <.LM81>:
    ml_ResetDrv();                                                    /* stop the MLX4 */
    9024:	82db 122f 	callf	0x245e <_ml_ResetDrv>

00009028 <.L29>:

    /* wait for EEPROM operations */
    while (IO_GET(EEPROM_FLASH, EE_BUSY) != 0u)
    9028:	72d8 0186 	lod	A, 0x186 <.LASF1965+0x3>
    902c:	ac00      	cmp	A, #0
    902e:	1afc      	jsl	0x9028 <.L29>

00009030 <.L30>:
    {
    }
    /* wait for Flash operations */
    while ((IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM) ||
    9030:	72d8 017c 	lod	A, 0x17c <_EEPROM_FLASH+0x6>
    9034:	940f      	and	AL, #15
    9036:	8c04      	cmp	AL, #4
    9038:	197b      	je	0x9030 <.L30>

0000903a <.LM84>:
           (IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE))
    903a:	72d8 017c 	lod	A, 0x17c <_EEPROM_FLASH+0x6>

0000903e <.LM85>:
    /* wait for EEPROM operations */
    while (IO_GET(EEPROM_FLASH, EE_BUSY) != 0u)
    {
    }
    /* wait for Flash operations */
    while ((IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM) ||
    903e:	940f      	and	AL, #15
    9040:	8c03      	cmp	AL, #3
    9042:	1976      	je	0x9030 <.L30>

00009044 <.LM86>:
           (IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE))
    {
    }

    /* stop MLX16 */
    __asm__("HALT\n\t");
    9044:	42c9      	halt

00009046 <.LBB409>:
    9046:	5048      	call	fp2:0x40

00009048 <.LBE411>:
    9048:	6283      	lod	AL, io:0x3 <_RST_CTRL+0x1>
    904a:	8420      	or	AL, #32
    904c:	4283      	mov	io:0x3 <_RST_CTRL+0x1>, AL

0000904e <_ld_read_by_id_callout>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    904e:	580d      	inc	S, #14

00009050 <.LCFI18>:
    l_u8 u8Return;
    (void)iii;
    switch (id)
    9050:	6211      	lod	AL, [S-18]

00009052 <.LVL46>:
    9052:	8c2b      	cmp	AL, #43
    9054:	1923      	je	0x909c <.L39>
    9056:	5cf2      	usex	A
    9058:	ac2c      	cmp	A, #44
    905a:	192c      	je	0x90b4 <.L40>
    905c:	ac21      	cmp	A, #33
    905e:	1901      	je	0x9062 <.LBB413>
    9060:	003e      	jmp	0x90de <.L43>

00009062 <.LBB413>:
    {
    case 0x21u:
    {
        uint8_t lin_cfg_len = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1u;
        uint8_t lin_config[1 + SL_NUMBER_OF_DYNAMIC_MESSAGES] = SL_NODE_CONFIGURATION_INITIALIZER;
    9062:	7eef      	lod	X, S
    9064:	20f2      	add	X, #-14
    9066:	7ada 5bbe 	lod	Y, #23486
    906a:	0ea7      	lod	C, ML.7
    906c:	54c4      	movsb	[X++], [Y++]
    906e:	54c4      	movsb	[X++], [Y++]
    9070:	54c4      	movsb	[X++], [Y++]
    9072:	54c4      	movsb	[X++], [Y++]

00009074 <.LM92>:

        /* Verify NAD */
#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
        (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    9074:	54ca 0004 	pushw	#4

00009078 <.LCFI19>:
    9078:	7aef      	lod	Y, S
    907a:	e0f0      	add	Y, #-16
    907c:	72e6      	lod	A, Y
    907e:	5a07      	mov	[S-8], Y
    9080:	141e      	call	0x88be <_eeprom_ReadLINconfig>

00009082 <.LM93>:

        *pci = 8u; /* 7-bytes of data + 1 */
    9082:	7e15      	lod	X, [S-22]
    9084:	6008      	lod	AL, #8
    9086:	42f8      	mov	[X], AL
    9088:	7e17      	lod	X, [S-24]
    908a:	7a07      	lod	Y, [S-8]
    908c:	0ea7      	lod	C, ML.7
    908e:	54c4      	movsb	[X++], [Y++]
    9090:	54c4      	movsb	[X++], [Y++]
    9092:	54c4      	movsb	[X++], [Y++]
    9094:	54c4      	movsb	[X++], [Y++]
    9096:	5c01      	dec	S, #2

00009098 <.L44>:
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
        data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
        data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
        data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
        data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
        u8Return = LD_POSITIVE_RESPONSE;
    9098:	7007      	lod	A, #7

0000909a <.LM95>:
        break;
    909a:	540f      	ret	#16

0000909c <.L39>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    909c:	7e13      	lod	X, [S-20]

0000909e <.LM97>:
        break;
    }

    case 0x2Bu:
    {
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
    909e:	6005      	lod	AL, #5
    90a0:	42f8      	mov	[X], AL

000090a2 <.LM98>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    90a2:	7e15      	lod	X, [S-22]

000090a4 <.LM99>:
    }

    case 0x2Bu:
    {
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
        data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
    90a4:	6002      	lod	AL, #2
    90a6:	42f8      	mov	[X], AL

000090a8 <.LM100>:
        data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
    90a8:	600b      	lod	AL, #11
    90aa:	42f9      	mov	[X+1], AL

000090ac <.LM101>:
        data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
    90ac:	6000      	lod	AL, #0
    90ae:	42fa      	mov	[X+2], AL

000090b0 <.LM102>:
        data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
    90b0:	42fb      	mov	[X+3], AL
    90b2:	07f2      	jmp	0x9098 <.L44>

000090b4 <.L40>:
        break;
    }

    case 0x2Cu:
    {
        uint32_t version = VERSION_getFwAppVersion();
    90b4:	82db 5200 	callf	0xa400 <_VERSION_getFwAppVersion>
    90b8:	58a0      	mov	[S-4], YA

000090ba <.LM104>:
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
    90ba:	7e13      	lod	X, [S-20]
    90bc:	6405      	lod	YL, #5
    90be:	46f8      	mov	[X], YL

000090c0 <.LM105>:
        data[0] = (uint8_t)(version >> 24);
    90c0:	58e0      	mov	YA, [S-4]
    90c2:	48af      	lsr	YA, #16
    90c4:	48a7      	lsr	YA, #8

000090c6 <.LVL55>:
    90c6:	58a3      	mov	[S-10], YA
    90c8:	7e15      	lod	X, [S-22]
    90ca:	42f8      	mov	[X], AL

000090cc <.LM106>:
        data[1] = (uint8_t)(version >> 16);
    90cc:	6601      	lod	YL, [S-2]
    90ce:	46f9      	mov	[X+1], YL

000090d0 <.LM107>:
        data[2] = (uint8_t)(version >> 8);
    90d0:	58e0      	mov	YA, [S-4]
    90d2:	48a7      	lsr	YA, #8
    90d4:	58a3      	mov	[S-10], YA
    90d6:	42fa      	mov	[X+2], AL

000090d8 <.LM108>:
        data[3] = (uint8_t)(version >> 0);
    90d8:	6603      	lod	YL, [S-4]
    90da:	46fb      	mov	[X+3], YL
    90dc:	07dd      	jmp	0x9098 <.L44>

000090de <.L43>:
        u8Return = LD_POSITIVE_RESPONSE;
        break;
    }

    default:
        u8Return = LD_NEGATIVE_RESPONSE;
    90de:	7002      	lod	A, #2

000090e0 <.LM110>:
        break;
    }

    return (u8Return);
}
    90e0:	540f      	ret	#16

000090e2 <_l_ifc_sleep_entered_callout>:
 *
 * @param[in]  Reason  Reason of entering sleep mode.
 */
void l_ifc_sleep_entered_callout(ml_SleepReason_t Reason)
{
    switch (Reason)
    90e2:	ac01      	cmp	A, #1
    90e4:	1903      	je	0x90ec <.L47>
    90e6:	ac06      	cmp	A, #6
    90e8:	1904      	je	0x90f2 <.L48>
    90ea:	5401      	ret

000090ec <.L47>:
    {
    case ml_reasonMaster:
        /* "Go-to-Sleep" frame has been received from Master */
        EVENT_GotoSleep(); // 250415 - To do act after sr
    90ec:	82db 4d5d 	callf	0x9aba <_EVENT_GotoSleep>

000090f0 <.LM114>:
        lin22_GotoSleep(); /* switch to sleep mode */
    90f0:	1781      	call	0x8ff4 <_lin22_GotoSleep>

000090f2 <.L48>:
        break;
    case ml_reasonTimeOut:
        /* Sleep State entered with a timeout with LIN bus recessive */
        bLinTimeoutActive = 1;
    90f2:	6001      	lod	AL, #1

000090f4 <.LVL62>:
    90f4:	42d8 118b 	mov	0x118b <_bLinTimeoutActive>, AL

000090f8 <.LM116>:
        EVENT_GotoSleep();
        lin22_GotoSleep(); /* switch to sleep mode */
#endif
        break;
    }
}
    90f8:	5401      	ret

000090fa <_l_mls_Init>:
    const l_u8 l_s_ver = ML_VER_DEFAULT;
#endif /* ML_MLX4_VERSION >= 412 */

    /* Start and initialize the LIN Module
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
    90fa:	54ca 7d00 	pushw	#32000

000090fe <.LCFI0>:
    90fe:	54ca 0009 	pushw	#9

00009102 <.LCFI1>:
    9102:	54ca 4b00 	pushw	#19200

00009106 <.LCFI2>:
    9106:	0ea7      	lod	C, ML.7
    9108:	7001      	lod	A, #1
    910a:	82db 52b1 	callf	0xa562 <_ml_Init>
    910e:	5c05      	dec	S, #6

00009110 <.LCFI3>:
    9110:	ac00      	cmp	A, #0
    9112:	1d3a      	jne	0x9188 <.L1>

00009114 <.LBB10>:
 * @return void
 */
static void l_mls_InitEventTable(void)
{
    /* General events processing */
    plinEventTable->mlu_LinSleepMode = l_LinSleepMode;
    9114:	7ad8 1002 	lod	Y, 0x1002 <_plinEventTable>
    9118:	7ee6      	lod	X, Y
    911a:	200a      	add	X, #10
    911c:	72da 4a69 	lod	A, #19049
    9120:	52f8      	mov	[X], A

00009122 <.LM4>:
    plinEventTable->mlu_AutoAddressingStep = l_AutoAddressingStep;
    9122:	2002      	add	X, #2
    9124:	72da 4aeb 	lod	A, #19179
    9128:	52f8      	mov	[X], A

0000912a <.LM5>:

    /* Non-diagnostic frames are processed always by std. LIN API when it's initialized
     * The std. LIN API uses event from LIN transport layer */
    plinEventTable->ldt_NonDiagMessageReceived = l_MessageReceived;
    912a:	2002      	add	X, #2
    912c:	72da 4a76 	lod	A, #19062
    9130:	52f8      	mov	[X], A

00009132 <.LM6>:
    plinEventTable->ldt_NonDiagDataRequest = l_DataRequest;
    9132:	2004      	add	X, #4
    9134:	72da 4a95 	lod	A, #19093
    9138:	52f8      	mov	[X], A

0000913a <.LM7>:
    plinEventTable->ldt_NonDiagDataTransmitted = l_DataTransmitted;
    913a:	20fe      	add	X, #-2
    913c:	72da 4ad0 	lod	A, #19152
    9140:	52f8      	mov	[X], A

00009142 <.LM8>:

    /* Subscribe to errors reporting */
    uint8_t* idx = &ld_ErrorDetectedMultipleHandler.eventsCount;
    if (*idx < ld_ErrorDetectedMultipleHandler.eventsMaxLength) {
    9142:	62d8 13f5 	lod	AL, 0x13f5 <_ld_ErrorDetectedMultipleHandler+0x3>
    9146:	5cf2      	usex	A
    9148:	7ee2      	lod	X, A
    914a:	62d8 13f4 	lod	AL, 0x13f4 <_ld_ErrorDetectedMultipleHandler+0x2>
    914e:	8ed8 13f5 	cmp	AL, 0x13f5 <_ld_ErrorDetectedMultipleHandler+0x3>
    9152:	1a0c      	jule	0x916c <.L3>

00009154 <.LM9>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[*idx] = l_ErrorDetected;
    9154:	442e      	asl	X
    9156:	72d8 13f2 	lod	A, 0x13f2 <_ld_ErrorDetectedMultipleHandler>
    915a:	22e2      	add	X, A
    915c:	72da 4ab1 	lod	A, #19121
    9160:	52f8      	mov	[X], A

00009162 <.LM10>:
        *idx = *idx + 1;
    9162:	62d8 13f5 	lod	AL, 0x13f5 <_ld_ErrorDetectedMultipleHandler+0x3>
    9166:	8001      	add	AL, #1
    9168:	42d8 13f5 	mov	0x13f5 <_ld_ErrorDetectedMultipleHandler+0x3>, AL

0000916c <.L3>:
    }

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /* Diagnostic frames: node configuration / identification */
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_DiagRequest);
    916c:	7ee6      	lod	X, Y
    916e:	201a      	add	X, #26
    9170:	54ca 4901 	pushw	#18689

00009174 <.LCFI4>:
    9174:	72f8      	lod	A, [X]
    9176:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

0000917a <.LM12>:
    plinEventTable->ldt_GetLINNAD = ld_GetLINNAD;
    917a:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    917e:	2014      	add	X, #20
    9180:	72da 48d8 	lod	A, #18648
    9184:	52f8      	mov	[X], A
    9186:	5c01      	dec	S, #2

00009188 <.L1>:
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
        /* Initialize MLX LIN API event table */
        l_mls_InitEventTable();
    }
}
    9188:	5401      	ret

0000918a <_l_sys_irq_disable>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    918a:	72e3      	lod	A, M

0000918c <.LBE12>:
l_irqmask l_sys_irq_disable(void)
{
    l_u16 mreg_saved = builtin_mlx16_get_status();

    /* Keep User-bit unchanged */
    builtin_mlx16_set_status((mreg_saved & ~((l_u16)7u << 8)) |
    918c:	7ee2      	lod	X, A
    918e:	36da f8ff 	and	X, #63743
    9192:	26da 0400 	or	X, #1024

00009196 <.LBB14>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9196:	5ee3      	mov	M, X

00009198 <.LBE14>:
                             (((l_u16)LINAPI_RESOURCES_BLOCKING_PRIORITY & 7u) << 8));
    return mreg_saved;
}
    9198:	5401      	ret

0000919a <_l_sys_irq_restore>:
    919a:	52e3      	mov	M, A

0000919c <.LBE16>:
 * @return void
 */
void l_sys_irq_restore(l_irqmask previous)
{
    builtin_mlx16_set_status(previous);
}
    919c:	5401      	ret

0000919e <_ld_DiagInit>:
/** (Re)initialize the configuration/identification layer
 * @return  void
 */
void ld_DiagInit (void)
{
    pendingSlaveResponse = respNoResponse;
    919e:	7000      	lod	A, #0
    91a0:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

000091a4 <.LM40>:
    ml_ConfiguredNAD = ml_InitialNAD;
    91a4:	62d8 5daa 	lod	AL, 0x5daa <_ml_InitialNAD>
    91a8:	0ea7      	lod	C, ML.7
    91aa:	42d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, AL

000091ae <.LM41>:
}
    91ae:	5401      	ret

000091b0 <_ld_GetLINNAD>:
 * @return Current NAD.
 */
l_u8 ld_GetLINNAD (l_u8 NAD)
{
    (void)NAD; /* There is no interest to track other than current NADs on the bus */
    l_u8 retVal = ml_ConfiguredNAD;
    91b0:	66d8 10a4 	lod	YL, 0x10a4 <_ml_ConfiguredNAD>
    91b4:	5cf6      	usex	Y

000091b6 <.LM47>:
#if SL_EN_ASSIGN_NAD_SERVICE
    /* Assign NAD request */
    if (ML_SLAVE_FRAME_DATA_BUFFER[2] == 0xB0u) {
    91b6:	62d8 1006 	lod	AL, 0x1006 <_ml_Data+0x2>

000091ba <.LVL41>:
    91ba:	8cb0      	cmp	AL, #-80
    91bc:	1d03      	jne	0x91c4 <.L26>

000091be <.LM48>:
        retVal = ml_InitialNAD;
    91be:	66d8 5daa 	lod	YL, 0x5daa <_ml_InitialNAD>
    91c2:	5cf6      	usex	Y

000091c4 <.L26>:
    }
#endif /* SL_EN_ASSIGN_NAD_SERVICE */
    return retVal;
}
    91c4:	72e6      	lod	A, Y
    91c6:	5401      	ret

000091c8 <_isSupplierIdValid>:
    l_u16 supplierID;
    l_u16 cur_supplierID;
    ml_Status_t status;

    /* supplierID word could be on odd address, so get LSB, MSB separately */
    supplierID = ((l_u16)data[1] << 8 ) | data[0];
    91c8:	7ee2      	lod	X, A
    91ca:	62f8      	lod	AL, [X]
    91cc:	6af9      	lod	AH, [X+1]

000091ce <.LM52>:
    cur_supplierID = (l_u16)ml_ProductID[0]
    91ce:	66d8 5da4 	lod	YL, 0x5da4 <_ml_ProductID>
    91d2:	6ed8 5da5 	lod	YH, 0x5da5 <_ml_ProductID+0x1>

000091d6 <.LM53>:
                     | (((l_u16)ml_ProductID[1]) << 8);

    if (   (supplierID == cur_supplierID)
    91d6:	aee6      	cmp	A, Y
    91d8:	1904      	je	0x91e2 <.L29>

000091da <.LM54>:
           || (supplierID == 0x7FFFU /* wildcard */)) {
        status = ML_SUCCESS;
    91da:	aeda 7fff 	cmp	A, #32767
    91de:	5ca2      	sne	A
    91e0:	5401      	ret

000091e2 <.L29>:
    91e2:	7000      	lod	A, #0

000091e4 <.LM55>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    91e4:	5401      	ret

000091e6 <_isFunctionIdValid>:
    l_u16 functionID;
    l_u16 cur_functionID;
    ml_Status_t status;

    /* functionID word could be on odd address, so get LSB, MSB separately */
    functionID = ((l_u16)data[1] << 8) | data[0];
    91e6:	7ee2      	lod	X, A
    91e8:	62f8      	lod	AL, [X]
    91ea:	6af9      	lod	AH, [X+1]

000091ec <.LM58>:
    cur_functionID = ((l_u16)ml_ProductID[2])
    91ec:	66d8 5da6 	lod	YL, 0x5da6 <_ml_ProductID+0x2>
    91f0:	6ed8 5da7 	lod	YH, 0x5da7 <_ml_ProductID+0x3>

000091f4 <.LM59>:
                     | (((l_u16)ml_ProductID[3]) << 8);

    if (   (functionID == cur_functionID)
    91f4:	aee6      	cmp	A, Y
    91f6:	1903      	je	0x91fe <.L32>

000091f8 <.LM60>:
           || (functionID == 0xFFFFU /* wildcard */)) {
        status = ML_SUCCESS;
    91f8:	acff      	cmp	A, #-1
    91fa:	5ca2      	sne	A
    91fc:	5401      	ret

000091fe <.L32>:
    91fe:	7000      	lod	A, #0

00009200 <.LM61>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    9200:	5401      	ret

00009202 <_ld_DiagRequest>:
 * @return Status:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
bool ld_DiagRequest(LINDiagTransfer_t *transfer)
{
    9202:	5809      	inc	S, #10

00009204 <.LCFI4>:
    9204:	7ae2      	lod	Y, A

00009206 <.LM63>:
    pDiagTransfer = transfer;
    9206:	52d8 118e 	mov	0x118e <_pDiagTransfer>, A

0000920a <.LM64>:

    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;
    920a:	7000      	lod	A, #0

0000920c <.LVL50>:
    920c:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00009210 <.LM65>:

    switch (pDiagTransfer->request.reqSId) {
    9210:	62f0      	lod	AL, [Y]
    9212:	4205      	mov	[S-6], AL
    9214:	6205      	lod	AL, [S-6]
    9216:	8cb2      	cmp	AL, #-78
    9218:	1d01      	jne	0x921c <.LASF1124+0x7>
    921a:	0061      	jmp	0x92de <.L35>
    921c:	5cf2      	usex	A
    921e:	aeda 00b2 	cmp	A, #178
    9222:	1e11      	jug	0x9246 <.L36>
    9224:	aeda 00b0 	cmp	A, #176
    9228:	1d01      	jne	0x922c <.L34>
    922a:	0040      	jmp	0x92ac <.L37>

0000922c <.L34>:
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    SlaveResponse_t thisPendingSlaveResponse = pendingSlaveResponse;
    922c:	7ed8 1190 	lod	X, 0x1190 <_pendingSlaveResponse>

00009230 <.LM67>:

    /* reset pending response after processing */
    /* speculative next state/response, overwrite if otherwise */
    pendingSlaveResponse = respNoResponse;
    9230:	7000      	lod	A, #0
    9232:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00009236 <.LM68>:

    switch (thisPendingSlaveResponse) {
    9236:	20ff      	add	X, #-1

00009238 <.LVL53>:
    9238:	2c06      	cmp	X, #6
    923a:	1a01      	jule	0x923e <.LVL53+0x6>
    923c:	00d2      	jmp	0x93e2 <.L61>
    923e:	442e      	asl	X
    9240:	22da 5d5e 	add	X, #23902
    9244:	76f8      	jmp	[X]

00009246 <.L36>:
    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;

    switch (pDiagTransfer->request.reqSId) {
    9246:	aeda 00b6 	cmp	A, #182
    924a:	1d01      	jne	0x924e <.LASF1396+0x6>
    924c:	0086      	jmp	0x935a <.L38>
    924e:	aeda 00b7 	cmp	A, #183
    9252:	1d6c      	jne	0x922c <.L34>

00009254 <.LBB43>:
 * @return: Requested response or respNoResponse.
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
    9254:	72f2      	lod	A, [Y+2]
    9256:	ac05      	cmp	A, #5
    9258:	1d27      	jne	0x92a8 <.L45>

0000925a <.LM71>:
        return respNoResponse;
    }

    /* invalid start index */
    if (pDiagTransfer->request.data[0] >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    925a:	62f4      	lod	AL, [Y+4]
    925c:	4207      	mov	[S-8], AL
    925e:	8c02      	cmp	AL, #2
    9260:	1e23      	jug	0x92a8 <.L45>

00009262 <.LBB45>:
    } else {
        l_u8 *pid;
        l_u8 index;
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
    9262:	8003      	add	AL, #3
    9264:	5cf2      	usex	A
    9266:	5205      	mov	[S-6], A

00009268 <.LM73>:
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */
    9268:	e008      	add	Y, #8

0000926a <.LVL57>:
    926a:	6207      	lod	AL, [S-8]

0000926c <.LVL58>:
    926c:	80ff      	add	AL, #-1
    926e:	5cf2      	usex	A
    9270:	5207      	mov	[S-8], A

00009272 <.L52>:

        for (i = 0U; i < 4U; i++) {
            if (*pid != 0xFFU) {                                /* if id is NOT 0xFF .. */
    9272:	62f0      	lod	AL, [Y]
    9274:	8cff      	cmp	AL, #-1
    9276:	1d01      	jne	0x927a <.LM75>
    9278:	0082      	jmp	0x937e <.L46>

0000927a <.LM75>:
                if (index >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {   /* if wrong index for valid pid .. */
    927a:	7205      	lod	A, [S-6]
    927c:	ac02      	cmp	A, #2
    927e:	1e14      	jug	0x92a8 <.L45>

00009280 <.LM76>:
                    return respNoResponse;
                } else {                                          /* proper index */
                    (void)ml_Disconnect();
    9280:	5a03      	mov	[S-4], Y
    9282:	82db 11f0 	callf	0x23e0 <_ml_Disconnect>

00009286 <.LM77>:
                    if (*pid == 0x00U) {                        /* unassign */
    9286:	7a03      	lod	Y, [S-4]
    9288:	62f0      	lod	AL, [Y]
    928a:	4201      	mov	[S-2], AL
    928c:	5cf2      	usex	A
    928e:	7ee2      	lod	X, A
    9290:	6201      	lod	AL, [S-2]
    9292:	1901      	je	0x9296 <.LM78>
    9294:	007e      	jmp	0x9392 <.L47>

00009296 <.LM78>:
                        if (ml_DisableMessage(index) != ML_SUCCESS) {
    9296:	7205      	lod	A, [S-6]
    9298:	82db 1175 	callf	0x22ea <_ml_DisableMessage>
    929c:	7a03      	lod	Y, [S-4]
    929e:	ac00      	cmp	A, #0
    92a0:	1d01      	jne	0x92a4 <.L51>
    92a2:	0065      	jmp	0x936e <.L48>

000092a4 <.L51>:
                            (void)ml_Connect();
    92a4:	82db 11ee 	callf	0x23dc <_ml_Connect>

000092a8 <.L45>:
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
        return respNoResponse;
    92a8:	7000      	lod	A, #0
    92aa:	0016      	jmp	0x92d8 <.L49>

000092ac <.L37>:
 *
 * @return: Requested response or respNoResponse
 */
static SlaveResponse_t assignNAD (void)
{
    if (pDiagTransfer->request.dataLen != 0x05u) {
    92ac:	72f2      	lod	A, [Y+2]
    92ae:	ac05      	cmp	A, #5
    92b0:	1d7b      	jne	0x92a8 <.L45>

000092b2 <.LM82>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    92b2:	72e6      	lod	A, Y
    92b4:	a004      	add	A, #4
    92b6:	5a03      	mov	[S-4], Y
    92b8:	1787      	call	0x91c8 <_isSupplierIdValid>

000092ba <.LVL65>:
    92ba:	5205      	mov	[S-6], A
    92bc:	7a03      	lod	Y, [S-4]
    92be:	ac00      	cmp	A, #0
    92c0:	1d73      	jne	0x92a8 <.L45>

000092c2 <.LM83>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
    92c2:	72e6      	lod	A, Y
    92c4:	a006      	add	A, #6
    92c6:	178f      	call	0x91e6 <_isFunctionIdValid>

000092c8 <.LM84>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    92c8:	7a03      	lod	Y, [S-4]
    92ca:	ac00      	cmp	A, #0
    92cc:	1d6d      	jne	0x92a8 <.L45>

000092ce <.LM85>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
        ml_ConfiguredNAD = pDiagTransfer->request.data[4];   /* new NAD */
    92ce:	e008      	add	Y, #8
    92d0:	62f0      	lod	AL, [Y]
    92d2:	42d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, AL

000092d6 <.LM86>:
        return respPositiveAssignNAD;
    92d6:	7004      	lod	A, #4

000092d8 <.L49>:
            break; /* !case 0xB6 */
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case 0xB7: /* Assign Frame ID range */
            pendingSlaveResponse = assignFrameIdRange();
    92d8:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

000092dc <.LM88>:
            break; /* !case 0xB7 */
    92dc:	07a7      	jmp	0x922c <.L34>

000092de <.L35>:
 */
static SlaveResponse_t readByIdentifier (void)
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
    92de:	72f2      	lod	A, [Y+2]
    92e0:	ac05      	cmp	A, #5
    92e2:	1901      	je	0x92e6 <.LM90>
    92e4:	0034      	jmp	0x934e <.L66>

000092e6 <.LM90>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    92e6:	72e6      	lod	A, Y
    92e8:	a005      	add	A, #5
    92ea:	5a03      	mov	[S-4], Y
    92ec:	176d      	call	0x91c8 <_isSupplierIdValid>

000092ee <.LVL68>:
    92ee:	5205      	mov	[S-6], A
    92f0:	7a03      	lod	Y, [S-4]
    92f2:	ac00      	cmp	A, #0
    92f4:	1d2c      	jne	0x934e <.L66>

000092f6 <.LM91>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {
    92f6:	72e6      	lod	A, Y
    92f8:	a007      	add	A, #7
    92fa:	1775      	call	0x91e6 <_isFunctionIdValid>

000092fc <.LM92>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    92fc:	7a03      	lod	Y, [S-4]
    92fe:	ac00      	cmp	A, #0
    9300:	1d26      	jne	0x934e <.L66>

00009302 <.LM93>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
    9302:	62f4      	lod	AL, [Y+4]
    9304:	4205      	mov	[S-6], AL
    9306:	6205      	lod	AL, [S-6]
    9308:	1924      	je	0x9352 <.L68>
    930a:	5cf2      	usex	A
    930c:	7ee2      	lod	X, A
    930e:	ac01      	cmp	A, #1
    9310:	1d04      	jne	0x931a <.L76>

00009312 <.LM94>:
                    retVal = respLinProductID;
                    break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
                case 0x01:                      /* ID: Serial number (optional) */
                    retVal = respSerialNumber;
    9312:	7803      	lod	Y, #3

00009314 <.L41>:
            break;
#endif /* SL_vLIN_2_0 || (SL_vSAE_J2602_2012 && SL_EN_ASSIGN_FRAME_ID_SERVICE) */

#if SL_vLIN_2_x || SL_vISO17987_2016 || (SL_vSAE_J2602_2012 && SL_EN_READ_BY_ID_SERVICE)
        case 0xB2: /* Read by Identifier request */
            pendingSlaveResponse = readByIdentifier();
    9314:	5ad8 1190 	mov	0x1190 <_pendingSlaveResponse>, Y

00009318 <.LM96>:
            break;
    9318:	0789      	jmp	0x922c <.L34>

0000931a <.L76>:
                    break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
    931a:	6205      	lod	AL, [S-6]
    931c:	80e0      	add	AL, #-32
    931e:	8c1f      	cmp	AL, #31
    9320:	1e1a      	jug	0x9356 <.L69>

00009322 <.LBB52>:
                        l_u8 pci = 6; /* Default value */
    9322:	6006      	lod	AL, #6
    9324:	4209      	mov	[S-10], AL

00009326 <.LM99>:
                        l_u8 response = ld_read_by_id_callout (dummy,
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
    9326:	e004      	add	Y, #4

00009328 <.LM100>:

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
                        l_u8 pci = 6; /* Default value */
                        l_u8 response = ld_read_by_id_callout (dummy,
    9328:	5adf      	push	Y

0000932a <.LCFI5>:
    932a:	72ef      	lod	A, S
    932c:	a0f4      	add	A, #-12
    932e:	52df      	push	A

00009330 <.LCFI6>:
    9330:	5edf      	push	X

00009332 <.LCFI7>:
    9332:	72d8 13f6 	lod	A, 0x13f6 <_dummy>
    9336:	168b      	call	0x904e <_ld_read_by_id_callout>
    9338:	7ae2      	lod	Y, A

0000933a <.LM101>:
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
                        pDiagTransfer->response.dataLen = (l_u16)pci - 1u; /* Convert PCI to data length */
    933a:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    933e:	620f      	lod	AL, [S-16]

00009340 <.LVL72>:
    9340:	5cf2      	usex	A
    9342:	a0ff      	add	A, #-1
    9344:	52fa      	mov	[X+2], A

00009346 <.LM102>:
                        pDiagTransfer->response.respSId = RSID(SID_ReadById);
    9346:	60f2      	lod	AL, #-14
    9348:	42f8      	mov	[X], AL

0000934a <.LVL73>:
    934a:	5c05      	dec	S, #6

0000934c <.LCFI8>:
    934c:	07e3      	jmp	0x9314 <.L41>

0000934e <.L66>:
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
        /* if (PCI-1) is not valid .. */
        retVal = respNoResponse;
    934e:	7800      	lod	Y, #0
    9350:	07e1      	jmp	0x9314 <.L41>

00009352 <.L68>:

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
                case 0x00:                      /* ID: LIN Product Identification */
                    retVal = respLinProductID;
    9352:	7801      	lod	Y, #1
    9354:	07df      	jmp	0x9314 <.L41>

00009356 <.L69>:
                        retVal = (SlaveResponse_t)response;
                        break;
                    }
                    /* else : wrong ID */
#endif /* SL_EN_READ_BY_ID_CALLOUT */
                    retVal = respNegativeResponse;
    9356:	7802      	lod	Y, #2
    9358:	07dd      	jmp	0x9314 <.L41>

0000935a <.L38>:
/** Process Save Configuration frame.
 * @return  void
 */
static SlaveResponse_t saveConfiguration (void)
{
    if (pDiagTransfer->request.dataLen != 0u) {
    935a:	72f2      	lod	A, [Y+2]
    935c:	1901      	je	0x9360 <.LM107>
    935e:	07a4      	jmp	0x92a8 <.L45>

00009360 <.LM107>:
        /* if (PCI-1) is not correct .. */
        return respNoResponse;
    }
    /* else: (PCI-1) is correct, continue processing .. */

    s_ifcStatus.mapped.SaveConfig = true;
    9360:	7eda 13f8 	lod	X, #5112
    9364:	62f8      	lod	AL, [X]
    9366:	8440      	or	AL, #64
    9368:	42f8      	mov	[X], AL

0000936a <.LM108>:

    return respPositiveSaveConfig;
    936a:	7006      	lod	A, #6
    936c:	07b5      	jmp	0x92d8 <.L49>

0000936e <.L48>:
                        }
                        /* else save unassignment to node_configuration */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
    936e:	7e05      	lod	X, [S-6]
    9370:	22da 13fe 	add	X, #5118
    9374:	42f8      	mov	[X], AL

00009376 <.L50>:
                        }
                        /* else: don't store PID */
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
                    } /* assign */

                    (void)ml_Connect();
    9376:	5a03      	mov	[S-4], Y
    9378:	82db 11ee 	callf	0x23dc <_ml_Connect>
    937c:	7a03      	lod	Y, [S-4]

0000937e <.L46>:
                } /* proper index */
            } else {   /* id is 0xFF .. */
                       /* .. skip PID from processing */
            }

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
    937e:	e0ff      	add	Y, #-1

00009380 <.LM112>:
            --index;        /* get previous index */
    9380:	6205      	lod	AL, [S-6]
    9382:	80ff      	add	AL, #-1
    9384:	5cf2      	usex	A
    9386:	5205      	mov	[S-6], A

00009388 <.LM113>:
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */

        for (i = 0U; i < 4U; i++) {
    9388:	ae07      	cmp	A, [S-8]
    938a:	1901      	je	0x938e <.LM114>
    938c:	0772      	jmp	0x9272 <.L52>

0000938e <.LM114>:

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
            --index;        /* get previous index */
        } /* for 4 pids */

        return respPositiveAssignFidRange;
    938e:	7005      	lod	A, #5

00009390 <.LVL81>:
    9390:	07a3      	jmp	0x92d8 <.L49>

00009392 <.L47>:
#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
#endif /* ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && SL_EN_SAVE_CONFIG_FUNC) */
                    } else {                                      /* assign */
                        if (ml_AssignFrameToMessageID(index,*pid) != ML_SUCCESS) {
    9392:	5edf      	push	X

00009394 <.LCFI9>:
    9394:	7207      	lod	A, [S-8]
    9396:	5a05      	mov	[S-6], Y
    9398:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    939c:	5c01      	dec	S, #2

0000939e <.LCFI10>:
    939e:	7a03      	lod	Y, [S-4]
    93a0:	ac00      	cmp	A, #0
    93a2:	1901      	je	0x93a6 <.LM116>
    93a4:	077f      	jmp	0x92a4 <.L51>

000093a6 <.LM116>:
                        /* else: assignment was OK, continue processing */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        /* save assignment to node_configuration */
                        node_configuration[index] = *pid;
    93a6:	7e05      	lod	X, [S-6]
    93a8:	22da 13fe 	add	X, #5118
    93ac:	0ea7      	lod	C, ML.7
    93ae:	54c4      	movsb	[X++], [Y++]

000093b0 <.LVL86>:
    93b0:	e0ff      	add	Y, #-1
    93b2:	07e1      	jmp	0x9376 <.L50>

000093b4 <.L54>:
            retVal = false;
            break;

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE
        case respLinProductID:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    93b4:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    93b8:	60f2      	lod	AL, #-14
    93ba:	42f8      	mov	[X], AL

000093bc <.LM118>:
            pDiagTransfer->response.dataLen = 5u; /* Only data bytes length */
    93bc:	7005      	lod	A, #5
    93be:	52fa      	mov	[X+2], A

000093c0 <.LM119>:
            pDiagTransfer->response.data[0] = ml_ProductID[0];
    93c0:	62d8 5da4 	lod	AL, 0x5da4 <_ml_ProductID>
    93c4:	42fc      	mov	[X+4], AL

000093c6 <.LM120>:
            pDiagTransfer->response.data[1] = ml_ProductID[1];
    93c6:	62d8 5da5 	lod	AL, 0x5da5 <_ml_ProductID+0x1>
    93ca:	42fd      	mov	[X+5], AL

000093cc <.LM121>:
            pDiagTransfer->response.data[2] = ml_ProductID[2];
    93cc:	62d8 5da6 	lod	AL, 0x5da6 <_ml_ProductID+0x2>
    93d0:	42fe      	mov	[X+6], AL

000093d2 <.LM122>:
            pDiagTransfer->response.data[3] = ml_ProductID[3];
    93d2:	62d8 5da7 	lod	AL, 0x5da7 <_ml_ProductID+0x3>
    93d6:	42ff      	mov	[X+7], AL

000093d8 <.LM123>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
    93d8:	2008      	add	X, #8
    93da:	62d8 5da8 	lod	AL, 0x5da8 <_ml_ProductID+0x4>
    93de:	42f8      	mov	[X], AL

000093e0 <.L71>:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    93e0:	7001      	lod	A, #1

000093e2 <.L61>:
            break;
    }

    /* Prepare the response */
    return ld_DiagResponse();
}
    93e2:	540b      	ret	#12

000093e4 <.L57>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
            break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
        case respSerialNumber:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    93e4:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    93e8:	60f2      	lod	AL, #-14
    93ea:	42f8      	mov	[X], AL

000093ec <.LM127>:
            pDiagTransfer->response.dataLen = 4u; /* Only data bytes length */
    93ec:	7004      	lod	A, #4
    93ee:	52fa      	mov	[X+2], A

000093f0 <.LM128>:
            ld_serial_number_callout(&pDiagTransfer->response.data[0]); /* Insert Serial Number into data bytes 3..6 */
    93f0:	72ee      	lod	A, X
    93f2:	a004      	add	A, #4
    93f4:	15eb      	call	0x8fcc <_ld_serial_number_callout>
    93f6:	07f4      	jmp	0x93e0 <.L71>

000093f8 <.L56>:
            pDiagTransfer->response.data[4] = 0x00u; /* reserved */
            break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

        case respNegativeResponse:
            pDiagTransfer->response.respSId = RSID_NegativeResponse;
    93f8:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    93fc:	607f      	lod	AL, #127
    93fe:	42f8      	mov	[X], AL

00009400 <.LM130>:
            pDiagTransfer->response.dataLen = 2u; /* Only data bytes length */
    9400:	7002      	lod	A, #2
    9402:	52fa      	mov	[X+2], A
    9404:	72da 12b2 	lod	A, #4786
    9408:	52fc      	mov	[X+4], A
    940a:	07ea      	jmp	0x93e0 <.L71>

0000940c <.L58>:
            break;
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE */

#if SL_EN_ASSIGN_NAD_SERVICE
        case respPositiveAssignNAD:
            pDiagTransfer->response.respSId = RSID(SID_AssignNad);
    940c:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    9410:	72da 00f0 	lod	A, #240

00009414 <.L77>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    9414:	42f8      	mov	[X], AL

00009416 <.LM133>:
            pDiagTransfer->response.dataLen = 0u; /* Only data bytes length */
    9416:	7000      	lod	A, #0
    9418:	52fa      	mov	[X+2], A
    941a:	07e2      	jmp	0x93e0 <.L71>

0000941c <.L59>:
            break;
#endif /* SL_vSAE_J2602_2012 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case respPositiveAssignFidRange:
            pDiagTransfer->response.respSId = RSID(SID_AssignFrameIdRange);
    941c:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    9420:	72da 00f7 	lod	A, #247
    9424:	07f7      	jmp	0x9414 <.L77>

00009426 <.L60>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    9426:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    942a:	72da 00f6 	lod	A, #246
    942e:	07f2      	jmp	0x9414 <.L77>

00009430 <_l_sys_init>:
 * - 1 - fail.
 */
l_bool l_sys_init(void)
{
    return (l_bool)0u;
}
    9430:	7000      	lod	A, #0
    9432:	5401      	ret

00009434 <_l_SetFlagsMask>:
 * @param[out]  dest    destination pointer
 * @param[in]   mask    used flags mask
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    9434:	5805      	inc	S, #6

00009436 <.LCFI0>:
    9436:	5201      	mov	[S-2], A
    9438:	620b      	lod	AL, [S-12]

0000943a <.LVL1>:
    943a:	5cf2      	usex	A
    943c:	5203      	mov	[S-4], A

0000943e <.LBB6>:
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    943e:	16a5      	call	0x918a <_l_sys_irq_disable>
    9440:	5205      	mov	[S-6], A

00009442 <.LBB7>:
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    9442:	7203      	lod	A, [S-4]

00009444 <.LVL4>:
    9444:	190a      	je	0x945a <.L3>
    9446:	7e09      	lod	X, [S-10]
    9448:	7a01      	lod	Y, [S-2]

0000944a <.L4>:
        dest[cnt] |= mask[cnt];
    944a:	62f0      	lod	AL, [Y]
    944c:	86de      	or	AL, [X++]
    944e:	42d6      	mov	[Y++], AL

00009450 <.LM7>:
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    9450:	62e8      	lod	AL, YL
    9452:	8a01      	sub	AL, [S-2]
    9454:	5cf2      	usex	A
    9456:	ae03      	cmp	A, [S-4]
    9458:	1878      	jc	0x944a <.L4>

0000945a <.L3>:
 *
 */

STATIC INLINE void l_sys_irq_restore_pointer (const l_irqmask *p)
{
    l_sys_irq_restore(*p);
    945a:	7205      	lod	A, [S-6]
    945c:	169e      	call	0x919a <_l_sys_irq_restore>

0000945e <.LBE6>:
        dest[cnt] |= mask[cnt];
    }
    EXIT_STD_LIN_API_ATOMIC_SECTION();
}
    945e:	5407      	ret	#8

00009460 <_l_ifcUpdateOverrun>:
    9460:	7eda 13f8 	lod	X, #5112
    9464:	66f8      	lod	YL, [X]
    9466:	62e8      	lod	AL, YL
    9468:	9404      	and	AL, #4
    946a:	1d0a      	jne	0x9480 <.L1>

0000946c <.LM3>:
    946c:	62d8 1192 	lod	AL, 0x1192 <_s_ifcOverrunFramesCount>
    9470:	8001      	add	AL, #1
    9472:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

00009476 <.LM4>:
    9476:	8c01      	cmp	AL, #1
    9478:	1a03      	jule	0x9480 <.L1>

0000947a <.LM5>:
    947a:	62e8      	lod	AL, YL
    947c:	8404      	or	AL, #4
    947e:	42f8      	mov	[X], AL

00009480 <.L1>:
    9480:	5401      	ret

00009482 <_l_ifc_init_sl1>:
    9482:	163b      	call	0x90fa <_l_mls_Init>

00009484 <.LM9>:
    9484:	6000      	lod	AL, #0
    9486:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

0000948a <.LM10>:
    948a:	1689      	call	0x919e <_ld_DiagInit>

0000948c <.LM11>:
    948c:	82db 11ee 	callf	0x23dc <_ml_Connect>
    9490:	ac00      	cmp	A, #0
    9492:	5ca2      	sne	A

00009494 <.LM12>:
    9494:	5401      	ret

00009496 <_l_ifc_read_status_sl1>:
    9496:	5803      	inc	S, #4

00009498 <.LBB17>:
    9498:	1678      	call	0x918a <_l_sys_irq_disable>
    949a:	5203      	mov	[S-4], A

0000949c <.LM15>:
    949c:	7008      	lod	A, #8

0000949e <.LVL5>:
    949e:	82db 11d3 	callf	0x23a6 <_ml_GetState>

000094a2 <.LM16>:
    94a2:	62d8 1010 	lod	AL, 0x1010 <.LLST8+0x2>
    94a6:	9401      	and	AL, #1
    94a8:	1905      	je	0x94b4 <.L7>

000094aa <.LM17>:
    94aa:	7eda 13f8 	lod	X, #5112
    94ae:	62f8      	lod	AL, [X]
    94b0:	8410      	or	AL, #16
    94b2:	42f8      	mov	[X], AL

000094b4 <.L7>:
    94b4:	7ad8 13f8 	lod	Y, 0x13f8 <_s_ifcStatus>

000094b8 <.LM19>:
    94b8:	6000      	lod	AL, #0
    94ba:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

000094be <.LM20>:
    94be:	0ea7      	lod	C, ML.7
    94c0:	7000      	lod	A, #0
    94c2:	52d8 13f8 	mov	0x13f8 <_s_ifcStatus>, A

000094c6 <.LBB18>:
    94c6:	7203      	lod	A, [S-4]
    94c8:	5a01      	mov	[S-2], Y
    94ca:	1667      	call	0x919a <_l_sys_irq_restore>

000094cc <.LBE17>:
    94cc:	7a01      	lod	Y, [S-2]
    94ce:	72e6      	lod	A, Y
    94d0:	5405      	ret	#6

000094d2 <_l_LinSleepMode>:
/** LIN Slave driver entered a sleep mode.
 * @param[in]   Reason    Reason of entering sleep mode.
 * @return void
 */
void l_LinSleepMode(ml_SleepReason_t Reason)
{
    94d2:	7ee2      	lod	X, A

000094d4 <.LM29>:

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    if (Reason == ml_reasonMaster) {
    94d4:	ac01      	cmp	A, #1
    94d6:	1d08      	jne	0x94e8 <.L14>

000094d8 <.LM30>:
        s_ifcStatus.mapped.GoToSleep = true;
    94d8:	7ada 13f8 	lod	Y, #5112

000094dc <.LM31>:
        /*
         * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
         * and does not report it via l_MessageReceived event.
         * Hence write Protected ID 0x3C explicitly.
         */
        s_ifcStatus.mapped.PID = 0x3C;
    94dc:	603c      	lod	AL, #60

000094de <.LVL14>:
    94de:	42d8 13f9 	mov	0x13f9 <.LLST9>, AL

000094e2 <.LM32>:
        s_ifcStatus.mapped.SuccessfulTrans = true;
    94e2:	62f0      	lod	AL, [Y]
    94e4:	840a      	or	AL, #10
    94e6:	42f0      	mov	[Y], AL

000094e8 <.L14>:
    }
    /* else: other reasons of sleep don't required special care */
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */

    l_ifc_sleep_entered_callout(Reason);    /* notify application on the sleep reason */
    94e8:	72ee      	lod	A, X
    94ea:	05fb      	jmp	0x90e2 <_l_ifc_sleep_entered_callout>

000094ec <_l_MessageReceived>:
 * @note The Signals write and Flags update are done atomically.
 * Thus the Signals / Flags API functions are allowed to be used in other interrupts
 * with higher priority then LIN ISR.
 */
void l_MessageReceived(ml_MessageID_t MessageIndex)
{
    94ec:	5801      	inc	S, #2

000094ee <.LCFI1>:
    94ee:	7ae2      	lod	Y, A

000094f0 <.LM36>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    94f0:	7eda 13f8 	lod	X, #5112
    94f4:	62f8      	lod	AL, [X]

000094f6 <.LVL17>:
    94f6:	8402      	or	AL, #2
    94f8:	42f8      	mov	[X], AL

000094fa <.LM37>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    94fa:	5a01      	mov	[S-2], Y
    94fc:	82db 5282 	callf	0xa504 <_ml_GetProtectedID>
    9500:	42d8 13f9 	mov	0x13f9 <.LLST9>, AL

00009504 <.LM38>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */


        if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    9504:	7a01      	lod	Y, [S-2]
    9506:	ec02      	cmp	Y, #2
    9508:	1e0f      	jug	0x9528 <.L15>

0000950a <.LBB20>:

        }
#else /*SUPPORT_MULTI_SLAVE*/

		/* Get Frame Handler */
		const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
    950a:	44a6      	asl	Y, #2
    950c:	e2da 5d94 	add	Y, #23956

00009510 <.LM40>:
		l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    9510:	7ef0      	lod	X, [Y]
    9512:	7af8      	lod	Y, [X]

00009514 <.LM41>:

		/* Actions on the frame */
		(void)ProcessFrame(sfa_UpdateSignals); /* Use new signals values */
    9514:	7000      	lod	A, #0
    9516:	5a01      	mov	[S-2], Y
    9518:	0001      	jmp	0x951c <.L18>

0000951a <.L17>:
    951a:	76e6      	jmp	Y

0000951c <.L18>:
    951c:	17fe      	call	0x951a <.L17>

0000951e <.LM42>:
		(void)ProcessFrame(sfa_SetFlags);   /* Mark corresponding signal's flags as received */
    951e:	7003      	lod	A, #3
    9520:	7a01      	lod	Y, [S-2]
    9522:	0001      	jmp	0x9526 <.L20>

00009524 <.L19>:
    9524:	76e6      	jmp	Y

00009526 <.L20>:
    9526:	17fe      	call	0x9524 <.L19>

00009528 <.L15>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */
#endif /*SUPPORT_MULTI_SLAVE*/
    } else {
        /* Unexpected frame -> ignore */
    }
}
    9528:	5403      	ret	#4

0000952a <_l_DataRequest>:
/** Header of the relevant non-diagnostic slave-to-master frame has been received.
 * @param[in]    MessageIndex    Message index of the current Frame
 * @return  void
 */
void l_DataRequest (ml_MessageID_t MessageIndex)
{
    952a:	5801      	inc	S, #2

0000952c <.LCFI2>:
    if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    952c:	ac02      	cmp	A, #2
    952e:	1e16      	jug	0x955c <.L22>

00009530 <.LBB21>:
        /* Non-diagnostic message */
        /* Get the frame by message index */
        const l_s_Frame_t *currentFrame = (const l_s_Frame_t*)&frameList[MessageIndex];

        /* Unconditional frame */
        if (currentFrame->FrameType == sft_UnconditionalFrame) {
    9530:	44a2      	asl	A, #2

00009532 <.LVL27>:
    9532:	7ee2      	lod	X, A
    9534:	22da 5d92 	add	X, #23954
    9538:	72f8      	lod	A, [X]
    953a:	1d10      	jne	0x955c <.L22>

0000953c <.LBB22>:
            /* Get Frame Handler */
            const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
            const l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    953c:	7efa      	lod	X, [X+2]
    953e:	7af8      	lod	Y, [X]

00009540 <.LM48>:


#else	/*SUPPORT_MULTI_SLAVE*/

        /* Actions on the frame */
        (void)ProcessFrame(sfa_FillBuffer);          /* Fill the data buffer */
    9540:	7001      	lod	A, #1
    9542:	5a01      	mov	[S-2], Y
    9544:	0001      	jmp	0x9548 <.L25>

00009546 <.L24>:
    9546:	76e6      	jmp	Y

00009548 <.L25>:
    9548:	17fe      	call	0x9546 <.L24>

0000954a <.LM49>:
        (void)ProcessFrame(sfa_SetFlags);            /* Consider Signals as sent */
    954a:	7003      	lod	A, #3
    954c:	7a01      	lod	Y, [S-2]
    954e:	0001      	jmp	0x9552 <.L27>

00009550 <.L26>:
    9550:	76e6      	jmp	Y

00009552 <.L27>:
    9552:	17fe      	call	0x9550 <.L26>

00009554 <.LM50>:

#if SL_vSAE_J2602_2012
        l_u8 api_info = mlu_SAE_SetStatusApiInfo(MessageIndex); /* call User Application */
        (void)ml_SAE_DataReady(api_info);            /* Notify driver */
#else
        (void)ml_DataReady(ML_END_OF_TX_ENABLED);    /* Notify driver */
    9554:	7001      	lod	A, #1
    9556:	82db 1167 	callf	0x22ce <_ml_DataReady>

0000955a <.LBE22>:
    955a:	5403      	ret	#4

0000955c <.L22>:
            }
        }
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
        /* Unexpected frame type -> ignore */
        else {
            (void)ml_DiscardFrame();
    955c:	82db 119a 	callf	0x2334 <_ml_DiscardFrame>

00009560 <.LBE21>:
    }
    /* Unexpected message index -> ignore */
    else {
        (void)ml_DiscardFrame();
    }
}
    9560:	5403      	ret	#4

00009562 <_l_ErrorDetected>:
            /* There is no J2602 only specific action for other errors */
            break;
    }
#endif /* SL_vSAE_J2602_2012 */

    switch (Error) {
    9562:	a0fc      	add	A, #-4

00009564 <.LVL35>:
    9564:	ac0c      	cmp	A, #12
    9566:	1e1b      	jug	0x959e <.L28>
    9568:	4422      	asl	A
    956a:	7ee2      	lod	X, A
    956c:	22da 5d6c 	add	X, #23916
    9570:	76f8      	jmp	[X]

00009572 <.L32>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overvoltage, signal, Fwv_Overvoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overcurrent, signal, Fwv_Overcurrent)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overtemperature, signal, Fwv_Overtemperature)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Diag_Forced_Status, signal, Fwv_Diag_Forced_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
    9572:	160b      	call	0x918a <_l_sys_irq_disable>
    9574:	7ee2      	lod	X, A

00009576 <.LVL38>:
    9576:	62d8 13fc 	lod	AL, 0x13fc <_l_sl1_flags+0x2>

0000957a <.LVL39>:
    957a:	94df      	and	AL, #-33
    957c:	42d8 13fc 	mov	0x13fc <_l_sl1_flags+0x2>, AL
    9580:	72ee      	lod	A, X
    9582:	160b      	call	0x919a <_l_sys_irq_restore>

00009584 <.L33>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
L_SIGNAL(l_bool, Fwv_Overcurrent)
L_SIGNAL(l_bool, Fwv_Overtemperature)
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
    9584:	6001      	lod	AL, #1
    9586:	42d8 11a9 	mov	0x11a9 <_l_signals+0x15>, AL

0000958a <.LBE31>:
             */
            l_flg_clr_response_error();

            l_bool_wr_response_error(true);
#endif /* !SL_vSAE_J2602_2012 */
            s_ifcStatus.mapped.ErrorInResponse = true;
    958a:	7eda 13f8 	lod	X, #5112
    958e:	62f8      	lod	AL, [X]
    9590:	8401      	or	AL, #1
    9592:	42f8      	mov	[X], AL

00009594 <.LM58>:
            s_ifcStatus.mapped.PID = ml_GetProtectedID();
    9594:	82db 5282 	callf	0xa504 <_ml_GetProtectedID>
    9598:	42d8 13f9 	mov	0x13f9 <.LLST9>, AL

0000959c <.LM59>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
            l_ifcUpdateOverrun();
    959c:	1761      	call	0x9460 <_l_ifcUpdateOverrun>

0000959e <.L28>:
    }

#if !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES
    isNonUnconditional = snuft_False;
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
}
    959e:	5401      	ret

000095a0 <_l_DataTransmitted>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    95a0:	7eda 13f8 	lod	X, #5112
    95a4:	62f8      	lod	AL, [X]

000095a6 <.LVL45>:
    95a6:	8402      	or	AL, #2
    95a8:	42f8      	mov	[X], AL

000095aa <.LM63>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    95aa:	82db 5282 	callf	0xa504 <_ml_GetProtectedID>
    95ae:	42d8 13f9 	mov	0x13f9 <.LLST9>, AL

000095b2 <.LM64>:
    l_ifcUpdateOverrun();
    95b2:	1756      	call	0x9460 <_l_ifcUpdateOverrun>

000095b4 <.LBB39>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overvoltage, signal, Fwv_Overvoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overcurrent, signal, Fwv_Overcurrent)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overtemperature, signal, Fwv_Overtemperature)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Diag_Forced_Status, signal, Fwv_Diag_Forced_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
    95b4:	62d8 13fc 	lod	AL, 0x13fc <_l_sl1_flags+0x2>

000095b8 <.LBE39>:
    /*
     * The response_error flag is set when Response Error signal is copied to
     * frame buffer for transmission in the current frame. If an error occurred
     * during transmission, the flag is cleared in l_ErrorDetected handler.
     */
    if (l_flg_tst_response_error()) {
    95b8:	9420      	and	AL, #32
    95ba:	190c      	je	0x95d4 <.L34>

000095bc <.LBB41>:
    95bc:	15e6      	call	0x918a <_l_sys_irq_disable>
    95be:	7ee2      	lod	X, A

000095c0 <.LVL49>:
    95c0:	62d8 13fc 	lod	AL, 0x13fc <_l_sl1_flags+0x2>

000095c4 <.LVL50>:
    95c4:	94df      	and	AL, #-33
    95c6:	42d8 13fc 	mov	0x13fc <_l_sl1_flags+0x2>, AL
    95ca:	72ee      	lod	A, X
    95cc:	15e6      	call	0x919a <_l_sys_irq_restore>

000095ce <.LBB43>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
L_SIGNAL(l_bool, Fwv_Overcurrent)
L_SIGNAL(l_bool, Fwv_Overtemperature)
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
    95ce:	6000      	lod	AL, #0
    95d0:	42d8 11a9 	mov	0x11a9 <_l_signals+0x15>, AL

000095d4 <.L34>:
    }

    /* Notify user application about end of transmission */
    mlu_SAE_DataTransmitted();
#endif /* SL_vSAE_J2602_2012 */
}
    95d4:	5401      	ret

000095d6 <_l_AutoAddressingStep>:
 * @return  void
 */
__attribute__((weak)) void l_AutoAddressingStep(l_u8 StepNumber)
{
    (void)StepNumber;   /* unused parameter */
}
    95d6:	5401      	ret

000095d8 <_l_FillBufferSlave>:
/** Fill the data buffer from source
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    95d8:	5805      	inc	S, #6

000095da <.LCFI3>:
    95da:	5205      	mov	[S-6], A

000095dc <.LBB45>:
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    95dc:	6209      	lod	AL, [S-10]

000095de <.LVL56>:
    95de:	1911      	je	0x9602 <.L40>
    95e0:	5cf2      	usex	A
    95e2:	5203      	mov	[S-4], A
    95e4:	7000      	lod	A, #0

000095e6 <.L42>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    95e6:	7e05      	lod	X, [S-6]
    95e8:	22e2      	add	X, A
    95ea:	7ae2      	lod	Y, A
    95ec:	e2da 1004 	add	Y, #4100
    95f0:	0ea7      	lod	C, ML.7
    95f2:	54cc      	movsb	[Y++], [X++]

000095f4 <.LVL58>:
    95f4:	a001      	add	A, #1

000095f6 <.LM75>:
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    95f6:	66e0      	lod	YL, AL
    95f8:	5cf6      	usex	Y
    95fa:	5a01      	mov	[S-2], Y
    95fc:	7a03      	lod	Y, [S-4]
    95fe:	ee01      	cmp	Y, [S-2]
    9600:	1e72      	jug	0x95e6 <.L42>

00009602 <.L40>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    }
}
    9602:	5407      	ret	#8

00009604 <_l_sl1_Debug_Frame_handler>:
    l_u8 unused56  : 8;
} l_sl1_Debug_Frame_data_t;
ASSERT(sizeof(l_sl1_Debug_Frame_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_Debug_Frame_handler (l_s_FrameAction_t frameAction)
{
    9604:	5809      	inc	S, #10

00009606 <.LCFI0>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t Debug_Frame_flags_mask = {{0x0, 0x0, 0x0, 0x2f}};

    switch (frameAction) {
    9606:	ac01      	cmp	A, #1
    9608:	190c      	je	0x9622 <.L3>
    960a:	1802      	jc	0x9610 <.L4>
    960c:	ac03      	cmp	A, #3
    960e:	1d26      	jne	0x965c <.L9>

00009610 <.L4>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&Debug_Frame_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    9610:	54ca 0004 	pushw	#4

00009614 <.LCFI1>:
    9614:	54ca 5d8e 	pushw	#23950

00009618 <.LCFI2>:
    9618:	72da 13fa 	lod	A, #5114

0000961c <.LVL2>:
    961c:	170b      	call	0x9434 <_l_SetFlagsMask>

0000961e <.LM4>:
            break;
    961e:	5c03      	dec	S, #4

00009620 <.LCFI3>:
    9620:	001b      	jmp	0x9658 <.L10>

00009622 <.L3>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_d_valve_status = l_signals.d_valve_status;
    9622:	66d8 11ad 	lod	YL, 0x11ad <_l_signals+0x19>

00009626 <.LM6>:
            l_u8 sig_d_motor_status = l_signals.d_motor_status;
    9626:	62d8 11ae 	lod	AL, 0x11ae <_l_signals+0x1a>

0000962a <.LVL6>:
    962a:	4200      	mov	[S-1], AL

0000962c <.LM7>:
            l_u16 sig_d_debug_1 = l_signals.d_debug_1;
    962c:	7ed8 11b0 	lod	X, 0x11b0 <_l_signals+0x1c>

00009630 <.LM8>:
            l_u8 sig_d_debug_2 = l_signals.d_debug_2;
    9630:	62d8 11b2 	lod	AL, 0x11b2 <.LASF0>

00009634 <.LVL9>:
    9634:	4201      	mov	[S-2], AL

00009636 <.LM9>:

            l_sl1_Debug_Frame_data_t Debug_Frame_data = {
    9636:	4609      	mov	[S-10], YL
    9638:	6200      	lod	AL, [S-1]

0000963a <.LVL11>:
    963a:	4208      	mov	[S-9], AL
    963c:	5e07      	mov	[S-8], X
    963e:	6201      	lod	AL, [S-2]
    9640:	4205      	mov	[S-6], AL
    9642:	72da 00ff 	lod	A, #255
    9646:	4204      	mov	[S-5], AL
    9648:	4203      	mov	[S-4], AL
    964a:	4202      	mov	[S-3], AL

0000964c <.LM10>:
                sig_d_debug_2,
                0xff,
                0xff,
                0xff
            };
            l_FillBufferSlave((l_u8*)&Debug_Frame_data, (l_u8)sizeof(l_sl1_Debug_Frame_data_t));
    964c:	54ca 0008 	pushw	#8

00009650 <.LCFI4>:
    9650:	72ef      	lod	A, S
    9652:	a0f4      	add	A, #-12
    9654:	17c1      	call	0x95d8 <_l_FillBufferSlave>

00009656 <.LVL13>:
    9656:	5c01      	dec	S, #2

00009658 <.L10>:
} l_sl1_Debug_Frame_data_t;
ASSERT(sizeof(l_sl1_Debug_Frame_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_Debug_Frame_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    9658:	7000      	lod	A, #0

0000965a <.LM12>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&Debug_Frame_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    965a:	540b      	ret	#12

0000965c <.L9>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    965c:	7001      	lod	A, #1

0000965e <.LM14>:
            break;
    }
    return retVal;
}
    965e:	540b      	ret	#12

00009660 <_l_sl1_VPC_Fwv_Ctrl_handler>:
static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Ctrl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Ctrl_flags_mask = {{0x1f, 0x0, 0x0, 0x40}};

    switch (frameAction) {
    9660:	ac01      	cmp	A, #1
    9662:	1903      	je	0x966a <.L13>
    9664:	180b      	jc	0x967c <.L14>
    9666:	ac03      	cmp	A, #3
    9668:	1d28      	jne	0x96ba <.L22>

0000966a <.L13>:
            break;
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Ctrl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    966a:	54ca 0004 	pushw	#4

0000966e <.LCFI6>:
    966e:	54ca 5d8a 	pushw	#23946

00009672 <.LCFI7>:
    9672:	72da 13fa 	lod	A, #5114

00009676 <.LVL17>:
    9676:	16de      	call	0x9434 <_l_SetFlagsMask>

00009678 <.LM18>:
            break;
    9678:	5c03      	dec	S, #4

0000967a <.LCFI8>:
    967a:	001d      	jmp	0x96b6 <.L23>

0000967c <.L14>:

    switch (frameAction) {
        case sfa_UpdateSignals:    /* For M2S frames */
        {
            l_sl1_VPC_Fwv_Ctrl_data_t MLXCOMP_354_WA *VPC_Fwv_Ctrl_data = (l_sl1_VPC_Fwv_Ctrl_data_t*)ML_SLAVE_FRAME_DATA_BUFFER;
            l_signals.Fwv_Target_Mode = VPC_Fwv_Ctrl_data->sig_Fwv_Target_Mode;
    967c:	7eda 1004 	lod	X, #4100
    9680:	62f8      	lod	AL, [X]

00009682 <.LVL20>:
    9682:	9407      	and	AL, #7
    9684:	42d8 1194 	mov	0x1194 <_l_signals>, AL

00009688 <.LM20>:
            l_signals.Fwv_MoveEnable = VPC_Fwv_Ctrl_data->sig_Fwv_MoveEnable;
    9688:	62f8      	lod	AL, [X]
    968a:	44b0      	lsr	AL, #2
    968c:	4430      	lsr	AL
    968e:	9401      	and	AL, #1
    9690:	42d8 1195 	mov	0x1195 <_l_signals+0x1>, AL

00009694 <.LM21>:
            l_signals.Fwv_Initial = VPC_Fwv_Ctrl_data->sig_Fwv_Initial;
    9694:	62f8      	lod	AL, [X]
    9696:	44b0      	lsr	AL, #2
    9698:	44b0      	lsr	AL, #2
    969a:	9401      	and	AL, #1
    969c:	42d8 1196 	mov	0x1196 <_l_signals+0x2>, AL

000096a0 <.LM22>:
            l_signals.Fwv_ForcedDiag = VPC_Fwv_Ctrl_data->sig_Fwv_ForcedDiag;
    96a0:	62f8      	lod	AL, [X]
    96a2:	44b0      	lsr	AL, #2
    96a4:	44b0      	lsr	AL, #2
    96a6:	4430      	lsr	AL
    96a8:	9401      	and	AL, #1
    96aa:	42d8 1197 	mov	0x1197 <_l_signals+0x3>, AL

000096ae <.LM23>:
            l_signals.Fwv_Reserved1 = VPC_Fwv_Ctrl_data->sig_Fwv_Reserved1;
    96ae:	62d8 1005 	lod	AL, 0x1005 <_ml_Data+0x1>
    96b2:	42d8 1198 	mov	0x1198 <_l_signals+0x4>, AL

000096b6 <.L23>:
} l_sl1_VPC_Fwv_Ctrl_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Ctrl_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Ctrl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    96b6:	7000      	lod	A, #0

000096b8 <.LM25>:
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Ctrl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    96b8:	5401      	ret

000096ba <.L22>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    96ba:	7001      	lod	A, #1

000096bc <.LM27>:
            break;
    }
    return retVal;
}
    96bc:	5401      	ret

000096be <_l_sl1_VPC_Fwv_Resp_handler>:
    l_u8 unused56  : 8;
} l_sl1_VPC_Fwv_Resp_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Resp_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Resp_handler (l_s_FrameAction_t frameAction)
{
    96be:	582f      	inc	S, #48

000096c0 <.LCFI9>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Resp_flags_mask = {{0xe0, 0xff, 0xff, 0x10}};

    switch (frameAction) {
    96c0:	ac01      	cmp	A, #1
    96c2:	190d      	je	0x96de <.L26>
    96c4:	1803      	jc	0x96cc <.L27>
    96c6:	ac03      	cmp	A, #3
    96c8:	1901      	je	0x96cc <.L27>
    96ca:	00e0      	jmp	0x988c <.L32>

000096cc <.L27>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Resp_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    96cc:	54ca 0004 	pushw	#4

000096d0 <.LCFI10>:
    96d0:	54ca 5d86 	pushw	#23942

000096d4 <.LCFI11>:
    96d4:	72da 13fa 	lod	A, #5114

000096d8 <.LVL26>:
    96d8:	16ad      	call	0x9434 <_l_SetFlagsMask>

000096da <.LM31>:
            break;
    96da:	5c03      	dec	S, #4

000096dc <.LCFI12>:
    96dc:	00d5      	jmp	0x9888 <.L33>

000096de <.L26>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_Fwv_Actual_Mode = l_signals.Fwv_Actual_Mode;
    96de:	66d8 1199 	lod	YL, 0x1199 <_l_signals+0x5>

000096e2 <.LM33>:
            l_bool sig_Fwv_Position_Fault = l_signals.Fwv_Position_Fault;
    96e2:	62d8 119a 	lod	AL, 0x119a <_l_signals+0x6>

000096e6 <.LVL30>:
    96e6:	4205      	mov	[S-6], AL

000096e8 <.LM34>:
            l_bool sig_Fwv_FaultMode = l_signals.Fwv_FaultMode;
    96e8:	62d8 119b 	lod	AL, 0x119b <_l_signals+0x7>

000096ec <.LVL32>:
    96ec:	4209      	mov	[S-10], AL

000096ee <.LM35>:
            l_bool sig_Fwv_ProtectMode = l_signals.Fwv_ProtectMode;
    96ee:	62d8 119c 	lod	AL, 0x119c <_l_signals+0x8>

000096f2 <.LVL34>:
    96f2:	420b      	mov	[S-12], AL

000096f4 <.LM36>:
            l_bool sig_Fwv_InitialSta = l_signals.Fwv_InitialSta;
    96f4:	62d8 119d 	lod	AL, 0x119d <_l_signals+0x9>

000096f8 <.LVL36>:
    96f8:	420d      	mov	[S-14], AL

000096fa <.LM37>:
            l_bool sig_Fwv_Calibration_Fail = l_signals.Fwv_Calibration_Fail;
    96fa:	62d8 119e 	lod	AL, 0x119e <_l_signals+0xa>

000096fe <.LVL38>:
    96fe:	420f      	mov	[S-16], AL

00009700 <.LM38>:
            l_bool sig_Fwv_MoveEnable_Status = l_signals.Fwv_MoveEnable_Status;
    9700:	62d8 119f 	lod	AL, 0x119f <_l_signals+0xb>

00009704 <.LVL40>:
    9704:	4211      	mov	[S-18], AL

00009706 <.LM39>:
            l_bool sig_Fwv_Motor_Stall = l_signals.Fwv_Motor_Stall;
    9706:	62d8 11a0 	lod	AL, 0x11a0 <_l_signals+0xc>

0000970a <.LVL42>:
    970a:	4213      	mov	[S-20], AL

0000970c <.LM40>:
            l_bool sig_Fwv_Short_Circuit = l_signals.Fwv_Short_Circuit;
    970c:	62d8 11a1 	lod	AL, 0x11a1 <_l_signals+0xd>

00009710 <.LVL44>:
    9710:	4215      	mov	[S-22], AL

00009712 <.LM41>:
            l_bool sig_Fwv_Open_Circuit = l_signals.Fwv_Open_Circuit;
    9712:	62d8 11a2 	lod	AL, 0x11a2 <_l_signals+0xe>

00009716 <.LVL46>:
    9716:	4217      	mov	[S-24], AL

00009718 <.LM42>:
            l_bool sig_Fwv_Undervoltage = l_signals.Fwv_Undervoltage;
    9718:	62d8 11a3 	lod	AL, 0x11a3 <_l_signals+0xf>

0000971c <.LVL48>:
    971c:	4219      	mov	[S-26], AL

0000971e <.LM43>:
            l_bool sig_Fwv_Overvoltage = l_signals.Fwv_Overvoltage;
    971e:	62d8 11a4 	lod	AL, 0x11a4 <_l_signals+0x10>

00009722 <.LVL50>:
    9722:	421b      	mov	[S-28], AL

00009724 <.LM44>:
            l_bool sig_Fwv_Overcurrent = l_signals.Fwv_Overcurrent;
    9724:	62d8 11a5 	lod	AL, 0x11a5 <_l_signals+0x11>

00009728 <.LVL52>:
    9728:	421d      	mov	[S-30], AL

0000972a <.LM45>:
            l_bool sig_Fwv_Overtemperature = l_signals.Fwv_Overtemperature;
    972a:	62d8 11a6 	lod	AL, 0x11a6 <_l_signals+0x12>

0000972e <.LVL54>:
    972e:	421f      	mov	[S-32], AL

00009730 <.LM46>:
            l_bool sig_Fwv_Diag_Forced_Status = l_signals.Fwv_Diag_Forced_Status;
    9730:	62d8 11a7 	lod	AL, 0x11a7 <_l_signals+0x13>

00009734 <.LVL56>:
    9734:	4221      	mov	[S-34], AL

00009736 <.LM47>:
            l_bool sig_Fwv_Position_Sensor_Fault = l_signals.Fwv_Position_Sensor_Fault;
    9736:	62d8 11a8 	lod	AL, 0x11a8 <_l_signals+0x14>

0000973a <.LVL58>:
    973a:	4223      	mov	[S-36], AL

0000973c <.LM48>:
            l_bool sig_Fwv_CommErr = l_signals.Fwv_CommErr;
    973c:	62d8 11a9 	lod	AL, 0x11a9 <_l_signals+0x15>

00009740 <.LVL60>:
    9740:	4225      	mov	[S-38], AL

00009742 <.LM49>:
            l_u16 sig_Fwv_SW_Version = l_signals.Fwv_SW_Version;
    9742:	72d8 11aa 	lod	A, 0x11aa <_l_signals+0x16>

00009746 <.LVL62>:
    9746:	5207      	mov	[S-8], A

00009748 <.LM50>:
            l_u8 sig_Fwv_Stall_State = l_signals.Fwv_Stall_State;
    9748:	62d8 11ac 	lod	AL, 0x11ac <_l_signals+0x18>

0000974c <.LVL64>:
    974c:	4227      	mov	[S-40], AL

0000974e <.LM51>:

            l_sl1_VPC_Fwv_Resp_data_t VPC_Fwv_Resp_data = {
    974e:	7ee6      	lod	X, Y
    9750:	3407      	and	X, #7
    9752:	5e01      	mov	[S-2], X
    9754:	7a2f      	lod	Y, [S-48]

00009756 <.LVL66>:
    9756:	f4f0      	and	Y, #-16
    9758:	7e05      	lod	X, [S-6]
    975a:	3401      	and	X, #1
    975c:	72ee      	lod	A, X

0000975e <.LVL67>:
    975e:	44a2      	asl	A, #2
    9760:	4422      	asl	A
    9762:	e601      	or	Y, [S-2]
    9764:	e6e2      	or	Y, A
    9766:	7e09      	lod	X, [S-10]
    9768:	3401      	and	X, #1
    976a:	72ee      	lod	A, X
    976c:	44a2      	asl	A, #2
    976e:	44a2      	asl	A, #2
    9770:	5201      	mov	[S-2], A
    9772:	f4cf      	and	Y, #-49
    9774:	7e0b      	lod	X, [S-12]
    9776:	3401      	and	X, #1
    9778:	72ee      	lod	A, X
    977a:	4862 0020 	mulu	A, A, #32
    977e:	e601      	or	Y, [S-2]
    9780:	e6e2      	or	Y, A
    9782:	7e0d      	lod	X, [S-14]
    9784:	3401      	and	X, #1
    9786:	72ee      	lod	A, X
    9788:	4862 0040 	mulu	A, A, #64
    978c:	5201      	mov	[S-2], A
    978e:	f6da ff3f 	and	Y, #65343
    9792:	7e0f      	lod	X, [S-16]
    9794:	3401      	and	X, #1
    9796:	72ee      	lod	A, X
    9798:	4862 0080 	mulu	A, A, #128
    979c:	e601      	or	Y, [S-2]
    979e:	e6e2      	or	Y, A
    97a0:	7e11      	lod	X, [S-18]
    97a2:	3401      	and	X, #1
    97a4:	72ee      	lod	A, X
    97a6:	6800      	lod	AH, #0
    97a8:	72e4      	swap	A
    97aa:	5201      	mov	[S-2], A
    97ac:	f6da fcff 	and	Y, #64767
    97b0:	7e13      	lod	X, [S-20]
    97b2:	3401      	and	X, #1
    97b4:	72ee      	lod	A, X
    97b6:	4862 0200 	mulu	A, A, #512
    97ba:	e601      	or	Y, [S-2]
    97bc:	e6e2      	or	Y, A
    97be:	7e15      	lod	X, [S-22]
    97c0:	3401      	and	X, #1
    97c2:	72ee      	lod	A, X
    97c4:	4862 0400 	mulu	A, A, #1024
    97c8:	5201      	mov	[S-2], A
    97ca:	f6da f3ff 	and	Y, #62463
    97ce:	7e17      	lod	X, [S-24]
    97d0:	3401      	and	X, #1
    97d2:	72ee      	lod	A, X
    97d4:	4862 0800 	mulu	A, A, #2048
    97d8:	e601      	or	Y, [S-2]
    97da:	e6e2      	or	Y, A
    97dc:	7e19      	lod	X, [S-26]
    97de:	3401      	and	X, #1
    97e0:	72ee      	lod	A, X
    97e2:	4862 1000 	mulu	A, A, #4096
    97e6:	5201      	mov	[S-2], A
    97e8:	f6da cfff 	and	Y, #53247
    97ec:	7e1b      	lod	X, [S-28]
    97ee:	3401      	and	X, #1
    97f0:	72ee      	lod	A, X
    97f2:	4862 2000 	mulu	A, A, #8192
    97f6:	e601      	or	Y, [S-2]
    97f8:	e6e2      	or	Y, A
    97fa:	7e1d      	lod	X, [S-30]
    97fc:	3401      	and	X, #1
    97fe:	72ee      	lod	A, X
    9800:	b403      	and	A, #3
    9802:	44d2      	rr	A, #2
    9804:	5203      	mov	[S-4], A
    9806:	f6da 3fff 	and	Y, #16383
    980a:	621f      	lod	AL, [S-32]
    980c:	b401      	and	A, #1
    980e:	4452      	rr	A
    9810:	7ee2      	lod	X, A
    9812:	7203      	lod	A, [S-4]
    9814:	a6e6      	or	A, Y
    9816:	a6ee      	or	A, X
    9818:	522f      	mov	[S-48], A
    981a:	6621      	lod	YL, [S-34]
    981c:	f401      	and	Y, #1
    981e:	7e2d      	lod	X, [S-46]
    9820:	34fc      	and	X, #-4
    9822:	5e01      	mov	[S-2], X
    9824:	7e23      	lod	X, [S-36]
    9826:	3401      	and	X, #1
    9828:	72ee      	lod	A, X
    982a:	4422      	asl	A
    982c:	7e01      	lod	X, [S-2]
    982e:	26e6      	or	X, Y
    9830:	26e2      	or	X, A
    9832:	6225      	lod	AL, [S-38]
    9834:	b401      	and	A, #1
    9836:	44a2      	asl	A, #2
    9838:	7ae2      	lod	Y, A
    983a:	72ee      	lod	A, X
    983c:	94fb      	and	AL, #-5
    983e:	a6e6      	or	A, Y
    9840:	84f8      	or	AL, #-8
    9842:	422d      	mov	[S-46], AL
    9844:	6207      	lod	AL, [S-8]
    9846:	422c      	mov	[S-45], AL
    9848:	7a07      	lod	Y, [S-8]
    984a:	6400      	lod	YL, #0
    984c:	7ae8      	swap	Y
    984e:	7e2b      	lod	X, [S-44]
    9850:	36da fc00 	and	X, #64512
    9854:	5e03      	mov	[S-4], X
    9856:	7e27      	lod	X, [S-40]
    9858:	3403      	and	X, #3
    985a:	5e07      	mov	[S-8], X

0000985c <.LVL68>:
    985c:	72ee      	lod	A, X
    985e:	6800      	lod	AH, #0
    9860:	72e4      	swap	A
    9862:	7e03      	lod	X, [S-4]
    9864:	26e6      	or	X, Y
    9866:	a6ee      	or	A, X
    9868:	522b      	mov	[S-44], A
    986a:	7eef      	lod	X, S
    986c:	20d5      	add	X, #-43
    986e:	62f8      	lod	AL, [X]
    9870:	84fc      	or	AL, #-4
    9872:	42f8      	mov	[X], AL
    9874:	72da 00ff 	lod	A, #255
    9878:	4229      	mov	[S-42], AL
    987a:	4228      	mov	[S-41], AL

0000987c <.LM52>:
                sig_Fwv_Stall_State,
                0x3f,
                0xff,
                0xff
            };
            l_FillBufferSlave((l_u8*)&VPC_Fwv_Resp_data, (l_u8)sizeof(l_sl1_VPC_Fwv_Resp_data_t));
    987c:	54ca 0008 	pushw	#8

00009880 <.LCFI13>:
    9880:	72ef      	lod	A, S
    9882:	a0ce      	add	A, #-50
    9884:	16a9      	call	0x95d8 <_l_FillBufferSlave>

00009886 <.LVL70>:
    9886:	5c01      	dec	S, #2

00009888 <.L33>:
} l_sl1_VPC_Fwv_Resp_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Resp_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Resp_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    9888:	7000      	lod	A, #0

0000988a <.LM54>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Resp_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    988a:	5431      	ret	#50

0000988c <.L32>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    988c:	7001      	lod	A, #1

0000988e <.LM56>:
            break;
    }
    return retVal;
}
    988e:	5431      	ret	#50

00009890 <_globalVariableInit>:
 * @return 0
 */

void globalVariableInit(void)
{
	g_u16MotorSupplyVoltage = C_VSUP_REF; /**< [10mV] */
    9890:	72da 04b0 	lod	A, #1200
    9894:	52d8 1426 	mov	0x1426 <_g_u16MotorSupplyVoltage>, A

00009898 <.LM3>:
	g_i16ChipTemperature = 35;			  /**< [C] */
    9898:	7c23      	lod	X, #35
    989a:	0ea7      	lod	C, ML.7
    989c:	5ed8 140c 	mov	0x140c <_g_i16ChipTemperature>, X

000098a0 <.LM4>:
	g_u16SupplyVoltage = C_VSUP_REF;	  /**< [10mV] */
    98a0:	52d8 142e 	mov	0x142e <_g_u16SupplyVoltage>, A

000098a4 <.LM5>:
	g_u16VBGD = 1185u;					  /**< analog supply voltage [1mV] */
    98a4:	72da 04a1 	lod	A, #1185
    98a8:	0ea7      	lod	C, ML.7
    98aa:	52d8 142a 	mov	0x142a <_g_u16VBGD>, A

000098ae <.LM6>:
	l_u32MotorSupplyVoltageFilter = 0u;
    98ae:	4cfa 0000 	movs	YA, #0
    98b2:	52d8 1432 	mov	0x1432 <_l_u32MotorSupplyVoltageFilter>, A
    98b6:	0ea7      	lod	C, ML.7
    98b8:	5ad8 1434 	mov	0x1434 <_l_u32MotorSupplyVoltageFilter+0x2>, Y

000098bc <.LM7>:
	l_u32SupplyVoltageFilter = 0u;
    98bc:	52d8 1406 	mov	0x1406 <_l_u32SupplyVoltageFilter>, A
    98c0:	5ad8 1408 	mov	0x1408 <_l_u32SupplyVoltageFilter+0x2>, Y

000098c4 <.LM8>:
	l_u32ChipTemperatureFilter = 0u;
    98c4:	0ea7      	lod	C, ML.7
    98c6:	52d8 141c 	mov	0x141c <_l_u32ChipTemperatureFilter>, A
    98ca:	5ad8 141e 	mov	0x141e <_l_u32ChipTemperatureFilter+0x2>, Y

000098ce <.LM9>:
	g_u16IO3 = 0;  /**< [1mV] */
    98ce:	52d8 141a 	mov	0x141a <_g_u16IO3>, A

000098d2 <.LM10>:
	g_u16VDDA = 0; /**< [1mV] */
    98d2:	0ea7      	lod	C, ML.7
    98d4:	52d8 1416 	mov	0x1416 <_g_u16VDDA>, A

000098d8 <.LM11>:
	g_i16ShuntCurrent = 0u;
    98d8:	52d8 1428 	mov	0x1428 <_g_i16ShuntCurrent>, A

000098dc <.LM12>:
	g_u16PositionSensor = 0;
    98dc:	52d8 1404 	mov	0x1404 <_g_u16PositionSensor>, A

000098e0 <.LM13>:
	u16_Angle_Gap = 0;
    98e0:	0ea7      	lod	C, ML.7
    98e2:	52d8 1410 	mov	0x1410 <_u16_Angle_Gap>, A

000098e6 <.LM14>:
	SetDuty = 0;
    98e6:	52d8 1418 	mov	0x1418 <_SetDuty>, A

000098ea <.LM15>:
	u16_LIN_Target_Angle = 3;
    98ea:	7c03      	lod	X, #3
    98ec:	0ea7      	lod	C, ML.7
    98ee:	5ed8 1414 	mov	0x1414 <_u16_LIN_Target_Angle>, X

000098f2 <.LM16>:
	u16_CONV_Target_Angle = 0;
    98f2:	52d8 140a 	mov	0x140a <_u16_CONV_Target_Angle>, A

000098f6 <.LM17>:
	u16_Target_Angle_LCL = 0;
    98f6:	52d8 1422 	mov	0x1422 <_u16_Target_Angle_LCL>, A

000098fa <.LM18>:
	u16_Target_Angle_UCL = 0;
    98fa:	0ea7      	lod	C, ML.7
    98fc:	52d8 140e 	mov	0x140e <_u16_Target_Angle_UCL>, A

00009900 <.LM19>:
	Angle_Hysteresis = 7U;
    9900:	7c07      	lod	X, #7
    9902:	5ed8 1420 	mov	0x1420 <_Angle_Hysteresis>, X

00009906 <.LM20>:
	u16_Duty_Dec_Range = 0;
    9906:	0ea7      	lod	C, ML.7
    9908:	52d8 1402 	mov	0x1402 <_u16_Duty_Dec_Range>, A

0000990c <.LM21>:
	u16_IGN_PORT_CNT = 0;
    990c:	52d8 1412 	mov	0x1412 <_u16_IGN_PORT_CNT>, A

00009910 <.LM22>:
}
    9910:	5401      	ret

00009912 <_system_timer_ISR>:

void system_timer_ISR()
{
	if(motor.fault.openDetectCnt < OPEN_DETECT_TIMEOUT)    {	
    9912:	72d8 12e6 	lod	A, 0x12e6 <.LLST33+0x3>
    9916:	aeda 01f3 	cmp	A, #499
    991a:	1e03      	jug	0x9922 <.L3>

0000991c <.LM25>:
		motor.fault.openDetectCnt++; 
    991c:	a001      	add	A, #1
    991e:	52d8 12e6 	mov	0x12e6 <.LLST33+0x3>, A

00009922 <.L3>:
	}

	if(motor.fault.ocDetectCnt < OVER_CURRNET_DETECT_TIMEOUT)    {	
    9922:	72d8 12e2 	lod	A, 0x12e2 <.LASF1639+0xa>
    9926:	aeda 012b 	cmp	A, #299
    992a:	1e03      	jug	0x9932 <.L4>

0000992c <.LM27>:
		motor.fault.ocDetectCnt++; 
    992c:	a001      	add	A, #1
    992e:	52d8 12e2 	mov	0x12e2 <.LASF1639+0xa>, A

00009932 <.L4>:
	}

	if(motor.out.enable)
    9932:	72d8 12c4 	lod	A, 0x12c4 <.LASF1024+0x9>
    9936:	1907      	je	0x9946 <.L5>

00009938 <.LM29>:
	{
		if(motor.stall.maskTimer < STALL_DETECT_TIMEOUT) {
    9938:	72d8 12d2 	lod	A, 0x12d2 <.LASF2063>
    993c:	ac09      	cmp	A, #9
    993e:	1e03      	jug	0x9946 <.L5>

00009940 <.LM30>:
			motor.stall.maskTimer++;
    9940:	a001      	add	A, #1
    9942:	52d8 12d2 	mov	0x12d2 <.LASF2063>, A

00009946 <.L5>:
		}
	}

	if(test_Timer < 20000)
    9946:	72d8 11b6 	lod	A, 0x11b6 <_test_Timer>
    994a:	aeda 4e1f 	cmp	A, #19999
    994e:	1e04      	jug	0x9958 <.L6>

00009950 <.LM32>:
	{
		test_Timer++;
    9950:	a001      	add	A, #1
    9952:	52d8 11b6 	mov	0x11b6 <_test_Timer>, A
    9956:	5401      	ret

00009958 <.L6>:
	}
	else
	{
		test_Timer = 20001;
    9958:	7eda 4e21 	lod	X, #20001
    995c:	5ed8 11b6 	mov	0x11b6 <_test_Timer>, X

00009960 <.LM34>:

		if(test_relese_Timer < 20000)
    9960:	72d8 11b4 	lod	A, 0x11b4 <_test_relese_Timer>
    9964:	0ea7      	lod	C, ML.7
    9966:	aeda 4e1f 	cmp	A, #19999
    996a:	1e04      	jug	0x9974 <.L8>

0000996c <.LM35>:
		{
			test_relese_Timer++;
    996c:	a001      	add	A, #1
    996e:	52d8 11b4 	mov	0x11b4 <_test_relese_Timer>, A
    9972:	5401      	ret

00009974 <.L8>:
		}
		else
		{
			test_relese_Timer = 20001;
    9974:	5ed8 11b4 	mov	0x11b4 <_test_relese_Timer>, X

00009978 <.LM37>:
		}
	}
	

}
    9978:	5401      	ret

0000997a <_main>:

int main(void)
{
    997a:	5801      	inc	S, #2

0000997c <.LBB234>:

/** WDG_disableIwdIt disables the intelligent watchdog timer interrupt */
STATIC INLINE void WDG_disableIwdIt(void)
{
    /* disable IWD interrupt */
    IO_SET(MLX16, IWD_ATT_ITC, 0u);
    997c:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    9980:	94f7      	and	AL, #-9
    9982:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

00009986 <.LBE234>:
	/* Initialize watch-dogs, both analogue and digital */
	WDG_disableIwdIt();

	/* Initialize globalVariable */
	globalVariableInit();
    9986:	1784      	call	0x9890 <_globalVariableInit>

00009988 <.LBB236>:
 * Log reset source
 */
static void log_reset_source(void)
{
	uint16_t temp;
	if (IO_GET(PORT_MISC_IN, LOCAL_WU) != 0u)
    9988:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    998c:	d440      	and	AH, #64
    998e:	1d05      	jne	0x999a <.L25>

00009990 <.LM42>:
	{
		/* IO_0 wake up */
	}
	else if (IO_GET(PORT_MISC_IN, LIN_WU) != 0u)
    9990:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    9994:	d408      	and	AH, #8
    9996:	1d01      	jne	0x999a <.L25>

00009998 <.LM43>:
	{
		/* LIN wake up */
	}
	else if (IO_GET(RST_CTRL, AWD_WBOOT) != 0u)
    9998:	7282      	lod	A, io:0x2 <_RST_CTRL>

0000999a <.L25>:
	uint16_t temp;
	if (IO_GET(PORT_MISC_IN, LOCAL_WU) != 0u)
	{
		/* IO_0 wake up */
	}
	else if (IO_GET(PORT_MISC_IN, LIN_WU) != 0u)
    999a:	7020      	lod	A, #32

0000999c <.L17>:

STATIC INLINE uint8_t softio_get(GpioIo_t IO)
{
    uint8_t pinlevel = 0xFFu;
    if(IO <= MAXIO_INDEX) {
        pinlevel = (uint8_t)(IO_GET(PORT_IO_IN, IO_IN_SYNC) >> (uint16_t)IO) & 0x01u;
    999c:	7ed8 01de 	lod	X, 0x1de <_PORT_IO_IN>

000099a0 <.LBE238>:
	}
#if LIN_WAKEUP_DISABLE == 1
	for (temp = 32; temp > 0; temp--)
	{

		if (softio_get(0) == 0)
    99a0:	3401      	and	X, #1
    99a2:	1d0b      	jne	0x99ba <.L15>

000099a4 <.LM47>:
		{

			u16_IGN_PORT_CNT++;
    99a4:	7ed8 1412 	lod	X, 0x1412 <_u16_IGN_PORT_CNT>
    99a8:	2001      	add	X, #1
    99aa:	5ed8 1412 	mov	0x1412 <_u16_IGN_PORT_CNT>, X

000099ae <.LM48>:
			if (u16_IGN_PORT_CNT >= 16)
    99ae:	2c0f      	cmp	X, #15
    99b0:	1a04      	jule	0x99ba <.L15>

000099b2 <.LM49>:
			{
				lin22_GotoSleep();
    99b2:	5201      	mov	[S-2], A
    99b4:	82db 47fa 	callf	0x8ff4 <_lin22_GotoSleep>

000099b8 <.LVL3>:
    99b8:	7201      	lod	A, [S-2]

000099ba <.L15>:
	{

		/* power on reset */
	}
#if LIN_WAKEUP_DISABLE == 1
	for (temp = 32; temp > 0; temp--)
    99ba:	a0ff      	add	A, #-1

000099bc <.LVL5>:
    99bc:	1d6f      	jne	0x999c <.L17>

000099be <.LBE236>:
#if UART_DEBUG_ENABLE
	uartInit();
#endif

	/* Initialize the timeout timer module */
	swtimer_init();
    99be:	1230      	call	0x9e20 <_swtimer_init>

000099c0 <.LM52>:

	ctimer0_init(CTIMER0_1MS);
    99c0:	72da 07d0 	lod	A, #2000
    99c4:	12f5      	call	0x9fb0 <_ctimer0_init>

000099c6 <.LM53>:

	/* Initialize the eeprom handler */
	eeprom_Init();
    99c6:	82db 4450 	callf	0x88a0 <_eeprom_Init>

000099ca <.LM54>:

	/* initialize the pwm module */
	pwm_Init();
    99ca:	10f3      	call	0x9bb2 <_pwm_Init>

000099cc <.LM55>:

	/* Initialize the lin handler */
	lin22_Init();
    99cc:	82db 4754 	callf	0x8ea8 <_lin22_Init>

000099d0 <.LM56>:

	/* Initialize the adc driver */
	adc_Init();
    99d0:	82db 3bba 	callf	0x7774 <_adc_Init>

000099d4 <.LM57>:

	adc_Shunt_OffsetCalib();
    99d4:	82db 3c31 	callf	0x7862 <_adc_Shunt_OffsetCalib>

000099d8 <.LM58>:
	adc_Start(true); /* pwm must be initialized before you can use the do start and wait for loop */
    99d8:	7001      	lod	A, #1
    99da:	82db 3be1 	callf	0x77c2 <_adc_Start>

000099de <.LM59>:

	ctimer0_start();
    99de:	1302      	call	0x9fe4 <_ctimer0_start>

000099e0 <.LM60>:

	/* Start application */
	IO_SET(PORT_IO_ENABLE, IO_DISREC, 0x1E); // IO 1~4 -> ADC
    99e0:	601e      	lod	AL, #30
    99e2:	42d8 023b 	mov	0x23b <_PORT_IO_ENABLE+0x1>, AL

000099e6 <.LBB240>:
#if defined(HAS_HW_IO0_HV)
/** Enable high voltage cell of IO 0
 */
STATIC INLINE void gpio_io0HvEnable(void)
{
    IO_SET(PORT_IO_OUT_EN, IO0_LV_ENABLE, 0u);
    99e6:	0ea7      	lod	C, ML.7
    99e8:	62d8 01e8 	lod	AL, 0x1e8 <_PORT_IO_OUT_EN>
    99ec:	947f      	and	AL, #127
    99ee:	42d8 01e8 	mov	0x1e8 <_PORT_IO_OUT_EN>, AL

000099f2 <.LBE240>:
	gpio_io0HvEnable();						 // 250702-1 Support IO0 for High Voltage ,ignition interface.
	/* diag & prot */
	protection_Init();
    99f2:	1067      	call	0x9ac2 <_protection_Init>

000099f4 <.LBB242>:
 * @returns  raw Vsm adc sample.
 */
static INLINE uint16_t adc_GetRawVsm(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VSM];
    99f4:	72d8 12e8 	lod	A, 0x12e8 <_dBase>

000099f8 <.LBE244>:
 * --------------------------------------------- */
static void background_Handler(void);
static void log_reset_source(void);
static void app_Initialize(void)
{
	l_u32MotorSupplyVoltageFilter = adc_GetRawVsm() * 4u;
    99f8:	44a2      	asl	A, #2
    99fa:	4cf2      	usex	YA
    99fc:	52d8 1432 	mov	0x1432 <_l_u32MotorSupplyVoltageFilter>, A
    9a00:	5ad8 1434 	mov	0x1434 <_l_u32MotorSupplyVoltageFilter+0x2>, Y

00009a04 <.LBB246>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    9a04:	72d8 12f2 	lod	A, 0x12f2 <_dBase+0xa>

00009a08 <.LBE246>:
	l_u32SupplyVoltageFilter = adc_GetRawVs() * 4u;
    9a08:	44a2      	asl	A, #2
    9a0a:	4cf2      	usex	YA
    9a0c:	52d8 1406 	mov	0x1406 <_l_u32SupplyVoltageFilter>, A
    9a10:	5ad8 1408 	mov	0x1408 <_l_u32SupplyVoltageFilter+0x2>, Y

00009a14 <.LBB248>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    9a14:	72d8 12ea 	lod	A, 0x12ea <_dBase+0x2>

00009a18 <.LBE248>:
	l_u32ChipTemperatureFilter = adc_GetRawTemperature() * 4u;
    9a18:	44a2      	asl	A, #2
    9a1a:	4cf2      	usex	YA
    9a1c:	52d8 141c 	mov	0x141c <_l_u32ChipTemperatureFilter>, A
    9a20:	5ad8 141e 	mov	0x141e <_l_u32ChipTemperatureFilter+0x2>, Y

00009a24 <.LM69>:
	swtimer_register((uint16_t)SWTIMER_MOT_CTRL_PERIOD, 1, REPETITIVE); // 100usec
    9a24:	54ca 0001 	pushw	#1

00009a28 <.LCFI1>:
    9a28:	0ea7      	lod	C, ML.7
    9a2a:	54ca 0001 	pushw	#1

00009a2e <.LCFI2>:
    9a2e:	7005      	lod	A, #5
    9a30:	122c      	call	0x9e8a <_swtimer_register>

00009a32 <.LM70>:
	swtimer_start((uint16_t)SWTIMER_MOT_CTRL_PERIOD);
    9a32:	7005      	lod	A, #5
    9a34:	1240      	call	0x9eb6 <_swtimer_start>

00009a36 <.LM71>:
	swtimer_register((uint16_t)SWTIMER_APP_CTRL_PERIOD, 10, REPETITIVE); // 1msec
    9a36:	54ca 0001 	pushw	#1

00009a3a <.LCFI3>:
    9a3a:	54ca 000a 	pushw	#10

00009a3e <.LCFI4>:
    9a3e:	0ea7      	lod	C, ML.7
    9a40:	7006      	lod	A, #6
    9a42:	1223      	call	0x9e8a <_swtimer_register>

00009a44 <.LM72>:
	swtimer_start((uint16_t)SWTIMER_APP_CTRL_PERIOD);
    9a44:	7006      	lod	A, #6
    9a46:	1237      	call	0x9eb6 <_swtimer_start>

00009a48 <.LM73>:

	AppLinInit();
    9a48:	82db 31b5 	callf	0x636a <_AppLinInit>

00009a4c <.LM74>:
	sensor_init();
    9a4c:	82db 3cc5 	callf	0x798a <_sensor_init>

00009a50 <.LM75>:
	app_mot_init();
    9a50:	82db 3f7f 	callf	0x7efe <_app_mot_init>

00009a54 <.LM76>:
	AppValveInit();
    9a54:	82db 3540 	callf	0x6a80 <_AppValveInit>

00009a58 <.LBB250>:
        );
}

STATIC INLINE void builtin_mlx16_enter_user_mode(void)
{
    __asm__ __volatile__ ("setb MH.3" ::: "M", "memory");
    9a58:	0ab3      	setb	MH.3
    9a5a:	5c07      	dec	S, #8

00009a5c <.L22>:
    9a5c:	0f7f      	lod	C, io:0x0f.7

00009a5e <.LBE254>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    9a5e:	1c01      	jnc	0x9a62 <.L18>

00009a60 <.LM80>:
        IO_SET(AWD, ACK, 1u);
    9a60:	0b76      	setb	io:0x0e.6

00009a62 <.L18>:
#endif
	/* Application loop */
	while (1u)
	{
		WDG_conditionalAwdRefresh(); /* Restart watchdog */
		AppLinTask();
    9a62:	82db 31bb 	callf	0x6376 <_AppLinTask>

00009a66 <.LM82>:

		protection_Task();
    9a66:	10a2      	call	0x9bac <_protection_Task>

00009a68 <.LM83>:
		//     fm_Atan2HelperInterpolationInlined(100,200);

		if (g_bUnderVoltageDetected) /* log UV_VS interrupt detection */
    9a68:	62d8 11b8 	lod	AL, 0x11b8 <_g_bUnderVoltageDetected>
    9a6c:	1903      	je	0x9a74 <.L19>

00009a6e <.LM84>:
		{
			g_bUnderVoltageDetected = false; /* IC self detect*/
    9a6e:	6000      	lod	AL, #0
    9a70:	42d8 11b8 	mov	0x11b8 <_g_bUnderVoltageDetected>, AL

00009a74 <.L19>:
		}
		if (swtimer_isTriggered((uint16_t)SWTIMER_MOT_CTRL_PERIOD) != 0u) // 100us period
    9a74:	7005      	lod	A, #5
    9a76:	1230      	call	0x9ed8 <_swtimer_isTriggered>
    9a78:	ac00      	cmp	A, #0
    9a7a:	1902      	je	0x9a80 <.L20>

00009a7c <.LM86>:
		{
			motor_ctrl_handler();
    9a7c:	82db 4208 	callf	0x8410 <_motor_ctrl_handler>

00009a80 <.L20>:
		}
		if (swtimer_isTriggered((uint16_t)SWTIMER_APP_CTRL_PERIOD) != 0u) // 1ms period
    9a80:	7006      	lod	A, #6
    9a82:	122a      	call	0x9ed8 <_swtimer_isTriggered>
    9a84:	ac00      	cmp	A, #0
    9a86:	1904      	je	0x9a90 <.L21>

00009a88 <.LM88>:
		{
			app_motor_task();
    9a88:	82db 3fe1 	callf	0x7fc2 <_app_motor_task>

00009a8c <.LM89>:
			AppValveTask();
    9a8c:	82db 35d8 	callf	0x6bb0 <_AppValveTask>

00009a90 <.L21>:
static void background_Handler(void)
{
	static int16_t i16ChipTemperature = 35;

	/* Calibrate stimer over temperature */
	if (abs(g_i16ChipTemperature - i16ChipTemperature) > 10)
    9a90:	72d8 140c 	lod	A, 0x140c <_g_i16ChipTemperature>
    9a94:	aad8 10a6 	sub	A, 0x10a6 <___i16ChipTemperature_8613>
    9a98:	1d81      	jnn	0x9a9c <.L37>
    9a9a:	5cc2      	neg	A

00009a9c <.L37>:
    9a9c:	ac0a      	cmp	A, #10
    9a9e:	1b5e      	jsle	0x9a5c <.L22>

00009aa0 <.LBB258>:
    9aa0:	72d8 12ea 	lod	A, 0x12ea <_dBase+0x2>

00009aa4 <.LBE258>:
	{
		swtimer_calibrate(adc_GetRawTemperature());
    9aa4:	11e6      	call	0x9e72 <_swtimer_calibrate>

00009aa6 <.LM93>:
		i16ChipTemperature = g_i16ChipTemperature;
    9aa6:	72d8 140c 	lod	A, 0x140c <_g_i16ChipTemperature>
    9aaa:	52d8 10a6 	mov	0x10a6 <___i16ChipTemperature_8613>, A
    9aae:	0ea7      	lod	C, ML.7
    9ab0:	07d5      	jmp	0x9a5c <.L22>

00009ab2 <_EVENT_UnderVoltage>:
 * \image html diode.png
 * \image latex diode.png
 */
void EVENT_UnderVoltage(void)
{
	g_bUnderVoltageDetected = true;
    9ab2:	6001      	lod	AL, #1
    9ab4:	42d8 11b8 	mov	0x11b8 <_g_bUnderVoltageDetected>, AL

00009ab8 <.LM96>:
}
    9ab8:	5401      	ret

00009aba <_EVENT_GotoSleep>:
    9aba:	0f7f      	lod	C, io:0x0f.7

00009abc <.LBE262>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    9abc:	1c01      	jnc	0x9ac0 <.L40>

00009abe <.LM102>:
        IO_SET(AWD, ACK, 1u);
    9abe:	0b76      	setb	io:0x0e.6

00009ac0 <.L40>:
 */
void EVENT_GotoSleep(void)
{

	WDG_conditionalAwdRefresh(); /* Restart watchdog */
}
    9ac0:	5401      	ret

00009ac2 <_protection_Init>:
    9ac2:	5801      	inc	S, #2

00009ac4 <.LCFI0>:
    9ac4:	7800      	lod	Y, #0
    9ac6:	5ad8 11d8 	mov	0x11d8 <_g_e8ErrorVoltage>, Y

00009aca <.LM3>:
    9aca:	5ad8 11d6 	mov	0x11d6 <_g_e8ErrorOverTemperature>, Y

00009ace <.LM4>:
    9ace:	0ea7      	lod	C, ML.7
    9ad0:	5ad8 11d4 	mov	0x11d4 <_g_e8ShortOcc>, Y

00009ad4 <.LM5>:
    9ad4:	46d8 11d2 	mov	0x11d2 <_g_e8OverCurrent>, YL

00009ad8 <.LM6>:
    9ad8:	5adf      	push	Y

00009ada <.LCFI1>:
    9ada:	54ca 04e2 	pushw	#1250

00009ade <.LCFI2>:
    9ade:	7003      	lod	A, #3
    9ae0:	5a05      	mov	[S-6], Y
    9ae2:	11d3      	call	0x9e8a <_swtimer_register>

00009ae4 <.LM7>:
    9ae4:	7a05      	lod	Y, [S-6]
    9ae6:	5adf      	push	Y

00009ae8 <.LCFI3>:
    9ae8:	54ca 0064 	pushw	#100

00009aec <.LCFI4>:
    9aec:	7004      	lod	A, #4
    9aee:	11cd      	call	0x9e8a <_swtimer_register>

00009af0 <.LM8>:
    9af0:	82db 43a0 	callf	0x8740 <_diagnostic_Init>

00009af4 <.LM9>:
    9af4:	82db 43d0 	callf	0x87a0 <_diagnostic_Start>

00009af8 <.LCFI5>:
    9af8:	540b      	ret	#12

00009afa <_protection_CheckShort>:
        {
        }	g_e8OverCurrent = 0;
    }
    */
   
    if (diagnostic_IsVDSPending())
    9afa:	82db 4417 	callf	0x882e <_diagnostic_IsVDSPending>
    9afe:	ac00      	cmp	A, #0
    9b00:	1903      	je	0x9b08 <.L5>

00009b02 <.LM22>:
    {
        g_e8ShortOcc = C_ERR_SHORT_VDS;
    9b02:	7002      	lod	A, #2
    9b04:	52d8 11d4 	mov	0x11d4 <_g_e8ShortOcc>, A

00009b08 <.L5>:
        {
        }
        //        g_e8ShortOcc = C_ERR_SHORT_NO;
        /* MISRA C-2012 Rule 15.7 */
    }
}
    9b08:	5401      	ret

00009b0a <_protection_CheckSupplyMotorVoltage>:
 *
 * @param[in]  a_u16SupplyMotorVoltage  VSM voltage [10mV]
 */
void protection_CheckSupplyMotorVoltage(void)
{
    if (diagnostic_IsOVPending())
    9b0a:	82db 440e 	callf	0x881c <_diagnostic_IsOVPending>
    9b0e:	ac00      	cmp	A, #0
    9b10:	1904      	je	0x9b1a <.L11>

00009b12 <.LM26>:
    {
        g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
    9b12:	7004      	lod	A, #4

00009b14 <.L19>:
    }
    else if (diagnostic_IsUVPending())
    {

        g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    9b14:	52d8 11d8 	mov	0x11d8 <_g_e8ErrorVoltage>, A
    9b18:	5401      	ret

00009b1a <.L11>:
{
    if (diagnostic_IsOVPending())
    {
        g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
    }
    else if (diagnostic_IsUVPending())
    9b1a:	82db 4409 	callf	0x8812 <_diagnostic_IsUVPending>
    9b1e:	ac00      	cmp	A, #0
    9b20:	1902      	je	0x9b26 <.L13>

00009b22 <.LM29>:
    {

        g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    9b22:	7002      	lod	A, #2
    9b24:	07f7      	jmp	0x9b14 <.L19>

00009b26 <.L13>:
    }
    else
    {
        if ((g_e8ErrorVoltage == C_ERR_VOLTAGE_OVER_HW) && (get_valve_voltage() < C_APPL_OVOLT))
    9b26:	72d8 11d8 	lod	A, 0x11d8 <_g_e8ErrorVoltage>
    9b2a:	ac04      	cmp	A, #4
    9b2c:	1d0f      	jne	0x9b4c <.L15>

00009b2e <.LM31>:
    9b2e:	82db 3537 	callf	0x6a6e <_get_valve_voltage>
    9b32:	aeda 0707 	cmp	A, #1799
    9b36:	1e0a      	jug	0x9b4c <.L15>

00009b38 <.LM32>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u); /* clear MEM flag */
    9b38:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9b3c:	8408      	or	AL, #8
    9b3e:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009b42 <.LM33>:
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u); /* re-enable hardware protection */
    9b42:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9b46:	94f7      	and	AL, #-9
    9b48:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009b4c <.L15>:
        }
        if ((g_e8ErrorVoltage == C_ERR_VOLTAGE_UNDER_HW) && (get_valve_voltage() > C_APPL_UVOLT))
    9b4c:	72d8 11d8 	lod	A, 0x11d8 <_g_e8ErrorVoltage>
    9b50:	ac02      	cmp	A, #2
    9b52:	1d0f      	jne	0x9b72 <.L10>

00009b54 <.LM35>:
    9b54:	82db 3537 	callf	0x6a6e <_get_valve_voltage>
    9b58:	aeda 02bc 	cmp	A, #700
    9b5c:	1a0a      	jule	0x9b72 <.L10>

00009b5e <.LM36>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 1u); /* clear MEM flag */
    9b5e:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9b62:	8420      	or	AL, #32
    9b64:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009b68 <.LM37>:
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 0u); /* re-enable hardware protection */
    9b68:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9b6c:	94df      	and	AL, #-33
    9b6e:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009b72 <.L10>:
        }
        //		g_e8ErrorVoltage = C_ERR_VOLTAGE_IN_RANGE;
    }
}
    9b72:	5401      	ret

00009b74 <_protection_CheckChipTemperature>:
 *
 * @param[in]  a_i16ChipTemperature  chip internal temperature sensor [C]
 */
void protection_CheckChipTemperature(void)
{
    if (diagnostic_IsOVTPending())
    9b74:	82db 4413 	callf	0x8826 <_diagnostic_IsOVTPending>
    9b78:	ac00      	cmp	A, #0
    9b7a:	1904      	je	0x9b84 <.L21>

00009b7c <.LM41>:
    {

        g_e8ErrorOverTemperature = C_ERR_TEMP_ALARM;
    9b7c:	7002      	lod	A, #2
    9b7e:	52d8 11d6 	mov	0x11d6 <_g_e8ErrorOverTemperature>, A
    9b82:	5401      	ret

00009b84 <.L21>:
        //            swtimer_stop(SWTIMER_PROTECTION_DELAY_OVT);
    }
    else
    {
        if ((g_e8ErrorOverTemperature == C_ERR_TEMP_ALARM) && (get_valve_temperature() < (int16_t)(C_APPL_OTEMP + C_TEMP_CONV_OFFSET)))
    9b84:	72d8 11d6 	lod	A, 0x11d6 <_g_e8ErrorOverTemperature>
    9b88:	ac02      	cmp	A, #2
    9b8a:	1d0f      	jne	0x9baa <.L20>

00009b8c <.LM43>:
    9b8c:	82db 353a 	callf	0x6a74 <_get_valve_temperature>
    9b90:	aeda 009f 	cmp	A, #159
    9b94:	1f0a      	jsg	0x9baa <.L20>

00009b96 <.LM44>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u); /* clear MEM flag */
    9b96:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9b9a:	8402      	or	AL, #2
    9b9c:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009ba0 <.LM45>:
            IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u); /* re-enable hardware protection */
    9ba0:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9ba4:	94fd      	and	AL, #-3
    9ba6:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009baa <.L20>:
        }
        //	 g_e8ErrorOverTemperature = C_ERR_TEMP_NO;
        /* MISRA C-2012 Rule 15.7 */
    }
}
    9baa:	5401      	ret

00009bac <_protection_Task>:

void protection_Task(void)
{
    protection_CheckShort();
    9bac:	17a6      	call	0x9afa <_protection_CheckShort>

00009bae <.LM49>:

    protection_CheckSupplyMotorVoltage();
    9bae:	17ad      	call	0x9b0a <_protection_CheckSupplyMotorVoltage>

00009bb0 <.LM50>:
    protection_CheckChipTemperature();
    9bb0:	07e1      	jmp	0x9b74 <_protection_CheckChipTemperature>

00009bb2 <_pwm_Init>:
 *    |______|______|       |______|_
 *     <-LT->|<-LT->|        <-LT->|
 *
 */
void pwm_Init(void)
{
    9bb2:	5801      	inc	S, #2

00009bb4 <.LBB1030>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_DISABLE pwm1_master_disable

STATIC INLINE void pwm1_master_disable(void)
{
    IO_HOST(PWM_MASTER1, STOP) = 1u << IO_OFFSET(PWM_MASTER1, STOP);
    9bb4:	7802      	lod	Y, #2
    9bb6:	5ad8 013c 	mov	0x13c <.LASF2011+0x6>, Y

00009bba <.LBB1032>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_DISABLE pwm1_disable

STATIC INLINE void pwm1_disable(void)
{
    IO_HOST(PWM_SLAVE1, STOP) = 1u << IO_OFFSET(PWM_SLAVE1, STOP);
    9bba:	5ad8 0146 	mov	0x146 <.LASF899+0x7>, Y

00009bbe <.LBB1034>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_DISABLE pwm2_disable

STATIC INLINE void pwm2_disable(void)
{
    IO_HOST(PWM_SLAVE2, STOP) = 1u << IO_OFFSET(PWM_SLAVE2, STOP);
    9bbe:	0ea7      	lod	C, ML.7
    9bc0:	5ad8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, Y

00009bc4 <.LBB1036>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_DISABLE pwm3_disable

STATIC INLINE void pwm3_disable(void)
{
    IO_HOST(PWM_SLAVE3, STOP) = 1u << IO_OFFSET(PWM_SLAVE3, STOP);
    9bc4:	5ad8 015a 	mov	0x15a <.LASF2025+0x2>, Y

00009bc8 <.LBB1038>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_DISABLE pwm2_master_disable

STATIC INLINE void pwm2_master_disable(void)
{
    IO_HOST(PWM_MASTER2, STOP) = 1u << IO_OFFSET(PWM_MASTER2, STOP);
    9bc8:	5ad8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, Y

00009bcc <.LBB1040>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER1, PSCLM, ((DIV_)-1) & 0x0Fu,
    9bcc:	0ea7      	lod	C, ML.7
    9bce:	7008      	lod	A, #8
    9bd0:	52d8 013c 	mov	0x13c <.LASF2011+0x6>, A

00009bd4 <.LM8>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER1, PER, PERIOD_);
    9bd4:	7eda 0640 	lod	X, #1600
    9bd8:	0ea7      	lod	C, ML.7
    9bda:	5ed8 013a 	mov	0x13a <.LASF2011+0x4>, X

00009bde <.LM9>:
    IO_SET(PWM_MASTER1, CMP, CMP_);
    9bde:	72da 010b 	lod	A, #267
    9be2:	52d8 0134 	mov	0x134 <_PWM_MASTER1>, A

00009be6 <.LM10>:
    IO_SET(PWM_MASTER1, LT, LT_);
    9be6:	0ea7      	lod	C, ML.7
    9be8:	7000      	lod	A, #0
    9bea:	52d8 0138 	mov	0x138 <.LASF2011+0x2>, A

00009bee <.LM11>:
    IO_SET(PWM_MASTER1, HT, HT_);
    9bee:	52d8 0136 	mov	0x136 <.LASF2011>, A

00009bf2 <.LBB1042>:
#define PWM1_INIT pwm1_init

STATIC INLINE void pwm1_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE1, PSCLM, ((DIV_)-1) & 0x0Fu,
    9bf2:	0ea7      	lod	C, ML.7
    9bf4:	7c0c      	lod	X, #12
    9bf6:	5ed8 0146 	mov	0x146 <.LASF899+0x7>, X

00009bfa <.LM13>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE1, CMP, CMP_);
    9bfa:	7eda 0215 	lod	X, #533
    9bfe:	0ea7      	lod	C, ML.7
    9c00:	5ed8 013e 	mov	0x13e <_PWM_SLAVE1>, X

00009c04 <.LM14>:
    IO_SET(PWM_SLAVE1, LT, LT_);
    9c04:	52d8 0142 	mov	0x142 <.LASF899+0x3>, A

00009c08 <.LM15>:
    IO_SET(PWM_SLAVE1, HT, HT_);
    9c08:	52d8 0140 	mov	0x140 <.LASF899+0x1>, A

00009c0c <.LBB1044>:
#define PWM2_INIT pwm2_init

STATIC INLINE void pwm2_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE2, PSCLM, ((DIV_)-1) & 0x0Fu,
    9c0c:	0ea7      	lod	C, ML.7
    9c0e:	7c0c      	lod	X, #12
    9c10:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

00009c14 <.LM17>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE2, CMP, CMP_);
    9c14:	7eda 0320 	lod	X, #800
    9c18:	0ea7      	lod	C, ML.7
    9c1a:	5ed8 0148 	mov	0x148 <_PWM_SLAVE2>, X

00009c1e <.LM18>:
    IO_SET(PWM_SLAVE2, LT, LT_);
    9c1e:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009c22 <.LM19>:
    IO_SET(PWM_SLAVE2, HT, HT_);
    9c22:	52d8 014a 	mov	0x14a <_PWM_SLAVE2+0x2>, A

00009c26 <.LBB1046>:
#define PWM3_INIT pwm3_init

STATIC INLINE void pwm3_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE3, PSCLM, ((DIV_)-1) & 0x0Fu,
    9c26:	0ea7      	lod	C, ML.7
    9c28:	7c0c      	lod	X, #12
    9c2a:	5ed8 015a 	mov	0x15a <.LASF2025+0x2>, X

00009c2e <.LM21>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE3, CMP, CMP_);
    9c2e:	7eda 042a 	lod	X, #1066
    9c32:	0ea7      	lod	C, ML.7
    9c34:	5ed8 0152 	mov	0x152 <_PWM_SLAVE3>, X

00009c38 <.LM22>:
    IO_SET(PWM_SLAVE3, LT, LT_);
    9c38:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009c3c <.LM23>:
    IO_SET(PWM_SLAVE3, HT, HT_);
    9c3c:	52d8 0154 	mov	0x154 <_PWM_SLAVE3+0x2>, A

00009c40 <.LBB1048>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER2, PSCLM, ((DIV_)-1) & 0x0Fu,
    9c40:	0ea7      	lod	C, ML.7
    9c42:	7c08      	lod	X, #8
    9c44:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

00009c48 <.LM25>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER2, PER, PERIOD_);
    9c48:	7eda 0640 	lod	X, #1600
    9c4c:	0ea7      	lod	C, ML.7
    9c4e:	5ed8 0162 	mov	0x162 <_PWM_MASTER2+0x6>, X

00009c52 <.LM26>:
    IO_SET(PWM_MASTER2, CMP, CMP_);
    9c52:	7eda 0535 	lod	X, #1333
    9c56:	5ed8 015c 	mov	0x15c <_PWM_MASTER2>, X

00009c5a <.LM27>:
    IO_SET(PWM_MASTER2, LT, LT_);
    9c5a:	0ea7      	lod	C, ML.7
    9c5c:	52d8 0160 	mov	0x160 <_PWM_MASTER2+0x4>, A

00009c60 <.LM28>:
    IO_SET(PWM_MASTER2, HT, HT_);
    9c60:	52d8 015e 	mov	0x15e <_PWM_MASTER2+0x2>, A

00009c64 <.LBB1050>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_ENABLE pwm1_master_enable

STATIC INLINE void pwm1_master_enable(void)
{
    IO_HOST(PWM_MASTER1, START) = 1u << IO_OFFSET(PWM_MASTER1, START);
    9c64:	7c01      	lod	X, #1
    9c66:	0ea7      	lod	C, ML.7
    9c68:	5ed8 013c 	mov	0x13c <.LASF2011+0x6>, X

00009c6c <.LBB1052>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_ENABLE pwm1_enable

STATIC INLINE void pwm1_enable(void)
{
    IO_HOST(PWM_SLAVE1, START) = 1u << IO_OFFSET(PWM_SLAVE1, START);
    9c6c:	5ed8 0146 	mov	0x146 <.LASF899+0x7>, X

00009c70 <.LBB1054>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_ENABLE pwm2_enable

STATIC INLINE void pwm2_enable(void)
{
    IO_HOST(PWM_SLAVE2, START) = 1u << IO_OFFSET(PWM_SLAVE2, START);
    9c70:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

00009c74 <.LBB1056>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_ENABLE pwm3_enable

STATIC INLINE void pwm3_enable(void)
{
    IO_HOST(PWM_SLAVE3, START) = 1u << IO_OFFSET(PWM_SLAVE3, START);
    9c74:	0ea7      	lod	C, ML.7
    9c76:	5ed8 015a 	mov	0x15a <.LASF2025+0x2>, X

00009c7a <.LBB1058>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_ENABLE pwm2_master_enable

STATIC INLINE void pwm2_master_enable(void)
{
    IO_HOST(PWM_MASTER2, START) = 1u << IO_OFFSET(PWM_MASTER2, START);
    9c7a:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

00009c7e <.LBB1060>:
    9c7e:	7eda eeee 	lod	X, #61166
    9c82:	0ea7      	lod	C, ML.7
    9c84:	5ed8 0216 	mov	0x216 <_PORT_DRV_CTRL>, X

00009c88 <.LBE1060>:
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* enable digital part of the driver */
    // drvcfg_Enable(); in motor3ph_pwm_private.h
    IO_SET(PORT_DRV2_PROT, DIS_DRV, 0u);
    9c88:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

00009c8c <.LM36>:

    IO_SET(PORT_DRV_OUT, ENABLE_DRVSUP, 0x1u); /* enable driver supply */
    9c8c:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9c90:	8401      	or	AL, #1
    9c92:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009c96 <.LBB1062>:
    }
}

STATIC INLINE void DELAY(const uint16_t loops)
{
    delay_cycles(loops);
    9c96:	7050      	lod	A, #80
    9c98:	5a01      	mov	[S-2], Y
    9c9a:	82db 1128 	callf	0x2250 <_delay_cycles>

00009c9e <.LBE1062>:

    /* wait some time to have Vddaf to stabilize */
    DELAY_US(10u);

    /* enable the driver */
    IO_SET(PORT_DRV_OUT,
    9c9e:	72d8 020e 	lod	A, 0x20e <_PORT_DRV_OUT>
    9ca2:	b6da f001 	and	A, #61441
    9ca6:	a6da 09c2 	or	A, #2498
    9caa:	0ea7      	lod	C, ML.7
    9cac:	52d8 020e 	mov	0x20e <_PORT_DRV_OUT>, A

00009cb0 <.LBB1065>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9cb0:	7ee3      	lod	X, M

00009cb2 <.LBB1068>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    9cb2:	5049      	call	fp2:0x48

00009cb4 <.LBE1068>:
           DRVMOD_OPTION, 0x0u,
           PARALLEL_MODE_DRV, 0x1u); /* enable parallel mode U+V, W+T driver */

    /* configure pwm update sync interrupt - CNT ISR */
    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_SetPrio(PWM_MASTER1_END, 3u);
    9cb4:	62d8 008a 	lod	AL, 0x8a <__mlx4_flash_table_size+0x2>
    9cb8:	943f      	and	AL, #63
    9cba:	42d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, AL

00009cbe <.LBB1070>:

#define PWM1_MASTER_CNTI_ENABLE pwm1_master_cnti_enable

STATIC INLINE void pwm1_master_cnti_enable(void)
{
    Itc_Clear(PWM_MASTER1_END);
    9cbe:	6080      	lod	AL, #-128
    9cc0:	42d8 0053 	mov	0x53 <.LASF1528+0x6>, AL

00009cc4 <.LM43>:
    Itc_Enable(PWM_MASTER1_END);
    9cc4:	0ea7      	lod	C, ML.7
    9cc6:	62d8 006f 	lod	AL, 0x6f <__mlx4_cst_tables_ram_size+0x11>
    9cca:	8480      	or	AL, #-128
    9ccc:	42d8 006f 	mov	0x6f <__mlx4_cst_tables_ram_size+0x11>, AL

00009cd0 <.LBB1072>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_CMPI_ENABLE pwm2_cmpi_enable

STATIC INLINE void pwm2_cmpi_enable(void)
{
    Itc_Clear(PWM_SLAVE2_CMP);
    9cd0:	7a01      	lod	Y, [S-2]
    9cd2:	46d8 0054 	mov	0x54 <.Lframe0>, YL

00009cd6 <.LM45>:
    Itc_Enable(PWM_SLAVE2_CMP);
    9cd6:	62d8 0070 	lod	AL, 0x70 <__mlx4_cst_tables_ram_size+0x12>
    9cda:	8402      	or	AL, #2
    9cdc:	42d8 0070 	mov	0x70 <__mlx4_cst_tables_ram_size+0x12>, AL

00009ce0 <.LBB1074>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9ce0:	5ee3      	mov	M, X

00009ce2 <.LBE1065>:
    pwm1_master_cnti_enable();
    pwm2_cmpi_enable(); // pwm2
    EXIT_SECTION();

    u16DutyCycleMax = 0x4000;
}
    9ce2:	5403      	ret	#4

00009ce4 <_pwm_SetDutyCycle>:
 * @param[in]  u8Channels    The channel(s) to update the duty cycle for.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
extern uint16_t g_u16debug_2, g_u16debug_5;
void pwm_SetDutyCycle(uint8_t dir, uint16_t u16DutyCycle)
{
    9ce4:	5801      	inc	S, #2

00009ce6 <.LCFI1>:
    9ce6:	7e05      	lod	X, [S-6]
    9ce8:	7ada 0800 	lod	Y, #2048
    9cec:	2ee6      	cmp	X, Y
    9cee:	1a01      	jule	0x9cf2 <.L3>
    9cf0:	7ee6      	lod	X, Y

00009cf2 <.L3>:

    if (u16DutyCycle > C_PWMOUT_MAX_DUTY)
    {
        u16DutyCycle = C_PWMOUT_MAX_DUTY;
    }
    u16DutyCycle = (C_PWMOUT_MAX_DUTY - u16DutyCycle);
    9cf2:	eaee      	sub	Y, X

00009cf4 <.LM50>:
     * |     _____________     |
     * |____|             |____|
     */

    /* Change direction */
    switch (dir)
    9cf4:	ac01      	cmp	A, #1
    9cf6:	190f      	je	0x9d16 <.L5>
    9cf8:	ac02      	cmp	A, #2
    9cfa:	1912      	je	0x9d20 <.L6>

00009cfc <.L4>:
MATHLIB_INLINE_STATIC __inline__ uint16_t mulU16hi_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9cfc:	72e6      	lod	A, Y
    9cfe:	4822 63f0 	mulu	YA, A, #25584

00009d02 <.LBE1078>:
        break;
    } /* Change direction */

    u16LT = mulU16hi_U16byU16(u16DutyCycle, PWM_PERIOD << 4);

    u16LTcopy[0] = u16LT; /* U */
    9d02:	5ad8 11da 	mov	0x11da <_u16LTcopy>, Y

00009d06 <.LM53>:
    u16LTcopy[1] = u16LT; /* V */
    9d06:	5ad8 11dc 	mov	0x11dc <.Lframe0>, Y

00009d0a <.LM54>:
    u16LTcopy[2] = u16LT; /* W */
    9d0a:	5ad8 11de 	mov	0x11de <.Lframe0+0x2>, Y

00009d0e <.LM55>:
    u16LTcopy[3] = u16LT; /* T */
    9d0e:	0ea7      	lod	C, ML.7
    9d10:	5ad8 11e0 	mov	0x11e0 <.Lframe0+0x4>, Y

00009d14 <.LM56>:
}
    9d14:	5403      	ret	#4

00009d16 <.L5>:
    9d16:	72da dd00 	lod	A, #56576

00009d1a <.L7>:
    9d1a:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A
    9d1e:	07ee      	jmp	0x9cfc <.L4>

00009d20 <.L6>:
    9d20:	72da 33dd 	lod	A, #13277

00009d24 <.LVL21>:
    9d24:	07fa      	jmp	0x9d1a <.L7>

00009d26 <_pwm_Start>:
 * This function will start the pwm driver and will enable the
 * output of the pwm signals on the driver pins.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
void pwm_Start(uint8_t dir, uint16_t u16DutyCycle)
{
    9d26:	7e03      	lod	X, [S-4]

00009d28 <.LM60>:
			Itc_Enable(OVC);
			Itc_Clear(OVT);
			Itc_Enable(OVT);
			EXIT_SECTION();
#endif
        pwm_SetDutyCycle(dir, u16DutyCycle);
    9d28:	5edf      	push	X

00009d2a <.LCFI2>:
    9d2a:	17dc      	call	0x9ce4 <_pwm_SetDutyCycle>

00009d2c <.LM61>:
            MotorDriverUVWTSelectSource(DRV_CTRL_PWM_MASTER1,  /* U - Phase A */
            							DRV_CTRL_PWM_MASTER1,  /* V - Phase A */
										DRV_CTRL_PWM_SLAVE1,   /* W - Phase B */
										DRV_CTRL_PWM_SLAVE1);  /* T - Phase B */
#endif
        IO_SET(PORT_DRV_OUT, ENABLE_DRV, 0xFu); /* enable drivers of phases U,V,W,T */
    9d2c:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9d30:	843c      	or	AL, #60
    9d32:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009d36 <.LCFI3>:
    }
}
    9d36:	5403      	ret	#4

00009d38 <_pwm_Stop>:
    9d38:	72da dddd 	lod	A, #56797
    9d3c:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009d40 <.LBE1084>:
                                DRV_CTRL_LOW,  /* V */
                                DRV_CTRL_LOW,  /* W */
                                DRV_CTRL_LOW); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9d40:	7000      	lod	A, #0
    9d42:	0ea7      	lod	C, ML.7
    9d44:	52d8 0138 	mov	0x138 <.LASF2011+0x2>, A

00009d48 <.LM68>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9d48:	52d8 0142 	mov	0x142 <.LASF899+0x3>, A

00009d4c <.LM69>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9d4c:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009d50 <.LM70>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9d50:	0ea7      	lod	C, ML.7
    9d52:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009d56 <.LM71>:
}
    9d56:	5401      	ret

00009d58 <_pwm_Off>:
    9d58:	72da eeee 	lod	A, #61166
    9d5c:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009d60 <.LBE1086>:
                                DRV_CTRL_TRISTATE,  /* V */
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9d60:	7000      	lod	A, #0
    9d62:	0ea7      	lod	C, ML.7
    9d64:	52d8 0138 	mov	0x138 <.LASF2011+0x2>, A

00009d68 <.LM75>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9d68:	52d8 0142 	mov	0x142 <.LASF899+0x3>, A

00009d6c <.LM76>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9d6c:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009d70 <.LM77>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9d70:	0ea7      	lod	C, ML.7
    9d72:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009d76 <.LM78>:
}
    9d76:	5401      	ret

00009d78 <_pwm_Disable>:
    9d78:	72da eeee 	lod	A, #61166
    9d7c:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009d80 <.LBE1088>:
                                DRV_CTRL_TRISTATE,  /* V */
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9d80:	7000      	lod	A, #0
    9d82:	0ea7      	lod	C, ML.7
    9d84:	52d8 0138 	mov	0x138 <.LASF2011+0x2>, A

00009d88 <.LM82>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9d88:	52d8 0142 	mov	0x142 <.LASF899+0x3>, A

00009d8c <.LM83>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9d8c:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009d90 <.LM84>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9d90:	0ea7      	lod	C, ML.7
    9d92:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009d96 <.LM85>:

    IO_SET(PORT_DRV_OUT,
    9d96:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9d9a:	94c0      	and	AL, #-64
    9d9c:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009da0 <.LM86>:
           ENABLE_DRV, 0x0u,           /* disable drivers of all phases */
           ENABLE_DRVSUP, 0x0u,        /* disable driver supply */
           ENABLE_DRVMOD_CPCLK, 0x0u); /* disable driver clock */

    IO_SET(PORT_DRV2_PROT, DIS_DRV, 1u); /* disable digital part of the driver */
    9da0:	6001      	lod	AL, #1
    9da2:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

00009da6 <.LBB1090>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9da6:	7ee3      	lod	X, M

00009da8 <.LBB1093>:
    9da8:	5049      	call	fp2:0x48

00009daa <.LBE1093>:

    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_Disable(DIAG);
    9daa:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9dae:	94f7      	and	AL, #-9
    9db0:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009db4 <.LM90>:
    Itc_Disable(UV_VS);
    9db4:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    9db8:	947f      	and	AL, #127
    9dba:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

00009dbe <.LM91>:
    Itc_Disable(OV_VS);
    9dbe:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9dc2:	94fb      	and	AL, #-5
    9dc4:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009dc8 <.LBB1095>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9dc8:	5ee3      	mov	M, X

00009dca <.LBE1090>:
    EXIT_SECTION();
}
    9dca:	5401      	ret

00009dcc <__PWM_MASTER1_END_INT>:
 *
 * This function will handle the end of period interrupt to produce a
 * synchronized PWM LT update.
 */
INTERRUPT void _PWM_MASTER1_END_INT(void)
{
    9dcc:	52df      	push	A

00009dce <.LCFI4>:
    IO_SET(PWM_MASTER1, LT, u16LTcopy[0]); /* U */
    9dce:	72d8 11da 	lod	A, 0x11da <_u16LTcopy>
    9dd2:	52d8 0138 	mov	0x138 <.LASF2011+0x2>, A

00009dd6 <.LM96>:
    IO_SET(PWM_SLAVE1, LT, u16LTcopy[1]);  /* V */
    9dd6:	72d8 11dc 	lod	A, 0x11dc <.Lframe0>
    9dda:	0ea7      	lod	C, ML.7
    9ddc:	52d8 0142 	mov	0x142 <.LASF899+0x3>, A

00009de0 <.LM97>:
    IO_SET(PWM_SLAVE2, LT, u16LTcopy[2]);  /* W */
    9de0:	72d8 11de 	lod	A, 0x11de <.Lframe0+0x2>
    9de4:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009de8 <.LM98>:
    IO_SET(PWM_SLAVE3, LT, u16LTcopy[3]);  /* T */
    9de8:	0ea7      	lod	C, ML.7
    9dea:	72d8 11e0 	lod	A, 0x11e0 <.Lframe0+0x4>
    9dee:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009df2 <.LM99>:

    //    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    //    Itc_Disable(PWM_MASTER1_END);
    //    EXIT_SECTION();
}
    9df2:	72cf      	pop	A

00009df4 <.LCFI5>:
    9df4:	72cb      	pop	M
    9df6:	5401      	ret

00009df8 <__PWM_SLAVE2_CMP_INT>:

INTERRUPT void _PWM_SLAVE2_CMP_INT(void)
{
}
    9df8:	72cb      	pop	M
    9dfa:	5401      	ret

00009dfc <__DIAG_INT>:
 *
 * This function will handle the generic motor driver
 * interrupt.
 */
INTERRUPT void _DIAG_INT(void)
{
    9dfc:	5edf      	push	X

00009dfe <.LCFI6>:
    9dfe:	5adf      	push	Y

00009e00 <.LCFI7>:
    9e00:	52df      	push	A

00009e02 <.LCFI8>:
    9e02:	4c83      	push	D

00009e04 <.LCFI9>:
    /* remember the diagnostic error, all diagnostic errors need to be
     * cleared before the driver can be started again
     */
    u16LastDiagErr = IO_HOST(PORT_DIAG_IN, OVT_MEM);
    9e04:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

00009e08 <.LM104>:

    pwm_Stop();
    9e08:	1797      	call	0x9d38 <_pwm_Stop>

00009e0a <.LM105>:

    /* disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(DIAG);
    9e0a:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9e0e:	94f7      	and	AL, #-9
    9e10:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009e14 <.LM106>:
}
    9e14:	4cc3      	pop	D

00009e16 <.LCFI10>:
    9e16:	72cf      	pop	A

00009e18 <.LCFI11>:
    9e18:	7acf      	pop	Y

00009e1a <.LCFI12>:
    9e1a:	7ecf      	pop	X

00009e1c <.LCFI13>:
    9e1c:	72cb      	pop	M
    9e1e:	5401      	ret

00009e20 <_swtimer_init>:
 * Initialize Core Timer and start.
 */
void swtimer_init(void)
{
    /* Init clock error conversion */
    conv_clock_error_init();
    9e20:	82db 3e1b 	callf	0x7c36 <_conv_clock_error_init>

00009e24 <.LBB198>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    9e24:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9e26:	d43f      	and	AH, #63
    9e28:	c480      	or	AH, #-128
    9e2a:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009e2c <.LBB201>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    9e2c:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9e2e:	b6da c000 	and	A, #49152
    9e32:	8464      	or	AL, #100
    9e34:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009e36 <.LBB203>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9e36:	7ee3      	lod	X, M

00009e38 <.LBB206>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    9e38:	5048      	call	fp2:0x40

00009e3a <.LBE206>:
    STIMER_INIT(STIMER_1US_CLOCK, CT_PERIODIC_RATE);

    /* Enable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Clear(STIMER);
    9e3a:	6010      	lod	AL, #16
    9e3c:	42d8 0052 	mov	0x52 <.LASF1528+0x5>, AL

00009e40 <.LM8>:
    Itc_Enable(STIMER);
    9e40:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9e44:	8410      	or	AL, #16
    9e46:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009e4a <.LBB208>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9e4a:	5ee3      	mov	M, X

00009e4c <.LBE203>:

    EXIT_SECTION();
    #endif

    /* Clear all */
    (void)memset((void *)g_pTimer, 0, sizeof(g_pTimer) / sizeof(uint8_t));
    9e4c:	7eda 1436 	lod	X, #5174
    9e50:	7000      	lod	A, #0
    9e52:	54ee      	mov	Cx, #14
    9e54:	52de      	mov	[X++], A
    9e56:	1ffe      	djnz	Cx, 0x9e54 <.LBE203+0x8>

00009e58 <.LM11>:
}
    9e58:	5401      	ret

00009e5a <_swtimer_deinit>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    9e5a:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9e5c:	d43f      	and	AH, #63
    9e5e:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009e60 <.LBB214>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9e60:	7ee3      	lod	X, M

00009e62 <.LBB217>:
    9e62:	5048      	call	fp2:0x40

00009e64 <.LBE217>:
    STIMER_SET_MODE(STIMER_DISABLE_CLOCK);  /* switch off */

    /* Disable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Disable(STIMER);
    9e64:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9e68:	94ef      	and	AL, #-17
    9e6a:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009e6e <.LBB219>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9e6e:	5ee3      	mov	M, X

00009e70 <.LBE214>:
    EXIT_SECTION();
    #endif
}
    9e70:	5401      	ret

00009e72 <_swtimer_calibrate>:
void swtimer_calibrate(uint16_t u16ADC_Value)
{
    int16_t i16ClockCountCorrection = 0;

    /* Get clock count correction */
    i16ClockCountCorrection = conv_clock_error_speed(u16ADC_Value);
    9e72:	82db 3e2f 	callf	0x7c5e <_conv_clock_error_speed>

00009e76 <.LM21>:

    i16ClockCountCorrection = conv_clock_error_correct_period(CT_PERIODIC_RATE, i16ClockCountCorrection);
    9e76:	52df      	push	A

00009e78 <.LCFI0>:
    9e78:	7064      	lod	A, #100

00009e7a <.LVL13>:
    9e7a:	82db 3e45 	callf	0x7c8a <_conv_clock_error_correct_period>

00009e7e <.LBB223>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    9e7e:	7eb2      	lod	X, io:0x32 <_STIMER+0x2>
    9e80:	36da c000 	and	X, #49152
    9e84:	a6ee      	or	A, X

00009e86 <.LVL15>:
    9e86:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009e88 <.LBE223>:
    STIMER_SET_VALUE(i16ClockCountCorrection);
}
    9e88:	5403      	ret	#4

00009e8a <_swtimer_register>:
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    9e8a:	ac06      	cmp	A, #6
    9e8c:	1e12      	jug	0x9eb2 <.L7>

00009e8e <.LM26>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    9e8e:	7a03      	lod	Y, [S-4]

00009e90 <.LM27>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    9e90:	ec00      	cmp	Y, #0
    9e92:	1a8f      	jsl	0x9eb2 <.L7>

00009e94 <.LM28>:
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    9e94:	44a2      	asl	A, #2

00009e96 <.LVL17>:
    9e96:	7ee2      	lod	X, A
    9e98:	22da 1436 	add	X, #5174

00009e9c <.LM29>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    9e9c:	7205      	lod	A, [S-6]

00009e9e <.LM30>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    9e9e:	ac01      	cmp	A, #1
    9ea0:	5c82      	se	A

00009ea2 <.LM31>:
        g_pTimer[a_e8Id].u15Load = a_u15Load;
    9ea2:	f6da 7fff 	and	Y, #32767
    9ea6:	b401      	and	A, #1
    9ea8:	4452      	rr	A
    9eaa:	a6e6      	or	A, Y
    9eac:	52f8      	mov	[X], A

00009eae <.LM32>:
        bRetVal = true;
    9eae:	7001      	lod	A, #1
    9eb0:	5401      	ret

00009eb2 <.L7>:
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;
    9eb2:	7000      	lod	A, #0

00009eb4 <.LM34>:
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
        g_pTimer[a_e8Id].u15Load = a_u15Load;
        bRetVal = true;
    }
    return bRetVal;
}
    9eb4:	5401      	ret

00009eb6 <_swtimer_start>:
 * Start a software timer
 * @param[in]  a_e8Id  Timer id
 */
void swtimer_start(swtimer_id_t a_e8Id)
{
    g_pTimer[a_e8Id].u15Current = g_pTimer[a_e8Id].u15Load;
    9eb6:	44a2      	asl	A, #2

00009eb8 <.LVL22>:
    9eb8:	7ee2      	lod	X, A
    9eba:	22da 1436 	add	X, #5174
    9ebe:	7af8      	lod	Y, [X]
    9ec0:	f6da 7fff 	and	Y, #32767
    9ec4:	72fa      	lod	A, [X+2]
    9ec6:	b6da 8000 	and	A, #32768
    9eca:	a6e6      	or	A, Y
    9ecc:	52fa      	mov	[X+2], A

00009ece <.LM37>:
    g_pTimer[a_e8Id].bTriggered = 0u;
    9ece:	2003      	add	X, #3
    9ed0:	62f8      	lod	AL, [X]
    9ed2:	947f      	and	AL, #127
    9ed4:	42f8      	mov	[X], AL

00009ed6 <.LM38>:
}
    9ed6:	5401      	ret

00009ed8 <_swtimer_isTriggered>:
 * Check if a software timer has expired and clear it by timer id.
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    9ed8:	5801      	inc	S, #2

00009eda <.LCFI2>:
    bool lb_trigged = false;

    if (g_pTimer[a_e8Id].bTriggered != 0u)
    9eda:	44a2      	asl	A, #2

00009edc <.LVL31>:
    9edc:	5201      	mov	[S-2], A
    9ede:	7ee2      	lod	X, A
    9ee0:	22da 1439 	add	X, #5177
    9ee4:	66f8      	lod	YL, [X]
    9ee6:	62e8      	lod	AL, YL
    9ee8:	4440      	rl	AL
    9eea:	9401      	and	AL, #1
    9eec:	5cf2      	usex	A
    9eee:	7ee2      	lod	X, A
    9ef0:	62e8      	lod	AL, YL
    9ef2:	1d88      	jnn	0x9f04 <.L16>

00009ef4 <.LM52>:
    {
        g_pTimer[a_e8Id].bTriggered = 0u;
    9ef4:	7e01      	lod	X, [S-2]
    9ef6:	22da 1439 	add	X, #5177
    9efa:	62e8      	lod	AL, YL
    9efc:	947f      	and	AL, #127
    9efe:	42f8      	mov	[X], AL

00009f00 <.LM53>:
        lb_trigged = true;
    9f00:	7001      	lod	A, #1
    9f02:	5403      	ret	#4

00009f04 <.L16>:
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    bool lb_trigged = false;
    9f04:	72ee      	lod	A, X

00009f06 <.LM55>:
        g_pTimer[a_e8Id].bTriggered = 0u;
        lb_trigged = true;
    }

    return (lb_trigged);
}
    9f06:	5403      	ret	#4

00009f08 <_swtimer_enterIrq>:
/* ---------------------------------------------
 * Weak, default function implementation
 * --------------------------------------------- */

WEAK void swtimer_enterIrq(void)
{}
    9f08:	5401      	ret

00009f0a <_swtimer_exitIrq>:
    9f0a:	5401      	ret

00009f0c <_swtimer_triggerIrq>:
{}

WEAK void swtimer_triggerIrq(uint16_t id)
{
    (void)id;
}
    9f0c:	5401      	ret

00009f0e <__STIMER_INT>:

/**
 * The core timer interrupt service routine.
 */
INTERRUPT void _STIMER_INT(void)
{
    9f0e:	5edf      	push	X

00009f10 <.LCFI3>:
    9f10:	5adf      	push	Y

00009f12 <.LCFI4>:
    9f12:	52df      	push	A

00009f14 <.LCFI5>:
    9f14:	4c83      	push	D

00009f16 <.LCFI6>:
    9f16:	5807      	inc	S, #8

00009f18 <.LCFI7>:
    swtimer_enterIrq();
    9f18:	17f7      	call	0x9f08 <_swtimer_enterIrq>

00009f1a <.LBB225>:

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    9f1a:	7000      	lod	A, #0
    9f1c:	5205      	mov	[S-6], A

00009f1e <.L23>:
    {
        uint16_t value = g_pTimer[index].u15Current;
    9f1e:	7205      	lod	A, [S-6]
    9f20:	44a2      	asl	A, #2
    9f22:	5201      	mov	[S-2], A
    9f24:	7ee2      	lod	X, A
    9f26:	22da 1438 	add	X, #5176
    9f2a:	7ef8      	lod	X, [X]

00009f2c <.LM64>:

        if (value != 0u)
    9f2c:	72ee      	lod	A, X
    9f2e:	d47f      	and	AH, #127
    9f30:	ac00      	cmp	A, #0
    9f32:	1926      	je	0x9f80 <.L21>
    9f34:	72ee      	lod	A, X
    9f36:	b6da 7fff 	and	A, #32767

00009f3a <.LM65>:
        {
            value--;

            if (value == 0u)
    9f3a:	7ae2      	lod	Y, A
    9f3c:	e0ff      	add	Y, #-1

00009f3e <.LVL40>:
    9f3e:	5a07      	mov	[S-8], Y
    9f40:	ac01      	cmp	A, #1
    9f42:	1d12      	jne	0x9f68 <.L22>

00009f44 <.LM66>:
            {
                /* Trigger state */
                g_pTimer[index].bTriggered = 1u;
    9f44:	7a01      	lod	Y, [S-2]

00009f46 <.LVL41>:
    9f46:	e2da 1436 	add	Y, #5174
    9f4a:	7ee6      	lod	X, Y
    9f4c:	2003      	add	X, #3
    9f4e:	62f8      	lod	AL, [X]
    9f50:	8480      	or	AL, #-128
    9f52:	42f8      	mov	[X], AL

00009f54 <.LM67>:

                /* Callback event */
                swtimer_triggerIrq(index);
    9f54:	7205      	lod	A, [S-6]
    9f56:	5a03      	mov	[S-4], Y
    9f58:	17d9      	call	0x9f0c <_swtimer_triggerIrq>

00009f5a <.LM68>:

                if (g_pTimer[index].bRepetitive != 0u)
    9f5a:	7a03      	lod	Y, [S-4]
    9f5c:	62f1      	lod	AL, [Y+1]
    9f5e:	1d84      	jnn	0x9f68 <.L22>

00009f60 <.LM69>:
                {
                    /* Reload periodic timers */
                    value = g_pTimer[index].u15Load;
    9f60:	72f0      	lod	A, [Y]
    9f62:	b6da 7fff 	and	A, #32767
    9f66:	5207      	mov	[S-8], A

00009f68 <.L22>:
                }
            }

            g_pTimer[index].u15Current = value;
    9f68:	7205      	lod	A, [S-6]
    9f6a:	44a2      	asl	A, #2
    9f6c:	7ae2      	lod	Y, A
    9f6e:	e2da 1436 	add	Y, #5174
    9f72:	7207      	lod	A, [S-8]
    9f74:	d47f      	and	AH, #127
    9f76:	7ef2      	lod	X, [Y+2]
    9f78:	36da 8000 	and	X, #32768
    9f7c:	26e2      	or	X, A
    9f7e:	5ef2      	mov	[Y+2], X

00009f80 <.L21>:
INTERRUPT void _STIMER_INT(void)
{
    swtimer_enterIrq();

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    9f80:	7205      	lod	A, [S-6]
    9f82:	a001      	add	A, #1

00009f84 <.LVL46>:
    9f84:	5205      	mov	[S-6], A
    9f86:	ac07      	cmp	A, #7
    9f88:	1d4a      	jne	0x9f1e <.L23>

00009f8a <.LBE225>:

            g_pTimer[index].u15Current = value;
        }
    }

    swtimer_exitIrq();
    9f8a:	17bf      	call	0x9f0a <_swtimer_exitIrq>

00009f8c <.LM73>:
}
    9f8c:	5c07      	dec	S, #8

00009f8e <.LVL48>:
    9f8e:	4cc3      	pop	D

00009f90 <.LCFI8>:
    9f90:	72cf      	pop	A

00009f92 <.LCFI9>:
    9f92:	7acf      	pop	Y

00009f94 <.LCFI10>:
    9f94:	7ecf      	pop	X

00009f96 <.LCFI11>:
    9f96:	72cb      	pop	M
    9f98:	5401      	ret

00009f9a <__CTIMER0_3_INT>:
#include <ctimerlib.h>
#include "defines.h"

/** Timer1 INT3 handler for LIN AA frame timeout */
INTERRUPT void _CTIMER0_3_INT(void)
{
    9f9a:	5edf      	push	X

00009f9c <.LCFI0>:
    9f9c:	5adf      	push	Y

00009f9e <.LCFI1>:
    9f9e:	52df      	push	A

00009fa0 <.LCFI2>:
    9fa0:	4c83      	push	D

00009fa2 <.LCFI3>:
	system_timer_ISR();
    9fa2:	14b7      	call	0x9912 <_system_timer_ISR>

00009fa4 <.LM3>:
}
    9fa4:	4cc3      	pop	D

00009fa6 <.LCFI4>:
    9fa6:	72cf      	pop	A

00009fa8 <.LCFI5>:
    9fa8:	7acf      	pop	Y

00009faa <.LCFI6>:
    9faa:	7ecf      	pop	X

00009fac <.LCFI7>:
    9fac:	72cb      	pop	M
    9fae:	5401      	ret

00009fb0 <_ctimer0_init>:
#include <stdint.h>
#include "io.h"

STATIC INLINE void CTimer0_AutoloadInit(CTimer_Clockdivider_t divider, uint16_t cmpb)
{
    IO_SET(CTIMER0, TREGB, cmpb);
    9fb0:	52d8 0118 	mov	0x118 <_CTIMER0>, A

00009fb4 <.LM6>:
    IO_SET(CTIMER0, DIV, (uint16_t)divider, MODE, (uint16_t)eTimerModeTimer);
    9fb4:	62d8 011f 	lod	AL, 0x11f <_CTIMER0+0x7>

00009fb8 <.LVL2>:
    9fb8:	9407      	and	AL, #7
    9fba:	8440      	or	AL, #64
    9fbc:	42d8 011f 	mov	0x11f <_CTIMER0+0x7>, AL

00009fc0 <.LM7>:
    IO_SET(CTIMER0, START, 1u);
    9fc0:	62d8 011e 	lod	AL, 0x11e <_CTIMER0+0x6>
    9fc4:	94fc      	and	AL, #-4
    9fc6:	8401      	or	AL, #1
    9fc8:	42d8 011e 	mov	0x11e <_CTIMER0+0x6>, AL

00009fcc <.LBB149>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9fcc:	7ee3      	lod	X, M

00009fce <.LBB152>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    9fce:	5049      	call	fp2:0x48

00009fd0 <.LBB154>:
    IO_SET(MLX16, CTIMER0_2_ITC, 1u);
}

STATIC INLINE void CTimer0_Int3_Enable(void)
{
    IO_SET(MLX16, CTIMER0_3_PEND, 1u);
    9fd0:	6080      	lod	AL, #-128
    9fd2:	42d8 0052 	mov	0x52 <.LASF1528+0x5>, AL

00009fd6 <.LM11>:
    IO_SET(MLX16, CTIMER0_3_ITC, 1u);
    9fd6:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9fda:	8480      	or	AL, #-128
    9fdc:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009fe0 <.LBB156>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9fe0:	5ee3      	mov	M, X

00009fe2 <.LBE149>:
{
	CTimer0_AutoloadInit(eTimerCPUClockDivisionBy16, period);
	ENTER_SECTION(ATOMIC_SYSTEM_MODE);
	CTimer0_Int3_Enable();
	EXIT_SECTION();
}
    9fe2:	5401      	ret

00009fe4 <_ctimer0_start>:
#endif /* CTIMER1 */


STATIC INLINE void CTimer0_Start(void)
{
    IO_SET(CTIMER0, START, 1u);
    9fe4:	62d8 011e 	lod	AL, 0x11e <_CTIMER0+0x6>
    9fe8:	94fc      	and	AL, #-4
    9fea:	8401      	or	AL, #1
    9fec:	42d8 011e 	mov	0x11e <_CTIMER0+0x6>, AL

00009ff0 <.LBE160>:

void ctimer0_start(void)
{
	CTimer0_Start();
}
    9ff0:	5401      	ret

00009ff2 <_uart_Start>:



STATIC INLINE void UART_RxEnable(void)
{
    IO_SET(UART, REE, 1u);
    9ff2:	72d8 0256 	lod	A, 0x256 <_UART+0x8>
    9ff6:	8404      	or	AL, #4
    9ff8:	52d8 0256 	mov	0x256 <_UART+0x8>, A

00009ffc <.LBB677>:
/*********************** Function from lm_uart, Mulan2/3 ******************************************/


STATIC INLINE void UART_TxEnable(void)
{
    IO_SET(UART, TRE, 1u);
    9ffc:	72d8 0256 	lod	A, 0x256 <_UART+0x8>
    a000:	8402      	or	AL, #2
    a002:	52d8 0256 	mov	0x256 <_UART+0x8>, A

0000a006 <.LBE677>:
STATIC void uart_Start(void)
{
#ifndef HAS_TWO_UARTS
    UART_RxEnable();
    UART_TxEnable();
    IO_SET(PORT_UDMA_CTRL, UDMA_TXSTART, 1, UDMA_EN, 1);  /* Enable & Start UART DMA */
    a006:	62d8 024c 	lod	AL, 0x24c <_PORT_UDMA_CTRL>
    a00a:	8403      	or	AL, #3
    a00c:	42d8 024c 	mov	0x24c <_PORT_UDMA_CTRL>, AL

0000a010 <.LM5>:
#else
    UART0_RxEnable();
    UART0_TxEnable();
    IO_SET(PORT_UDMA0_CTRL, UDMA0_TXSTART, 1, UDMA0_EN, 1);  /* Enable & Start UART DMA */
#endif
}
    a010:	5401      	ret

0000a012 <_uart_Stop>:



STATIC INLINE void UART_RxDisable(void)
{
    IO_SET(UART, REE, 0u);
    a012:	72d8 0256 	lod	A, 0x256 <_UART+0x8>
    a016:	94fb      	and	AL, #-5
    a018:	52d8 0256 	mov	0x256 <_UART+0x8>, A

0000a01c <.LBB681>:



STATIC INLINE void UART_TxDisable(void)
{
    IO_SET(UART, TRE, 0u);
    a01c:	72d8 0256 	lod	A, 0x256 <_UART+0x8>
    a020:	94fd      	and	AL, #-3
    a022:	52d8 0256 	mov	0x256 <_UART+0x8>, A

0000a026 <.LBE681>:
    UART_TxDisable();
#else
    UART0_RxDisable();
    UART0_TxDisable();
#endif
}
    a026:	5401      	ret

0000a028 <__UDFR_INT>:
#ifndef HAS_TWO_UARTS
INTERRUPT void _UDFR_INT(void)
#else
INTERRUPT void _UDFR0_INT(void)
#endif
{
    a028:	5edf      	push	X

0000a02a <.LCFI4>:
    a02a:	5adf      	push	Y

0000a02c <.LCFI5>:
    a02c:	52df      	push	A

0000a02e <.LCFI6>:
    a02e:	4c83      	push	D

0000a030 <.LCFI7>:
    a030:	5807      	inc	S, #8

0000a032 <.LCFI8>:
    uint8_t * pu8UartRxBuf;

#ifndef HAS_TWO_UARTS
    if (IO_GET(PORT_UDMA_STATUS, UDMA_RD_BUFFER_VALID) == 0u)
    a032:	72d8 025a 	lod	A, 0x25a <_PORT_UDMA_STATUS>
    a036:	9401      	and	AL, #1
    a038:	1901      	je	0xa03c <.LM73>
    a03a:	0046      	jmp	0xa0c8 <.L13>

0000a03c <.LM73>:
#else
    if (IO_GET(PORT_UDMA0_STATUS, UDMA0_RD_BUFFER_VALID) == 0u)
#endif
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufB;
    a03c:	7eda 11ea 	lod	X, #4586

0000a040 <.L23>:
    }
    else
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufA;
    a040:	62f8      	lod	AL, [X]

0000a042 <.LM75>:
    }

    if ((pu8UartRxBuf[0] == C_SERIAL_PLOT_HEADER_BYTE0))
    a042:	8caa      	cmp	AL, #-86
    a044:	1901      	je	0xa048 <.LM75+0x6>
    a046:	0046      	jmp	0xa0d4 <.L15>
    a048:	7aee      	lod	Y, X
    a04a:	e001      	add	Y, #1
    a04c:	2009      	add	X, #9
    a04e:	5e07      	mov	[S-8], X
    a050:	5a05      	mov	[S-6], Y

0000a052 <.LBB1061>:
    {
        uint8_t checksum = 0u;
    a052:	7000      	lod	A, #0
    a054:	5203      	mov	[S-4], A
    a056:	7c08      	lod	X, #8
    a058:	5e01      	mov	[S-2], X

0000a05a <.L16>:
        for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH; index++)
        {
            checksum += pu8UartRxBuf[1u + index];
    a05a:	7e05      	lod	X, [S-6]
    a05c:	62de      	lod	AL, [X++]
    a05e:	5e05      	mov	[S-6], X
    a060:	8203      	add	AL, [S-4]
    a062:	5cf2      	usex	A
    a064:	5203      	mov	[S-4], A

0000a066 <.LM78>:
    }

    if ((pu8UartRxBuf[0] == C_SERIAL_PLOT_HEADER_BYTE0))
    {
        uint8_t checksum = 0u;
        for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH; index++)
    a066:	7201      	lod	A, [S-2]
    a068:	a0ff      	add	A, #-1
    a06a:	5201      	mov	[S-2], A
    a06c:	1d76      	jne	0xa05a <.L16>

0000a06e <.LBE1062>:
        {
            checksum += pu8UartRxBuf[1u + index];
        }

        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
    a06e:	7e07      	lod	X, [S-8]
    a070:	62f8      	lod	AL, [X]
    a072:	5cf2      	usex	A
    a074:	ae03      	cmp	A, [S-4]
    a076:	1d21      	jne	0xa0ba <.L12>
    a078:	7001      	lod	A, #1
    a07a:	5205      	mov	[S-6], A
    a07c:	7c04      	lod	X, #4
    a07e:	5e03      	mov	[S-4], X

0000a080 <.L20>:
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
            {
                uint16_t addr = (pu8UartRxBuf[1u + (index * 2u) + 1u] << 8) | pu8UartRxBuf[1u + (index * 2u)];
    a080:	6af1      	lod	AH, [Y+1]
    a082:	62f0      	lod	AL, [Y]
    a084:	5207      	mov	[S-8], A

0000a086 <.LVL33>:
    a086:	7205      	lod	A, [S-6]

0000a088 <.LVL34>:
    a088:	4422      	asl	A
    a08a:	7ee2      	lod	X, A

0000a08c <.LM81>:
                if (addr != 0)
    a08c:	7207      	lod	A, [S-8]

0000a08e <.LM82>:
                {
                    l_u16Payload[index] = addr;
    a08e:	22da 11e0 	add	X, #4576

0000a092 <.LM83>:
        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
            {
                uint16_t addr = (pu8UartRxBuf[1u + (index * 2u) + 1u] << 8) | pu8UartRxBuf[1u + (index * 2u)];
                if (addr != 0)
    a092:	ac00      	cmp	A, #0
    a094:	191c      	je	0xa0ce <.L18>

0000a096 <.L24>:
                {
                    l_u16Payload[index] = addr;
                }
                else
                {
                    l_u16Payload[index] = (uint16_t)&l_uart_plot_dummy;
    a096:	52f8      	mov	[X], A

0000a098 <.LVL35>:
    a098:	7205      	lod	A, [S-6]
    a09a:	a001      	add	A, #1
    a09c:	5205      	mov	[S-6], A

0000a09e <.LVL36>:
    a09e:	e002      	add	Y, #2

0000a0a0 <.LBE1064>:
            checksum += pu8UartRxBuf[1u + index];
        }

        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
    a0a0:	7e03      	lod	X, [S-4]
    a0a2:	20ff      	add	X, #-1
    a0a4:	5e03      	mov	[S-4], X
    a0a6:	1d6c      	jne	0xa080 <.L20>

0000a0a8 <.LBE1063>:
            }

            l_bCommandReady = true;
            if (l_bCommandReady)
            {
                memcpy(g_u16TxAddress, l_u16Payload, C_UART_PLOT_DATA_LENGTH);
    a0a8:	7eda 1012 	lod	X, #4114
    a0ac:	7ada 11e2 	lod	Y, #4578
    a0b0:	0ea7      	lod	C, ML.7
    a0b2:	54c6      	movsw	[X++], [Y++]
    a0b4:	54c6      	movsw	[X++], [Y++]
    a0b6:	54c6      	movsw	[X++], [Y++]
    a0b8:	54c6      	movsw	[X++], [Y++]

0000a0ba <.L12>:
    {
        /* we lost synchronization, repair */
        uart_Stop();
        uart_Start();
    }
}
    a0ba:	5c07      	dec	S, #8
    a0bc:	4cc3      	pop	D

0000a0be <.LCFI9>:
    a0be:	72cf      	pop	A

0000a0c0 <.LCFI10>:
    a0c0:	7acf      	pop	Y

0000a0c2 <.LCFI11>:
    a0c2:	7ecf      	pop	X

0000a0c4 <.LCFI12>:
    a0c4:	72cb      	pop	M
    a0c6:	5401      	ret

0000a0c8 <.L13>:
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufB;
    }
    else
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufA;
    a0c8:	7eda 11f4 	lod	X, #4596
    a0cc:	07b9      	jmp	0xa040 <.L23>

0000a0ce <.L18>:
                {
                    l_u16Payload[index] = addr;
                }
                else
                {
                    l_u16Payload[index] = (uint16_t)&l_uart_plot_dummy;
    a0ce:	72da 10a8 	lod	A, #4264

0000a0d2 <.LVL40>:
    a0d2:	07e1      	jmp	0xa096 <.L24>

0000a0d4 <.L15>:
        }
    }
    else
    {
        /* we lost synchronization, repair */
        uart_Stop();
    a0d4:	179e      	call	0xa012 <_uart_Stop>

0000a0d6 <.LM91>:
        uart_Start();
    a0d6:	178d      	call	0x9ff2 <_uart_Start>

0000a0d8 <.LM92>:
    }
}
    a0d8:	07f0      	jmp	0xa0ba <.L12>

0000a0da <__updateCRC8>:
/**
 * @brief Calculate and update CRC8 on one page
 * @param[in]  config  page data
 */
static void _updateCRC8(page_t * config)
{
    a0da:	5801      	inc	S, #2

0000a0dc <.LCFI0>:
    a0dc:	7ae2      	lod	Y, A

0000a0de <.LM2>:
    uint16_t u16CRC;

    config->crc8 = (uint16_t)0x00;
    a0de:	6000      	lod	AL, #0

0000a0e0 <.LVL1>:
    a0e0:	42f0      	mov	[Y], AL

0000a0e2 <.LM3>:

    u16CRC = nvram_CalcCRC((void *)config, sizeof(page_t) / sizeof(uint16_t));
    a0e2:	54ca 0004 	pushw	#4

0000a0e6 <.LCFI1>:
    a0e6:	72e6      	lod	A, Y
    a0e8:	5a03      	mov	[S-4], Y
    a0ea:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>

0000a0ee <.LM4>:

    config->crc8 = (uint16_t)(0xFFU - u16CRC);
    a0ee:	bcff      	xor	A, #-1

0000a0f0 <.LVL3>:
    a0f0:	7a03      	lod	Y, [S-4]
    a0f2:	42f0      	mov	[Y], AL

0000a0f4 <.LCFI2>:
}
    a0f4:	5405      	ret	#6

0000a0f6 <_unirom_Init>:
/* ---------------------------------------------
 * Public Functions Implementation
 * --------------------------------------------- */

void unirom_Init(void)
{}
    a0f6:	5401      	ret

0000a0f8 <_unirom_LoadUserConfig>:

bool unirom_LoadUserConfig(void)
{
    a0f8:	5809      	inc	S, #10

0000a0fa <.LCFI3>:
    a0fa:	7ada 0840 	lod	Y, #2112
    a0fe:	5a03      	mov	[S-4], Y

0000a100 <.LM10>:
    bool retVal = true;
    a100:	7001      	lod	A, #1
    a102:	5207      	mov	[S-8], A

0000a104 <.L6>:
}

#ifndef UNITTEST
STATIC INLINE void EEPROM_ClearErrorFlags(void)
{
    IO_SET(EEPROM_FLASH,
    a104:	600f      	lod	AL, #15
    a106:	42d8 0188 	mov	0x188 <.LASF1965+0x5>, AL

0000a10a <.LVL6>:
    a10a:	7a03      	lod	Y, [S-4]
    a10c:	e2da 09be 	add	Y, #2494
    a110:	5a01      	mov	[S-2], Y

0000a112 <.LBE92>:
        EEPROM_ClearErrorFlags();

        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* copy one page from EEPROM to RAM */
        memcpy((void*)&l_ramCopy.page[page], (void*)eeprom_address, sizeof(page_t) / sizeof(uint8_t));
    a112:	5a09      	mov	[S-10], Y
    a114:	7203      	lod	A, [S-4]
    a116:	7ee6      	lod	X, Y
    a118:	7ae2      	lod	Y, A
    a11a:	54e8      	mov	Cx, #8
    a11c:	54c4      	movsb	[X++], [Y++]
    a11e:	1ffe      	djnz	Cx, 0xa11c <.LASF109+0x3>

0000a120 <.LBB94>:
}
#endif /* UNITTEST */

STATIC INLINE bool EEPROM_GetErrorFlags(void)
{
    return (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_1) != 0u) || (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_2) != 0u);
    a120:	72d8 0188 	lod	A, 0x188 <.LASF1965+0x5>
    a124:	9402      	and	AL, #2
    a126:	1d0d      	jne	0xa142 <.L4>
    a128:	72d8 0188 	lod	A, 0x188 <.LASF1965+0x5>

0000a12c <.LBE94>:

        if (EEPROM_GetErrorFlags())
    a12c:	9408      	and	AL, #8
    a12e:	1d09      	jne	0xa142 <.L4>

0000a130 <.LM15>:
        {
            retVal = false;  /* ECC error */
        }
        else
        {
            if (nvram_CalcCRC((void *)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) != 0xFF)
    a130:	54ca 0004 	pushw	#4

0000a134 <.LCFI4>:
    a134:	7203      	lod	A, [S-4]
    a136:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    a13a:	5c01      	dec	S, #2

0000a13c <.LCFI5>:
    a13c:	aeda 00ff 	cmp	A, #255
    a140:	1902      	je	0xa146 <.L5>

0000a142 <.L4>:
            {
                retVal = false;  /* CRC error */
    a142:	7000      	lod	A, #0
    a144:	5207      	mov	[S-8], A

0000a146 <.L5>:

bool unirom_LoadUserConfig(void)
{
    bool retVal = true;

    for (uint8_t page = 0; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    a146:	7a03      	lod	Y, [S-4]
    a148:	e008      	add	Y, #8
    a14a:	5a03      	mov	[S-4], Y
    a14c:	eeda 0858 	cmp	Y, #2136
    a150:	1d59      	jne	0xa104 <.L6>

0000a152 <.LBE90>:
            }
        }
    }

    return retVal;
}
    a152:	7207      	lod	A, [S-8]
    a154:	540b      	ret	#12

0000a156 <_unirom_StoreUserConfig>:
    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
}

bool unirom_StoreUserConfig(void)
{
    a156:	5809      	inc	S, #10

0000a158 <.LCFI6>:
    a158:	7ada 0840 	lod	Y, #2112
    a15c:	5a01      	mov	[S-2], Y

0000a15e <.L15>:
    a15e:	7a01      	lod	Y, [S-2]
    a160:	e2da 09be 	add	Y, #2494
    a164:	5a03      	mov	[S-4], Y

0000a166 <.LBB131>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    a166:	5a07      	mov	[S-8], Y
    a168:	7e01      	lod	X, [S-2]
    a16a:	5e09      	mov	[S-10], X
    a16c:	7ee6      	lod	X, Y
    a16e:	7a09      	lod	Y, [S-10]

0000a170 <.LVL15>:
    a170:	7000      	lod	A, #0
    a172:	54e8      	mov	Cx, #8
    a174:	6ade      	lod	AH, [X++]
    a176:	cad6      	sub	AH, [Y++]
    a178:	1d02      	jne	0xa17e <.L18>
    a17a:	1ffc      	djnz	Cx, 0xa174 <.LVL15+0x4>
    a17c:	0001      	jmp	0xa180 <.L19>

0000a17e <.L18>:
    a17e:	4412      	rrc	A

0000a180 <.L19>:
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* Check if EEPROM and RAM copy are not the same */
        if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    a180:	ac00      	cmp	A, #0
    a182:	190f      	je	0xa1a2 <.L13>

0000a184 <.LBB135>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    a184:	7ae3      	lod	Y, M

0000a186 <.LBB138>:
    a186:	5049      	call	fp2:0x48

0000a188 <.LBE138>:
        {
            /* write to eeprom page */
            ENTER_SECTION(ATOMIC_SYSTEM_MODE);
            EEPROM_WriteWord64_blocking(eeprom_address, (void *)&l_ramCopy.page[page], EE_WRITE_KEY);
    a188:	54ca 0007 	pushw	#7

0000a18c <.LCFI7>:
    a18c:	7e05      	lod	X, [S-6]
    a18e:	5edf      	push	X

0000a190 <.LCFI8>:
    a190:	7205      	lod	A, [S-6]
    a192:	5a09      	mov	[S-10], Y
    a194:	111e      	call	0xa3d2 <_EEPROM_WriteWord64_blocking>

0000a196 <.LBB140>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    a196:	7a09      	lod	Y, [S-10]
    a198:	5ae3      	mov	M, Y

0000a19a <.LBB144>:
    a19a:	0f7f      	lod	C, io:0x0f.7

0000a19c <.LBE146>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    a19c:	5c03      	dec	S, #4

0000a19e <.LCFI9>:
    a19e:	1c01      	jnc	0xa1a2 <.L13>

0000a1a0 <.LM29>:
        IO_SET(AWD, ACK, 1u);
    a1a0:	0b76      	setb	io:0x0e.6

0000a1a2 <.L13>:
    return unirom_StoreUserConfig();
}

bool unirom_StoreUserConfig(void)
{
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    a1a2:	7a01      	lod	Y, [S-2]
    a1a4:	e008      	add	Y, #8
    a1a6:	5a01      	mov	[S-2], Y
    a1a8:	eeda 0858 	cmp	Y, #2136
    a1ac:	1d58      	jne	0xa15e <.L15>

0000a1ae <.LBE131>:
            WDG_conditionalAwdRefresh();  /* Restart watchdog */
        }
    }

    return true;
}
    a1ae:	7001      	lod	A, #1
    a1b0:	540b      	ret	#12

0000a1b2 <_unirom_ResetUserConfig>:

    return retVal;
}

bool unirom_ResetUserConfig(const user_pattern_t * def_config)
{
    a1b2:	5801      	inc	S, #2

0000a1b4 <.LCFI10>:
    /* restore ram copy  */
    memcpy((void*)&l_ramCopy, (void*)def_config, sizeof(user_pattern_t) / sizeof(uint8_t));
    a1b4:	7ada 11fe 	lod	Y, #4606
    a1b8:	5a01      	mov	[S-2], Y
    a1ba:	7ee2      	lod	X, A
    a1bc:	a018      	add	A, #24

0000a1be <.LVL25>:
    a1be:	0ea7      	lod	C, ML.7

0000a1c0 <.L21>:
    a1c0:	54cc      	movsb	[Y++], [X++]
    a1c2:	2ee2      	cmp	X, A
    a1c4:	1d7d      	jne	0xa1c0 <.L21>

0000a1c6 <.LBB148>:

    /* restore CRC8 of all pages */
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        _updateCRC8(&l_ramCopy.page[page]);
    a1c6:	72da 11fe 	lod	A, #4606
    a1ca:	1787      	call	0xa0da <__updateCRC8>
    a1cc:	72da 1206 	lod	A, #4614
    a1d0:	1784      	call	0xa0da <__updateCRC8>
    a1d2:	72da 120e 	lod	A, #4622
    a1d6:	1781      	call	0xa0da <__updateCRC8>

0000a1d8 <.LBE148>:
    }

    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
    a1d8:	17be      	call	0xa156 <_unirom_StoreUserConfig>

0000a1da <.LM36>:
}
    a1da:	5403      	ret	#4

0000a1dc <_unirom_StorePage>:

    return true;
}

bool unirom_StorePage(uint8_t page)
{
    a1dc:	5807      	inc	S, #8

0000a1de <.LCFI11>:
    uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));
    a1de:	a2da 0108 	add	A, #264

0000a1e2 <.LVL32>:
    a1e2:	44a2      	asl	A, #2
    a1e4:	4422      	asl	A
    a1e6:	5205      	mov	[S-6], A

0000a1e8 <.LM39>:

    /* Check if EEPROM and RAM copy are not the same */
    if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    a1e8:	a2da 09be 	add	A, #2494

0000a1ec <.LVL34>:
    a1ec:	5201      	mov	[S-2], A

0000a1ee <.LBB160>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    a1ee:	5207      	mov	[S-8], A
    a1f0:	7a05      	lod	Y, [S-6]
    a1f2:	7ee2      	lod	X, A
    a1f4:	7000      	lod	A, #0
    a1f6:	54e8      	mov	Cx, #8
    a1f8:	6ade      	lod	AH, [X++]
    a1fa:	cad6      	sub	AH, [Y++]
    a1fc:	1d02      	jne	0xa202 <.L28>
    a1fe:	1ffc      	djnz	Cx, 0xa1f8 <.LBB160+0xa>
    a200:	0001      	jmp	0xa204 <.L29>

0000a202 <.L28>:
    a202:	4412      	rrc	A

0000a204 <.L29>:
bool unirom_StorePage(uint8_t page)
{
    uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

    /* Check if EEPROM and RAM copy are not the same */
    if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    a204:	ac00      	cmp	A, #0
    a206:	190c      	je	0xa220 <.L23>

0000a208 <.LBB162>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    a208:	7ae3      	lod	Y, M

0000a20a <.LBB165>:
    a20a:	5049      	call	fp2:0x48

0000a20c <.LBE165>:
    {
        /* write to eeprom page */
        ENTER_SECTION(ATOMIC_SYSTEM_MODE);
        EEPROM_WriteWord64_blocking(eeprom_address, (void*)&l_ramCopy.page[page], EE_WRITE_KEY);
    a20c:	54ca 0007 	pushw	#7

0000a210 <.LCFI12>:
    a210:	7e03      	lod	X, [S-4]
    a212:	5edf      	push	X

0000a214 <.LCFI13>:
    a214:	7209      	lod	A, [S-10]
    a216:	5a07      	mov	[S-8], Y
    a218:	10dc      	call	0xa3d2 <_EEPROM_WriteWord64_blocking>

0000a21a <.LBB167>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    a21a:	7a07      	lod	Y, [S-8]
    a21c:	5ae3      	mov	M, Y

0000a21e <.LVL39>:
    a21e:	5c03      	dec	S, #4

0000a220 <.L23>:
        EXIT_SECTION();
    }

    return true;
}
    a220:	7001      	lod	A, #1
    a222:	5409      	ret	#10

0000a224 <_unirom_WritePage>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    a224:	5809      	inc	S, #10

0000a226 <.LCFI19>:
    a226:	660f      	lod	YL, [S-16]
    a228:	5cf6      	usex	Y
    a22a:	5a01      	mov	[S-2], Y

0000a22c <.LM63>:
    bool retVal = false;

    if (len <= 7u)
    a22c:	ec07      	cmp	Y, #7
    a22e:	1a01      	jule	0xa232 <.LASF1408+0x3>
    a230:	0031      	jmp	0xa294 <.L42>
    a232:	44a2      	asl	A, #2
    a234:	4422      	asl	A

0000a236 <.LVL55>:
    a236:	5209      	mov	[S-10], A

0000a238 <.LM64>:
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    a238:	a2da 11ff 	add	A, #4607
    a23c:	5205      	mov	[S-6], A
    a23e:	5207      	mov	[S-8], A

0000a240 <.LM65>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    a240:	7e0d      	lod	X, [S-14]

0000a242 <.LM66>:
    bool retVal = false;

    if (len <= 7u)
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    a242:	ec00      	cmp	Y, #0
    a244:	1927      	je	0xa294 <.L42>
    a246:	7ae2      	lod	Y, A
    a248:	7201      	lod	A, [S-2]

0000a24a <.L54>:
    a24a:	52df      	push	A
    a24c:	6ad6      	lod	AH, [Y++]
    a24e:	cade      	sub	AH, [X++]
    a250:	1d04      	jne	0xa25a <.L55>
    a252:	72cf      	pop	A
    a254:	a801      	sub	A, #1
    a256:	1d79      	jne	0xa24a <.L54>
    a258:	0002      	jmp	0xa25e <.L56>

0000a25a <.L55>:
    a25a:	5c01      	dec	S, #2
    a25c:	4412      	rrc	A

0000a25e <.L56>:
    a25e:	ac00      	cmp	A, #0
    a260:	1919      	je	0xa294 <.L42>

0000a262 <.LM67>:
        {
            memcpy((void*)&l_ramCopy.page[page].payload[0], (void *)data, len);  /* write the data to the ram copy */
    a262:	7e0d      	lod	X, [S-14]
    a264:	72ee      	lod	A, X
    a266:	a201      	add	A, [S-2]
    a268:	7a05      	lod	Y, [S-6]
    a26a:	0ea7      	lod	C, ML.7

0000a26c <.L57>:
    a26c:	54cc      	movsb	[Y++], [X++]
    a26e:	2ee2      	cmp	X, A
    a270:	1d7d      	jne	0xa26c <.L57>

0000a272 <.LM68>:
            memset((void*)&l_ramCopy.page[page].payload[len], 0, 7u - len);  /* clear non-used data with 0 */
    a272:	7c07      	lod	X, #7
    a274:	2a01      	sub	X, [S-2]
    a276:	7a01      	lod	Y, [S-2]
    a278:	e209      	add	Y, [S-10]
    a27a:	e2da 11ff 	add	Y, #4607
    a27e:	2c00      	cmp	X, #0
    a280:	1903      	je	0xa288 <.L40>
    a282:	6000      	lod	AL, #0
    a284:	42d6      	mov	[Y++], AL

0000a286 <L0>:
    a286:	1bfe      	djnz	X, 0xa284 <.LASF1447+0x1>

0000a288 <.L40>:

            _updateCRC8(&l_ramCopy.page[page]);  /* update CRC8 of that page */
    a288:	7209      	lod	A, [S-10]
    a28a:	a2da 11fe 	add	A, #4606
    a28e:	1725      	call	0xa0da <__updateCRC8>

0000a290 <.LM70>:

            retVal = true;
    a290:	7001      	lod	A, #1
    a292:	540b      	ret	#12

0000a294 <.L42>:
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    a294:	7000      	lod	A, #0

0000a296 <.LM72>:
            retVal = true;
        }
    }

    return retVal;
}
    a296:	540b      	ret	#12

0000a298 <_unirom_ReadPage>:

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    a298:	5805      	inc	S, #6

0000a29a <.LCFI20>:
    a29a:	660b      	lod	YL, [S-12]
    a29c:	5cf6      	usex	Y

0000a29e <.LM74>:
    bool retVal = false;

    if (len <= 7u)
    a29e:	ec07      	cmp	Y, #7
    a2a0:	1a02      	jule	0xa2a6 <.L59>

0000a2a2 <.L61>:
    return retVal;
}

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    a2a2:	7000      	lod	A, #0
    a2a4:	5407      	ret	#8

0000a2a6 <.L59>:
    a2a6:	44a2      	asl	A, #2
    a2a8:	4422      	asl	A

0000a2aa <.LVL63>:
    a2aa:	5205      	mov	[S-6], A

0000a2ac <.LM76>:

    if (len <= 7u)
    {
        if (nvram_CalcCRC((void*)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) == 0xFF)  /* check crc of the page */
    a2ac:	a2da 11fe 	add	A, #4606
    a2b0:	54ca 0004 	pushw	#4

0000a2b4 <.LCFI21>:
    a2b4:	5a05      	mov	[S-6], Y
    a2b6:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    a2ba:	5c01      	dec	S, #2

0000a2bc <.LCFI22>:
    a2bc:	7a03      	lod	Y, [S-4]
    a2be:	aeda 00ff 	cmp	A, #255
    a2c2:	1d6f      	jne	0xa2a2 <.L61>

0000a2c4 <.LM77>:
        {
            memcpy((void*)data, (void *)l_ramCopy.page[page].payload, len);  /* read from ram copy */
    a2c4:	7205      	lod	A, [S-6]
    a2c6:	a2da 11ff 	add	A, #4607
    a2ca:	ec00      	cmp	Y, #0
    a2cc:	190a      	je	0xa2e2 <.L62>
    a2ce:	7e09      	lod	X, [S-10]
    a2d0:	5e05      	mov	[S-6], X
    a2d2:	7ee2      	lod	X, A
    a2d4:	e2e2      	add	Y, A
    a2d6:	72e6      	lod	A, Y
    a2d8:	7a05      	lod	Y, [S-6]
    a2da:	0ea7      	lod	C, ML.7

0000a2dc <.L66>:
    a2dc:	54cc      	movsb	[Y++], [X++]
    a2de:	2ee2      	cmp	X, A
    a2e0:	1d7d      	jne	0xa2dc <.L66>

0000a2e2 <.L62>:

            retVal = true;
    a2e2:	7001      	lod	A, #1

0000a2e4 <.LM79>:
        }
    }
    return retVal;
}
    a2e4:	5407      	ret	#8

0000a2e6 <_CalculateTemperature3pLinearize>:
    a2e6:	7ed8 09b0 	lod	X, 0x9b0 <.LASF1595+0x1>
    a2ea:	54e4      	mov	Cx, #4
    a2ec:	44fe      	asr	X, #2
    a2ee:	1ffe      	djnz	Cx, 0xa2ec <_CalculateTemperature3pLinearize+0x6>

0000a2f0 <.LM3>:
    a2f0:	7ad8 09b4 	lod	Y, 0x9b4 <.LASF1595+0x5>
    a2f4:	eae2      	sub	Y, A
    a2f6:	72e6      	lod	A, Y

0000a2f8 <.LVL2>:
    a2f8:	7ad8 09b8 	lod	Y, 0x9b8 <.LASF1595+0x9>

0000a2fc <.LM4>:
    a2fc:	ac00      	cmp	A, #0
    a2fe:	1e93      	jsge	0xa326 <.L2>

0000a300 <.LBB6>:
    a300:	5cf6      	usex	Y

0000a302 <.L8>:
    a302:	4831      	muls	YA, A, Y

0000a304 <.LBE8>:
    a304:	4cb2 0000 	cmp	YA, #0
    a308:	0000 
    a30a:	1e84      	jsge	0xa314 <.L5>
    a30c:	4cc0      	mov	D, YA
    a30e:	4c0a 007f 	addu	D, #127
    a312:	4c80      	mov	YA, D

0000a314 <.L5>:
    a314:	48b6      	asr	YA, #7

0000a316 <.LM8>:
    a316:	2c00      	cmp	X, #0
    a318:	1d04      	jne	0xa322 <.L6>

0000a31a <.LM9>:
    a31a:	66d8 09b6 	lod	YL, 0x9b6 <.LASF1595+0x7>
    a31e:	5ce6      	ssex	Y
    a320:	7ee6      	lod	X, Y

0000a322 <.L6>:
    a322:	a2ee      	add	A, X

0000a324 <.LM11>:
    a324:	5401      	ret

0000a326 <.L2>:
    a326:	6400      	lod	YL, #0
    a328:	7ae8      	swap	Y

0000a32a <.LVL10>:
    a32a:	07eb      	jmp	0xa302 <.L8>

0000a32c <_SetSystemSpeed>:
    a32c:	5801      	inc	S, #2

0000a32e <.LCFI0>:
    a32e:	7ee2      	lod	X, A

0000a330 <.LM2>:
    a330:	62d8 0180 	lod	AL, 0x180 <.LASF1178+0x3>

0000a334 <.LVL1>:
    a334:	8407      	or	AL, #7
    a336:	42d8 0180 	mov	0x180 <.LASF1178+0x3>, AL

0000a33a <.LM3>:
    a33a:	62d8 0191 	lod	AL, 0x191 <.LASF1350>
    a33e:	840f      	or	AL, #15
    a340:	42d8 0191 	mov	0x191 <.LASF1350>, AL

0000a344 <.LBB118>:
    a344:	7ad8 01cc 	lod	Y, 0x1cc <_TRIM_RCO32M>

0000a348 <.LBE118>:
    a348:	72ee      	lod	A, X
    a34a:	b6da 03ff 	and	A, #1023

0000a34e <.LM6>:
    a34e:	f6da fc00 	and	Y, #64512
    a352:	a6e6      	or	A, Y
    a354:	52d8 01cc 	mov	0x1cc <_TRIM_RCO32M>, A

0000a358 <.LM7>:
    a358:	6205      	lod	AL, [S-6]
    a35a:	42d8 0200 	mov	0x200 <_PORT_CLOCK_CTRL>, AL

0000a35e <.LM8>:
    a35e:	7aee      	lod	Y, X
    a360:	7ae8      	swap	Y
    a362:	44b6      	lsr	Y, #2
    a364:	f403      	and	Y, #3
    a366:	e004      	add	Y, #4

0000a368 <.LM9>:
    a368:	5cf2      	usex	A
    a36a:	5201      	mov	[S-2], A
    a36c:	6205      	lod	AL, [S-6]
    a36e:	1904      	je	0xa378 <.L2>

0000a370 <.LM10>:
    a370:	72ee      	lod	A, X
    a372:	d480      	and	AH, #-128
    a374:	5ca2      	sne	A
    a376:	eae2      	sub	Y, A

0000a378 <.L2>:
    a378:	62d8 0191 	lod	AL, 0x191 <.LASF1350>
    a37c:	94f0      	and	AL, #-16
    a37e:	86e8      	or	AL, YL
    a380:	42d8 0191 	mov	0x191 <.LASF1350>, AL

0000a384 <.LM12>:
    a384:	7aee      	lod	Y, X

0000a386 <.LVL6>:
    a386:	7ae8      	swap	Y
    a388:	44b6      	lsr	Y, #2
    a38a:	44b6      	lsr	Y, #2
    a38c:	f403      	and	Y, #3
    a38e:	e001      	add	Y, #1

0000a390 <.LM13>:
    a390:	7201      	lod	A, [S-2]
    a392:	1906      	je	0xa3a0 <.L3>

0000a394 <.LM14>:
    a394:	36da 4000 	and	X, #16384

0000a398 <.LVL8>:
    a398:	5cae      	sne	X
    a39a:	eaee      	sub	Y, X

0000a39c <.LM15>:
    a39c:	1d01      	jne	0xa3a0 <.L3>

0000a39e <.LM16>:
    a39e:	7801      	lod	Y, #1

0000a3a0 <.L3>:
    a3a0:	62d8 0180 	lod	AL, 0x180 <.LASF1178+0x3>
    a3a4:	94f8      	and	AL, #-8
    a3a6:	86e8      	or	AL, YL
    a3a8:	42d8 0180 	mov	0x180 <.LASF1178+0x3>, AL

0000a3ac <.LM18>:
    a3ac:	5403      	ret	#4

0000a3ae <_EEPROM_BusyChecks>:
    a3ae:	72d8 0186 	lod	A, 0x186 <.LASF1965+0x3>
    a3b2:	d440      	and	AH, #64
    a3b4:	1906      	je	0xa3c2 <.L2>

0000a3b6 <.LM3>:
    a3b6:	62d8 0186 	lod	AL, 0x186 <.LASF1965+0x3>
    a3ba:	8401      	or	AL, #1

0000a3bc <.L7>:
    a3bc:	42d8 0186 	mov	0x186 <.LASF1965+0x3>, AL

0000a3c0 <.L1>:
    a3c0:	5401      	ret

0000a3c2 <.L2>:
    a3c2:	72d8 0186 	lod	A, 0x186 <.LASF1965+0x3>
    a3c6:	d410      	and	AH, #16
    a3c8:	197b      	je	0xa3c0 <.L1>

0000a3ca <.LM7>:
    a3ca:	62d8 0186 	lod	AL, 0x186 <.LASF1965+0x3>
    a3ce:	940f      	and	AL, #15
    a3d0:	07f5      	jmp	0xa3bc <.L7>

0000a3d2 <_EEPROM_WriteWord64_blocking>:
    a3d2:	5801      	inc	S, #2

0000a3d4 <.LCFI1>:
    a3d4:	7ed8 0186 	lod	X, 0x186 <.LASF1965+0x3>

0000a3d8 <.L24>:
    a3d8:	2c00      	cmp	X, #0
    a3da:	1e86      	jsge	0xa3e8 <.L19>

0000a3dc <.LM42>:
    a3dc:	5201      	mov	[S-2], A
    a3de:	17e7      	call	0xa3ae <_EEPROM_BusyChecks>

0000a3e0 <.LM43>:
    a3e0:	7ed8 0186 	lod	X, 0x186 <.LASF1965+0x3>
    a3e4:	7201      	lod	A, [S-2]
    a3e6:	07f8      	jmp	0xa3d8 <.L24>

0000a3e8 <.L19>:
    a3e8:	7e07      	lod	X, [S-8]

0000a3ea <.LM45>:
    a3ea:	5edf      	push	X

0000a3ec <.LCFI2>:
    a3ec:	7e07      	lod	X, [S-8]

0000a3ee <.LM47>:
    a3ee:	5edf      	push	X

0000a3f0 <.LCFI3>:
    a3f0:	82db 1328 	callf	0x2650 <_EEPROM_WriteWord64_non_blocking>

0000a3f4 <.LM48>:
    a3f4:	5c03      	dec	S, #4

0000a3f6 <.L21>:
    a3f6:	72d8 0186 	lod	A, 0x186 <.LASF1965+0x3>
    a3fa:	d420      	and	AH, #32
    a3fc:	1d7c      	jne	0xa3f6 <.L21>

0000a3fe <.LM50>:
    a3fe:	5403      	ret	#4

0000a400 <_VERSION_getFwAppVersion>:
    a400:	72d8 d7ee 	lod	A, 0xd7ee <.LASF676>
    a404:	72e4      	swap	A

0000a406 <.LVL1>:
    a406:	7ad8 d7ec 	lod	Y, 0xd7ec <__fw_app_version_start>
    a40a:	7ae8      	swap	Y

0000a40c <.LM3>:
    a40c:	5401      	ret

0000a40e <_atan2_helper>:
    a40e:	5801      	inc	S, #2

0000a410 <.LCFI0>:
    a410:	7ee6      	lod	X, Y

0000a412 <.LM2>:
    a412:	7ae2      	lod	Y, A
    a414:	7000      	lod	A, #0
    a416:	4c63      	divu	YA, X
    a418:	4c63      	divu	YA, X
    a41a:	66e4      	lod	YL, AH
    a41c:	6c00      	lod	YH, #0
    a41e:	4426      	asl	Y
    a420:	e2da 5dac 	add	Y, #23980
    a424:	7ef2      	lod	X, [Y+2]
    a426:	2af0      	sub	X, [Y]
    a428:	5cf2      	usex	A
    a42a:	4873      	muls	A, A, X
    a42c:	62e4      	lod	AL, AH
    a42e:	6800      	lod	AH, #0
    a430:	a2f0      	add	A, [Y]
    a432:	44b2      	lsr	A, #2

0000a434 <.LM3>:
    a434:	5403      	ret	#4

0000a436 <_atan2_lookup>:
    a436:	5801      	inc	S, #2

0000a438 <.LCFI1>:
    a438:	7ee2      	lod	X, A

0000a43a <.LVL3>:
    a43a:	5a01      	mov	[S-2], Y
    a43c:	7ae2      	lod	Y, A
    a43e:	7201      	lod	A, [S-2]

0000a440 <.LM5>:
    a440:	2ee2      	cmp	X, A
    a442:	1a06      	jule	0xa450 <.L3>

0000a444 <.LBB2>:
    a444:	17e4      	call	0xa40e <_atan2_helper>
    a446:	7ee2      	lod	X, A

0000a448 <.LM7>:
    a448:	72da 4000 	lod	A, #16384

0000a44c <.LVL6>:
    a44c:	aaee      	sub	A, X

0000a44e <.LBE2>:
    a44e:	5403      	ret	#4

0000a450 <.L3>:
    a450:	ac00      	cmp	A, #0
    a452:	1908      	je	0xa464 <.L2>

0000a454 <.LM9>:
    a454:	2ee2      	cmp	X, A
    a456:	1904      	je	0xa460 <.L6>

0000a458 <.LM10>:
    a458:	72ee      	lod	A, X
    a45a:	7a01      	lod	Y, [S-2]
    a45c:	17d8      	call	0xa40e <_atan2_helper>

0000a45e <.LVL9>:
    a45e:	5403      	ret	#4

0000a460 <.L6>:
    a460:	72da 2000 	lod	A, #8192

0000a464 <.L2>:
    a464:	5403      	ret	#4

0000a466 <_atan2I16>:
    a466:	ac00      	cmp	A, #0
    a468:	1e8c      	jsge	0xa482 <.L9>
    a46a:	5cc2      	neg	A

0000a46c <.LM18>:
    a46c:	7a03      	lod	Y, [S-4]
    a46e:	1d85      	jnn	0xa47a <.L10>

0000a470 <.LBB3>:
    a470:	5cc6      	neg	Y
    a472:	17e1      	call	0xa436 <_atan2_lookup>
    a474:	a2da 8000 	add	A, #32768

0000a478 <.LBE3>:
    a478:	5401      	ret

0000a47a <.L10>:
    a47a:	7a03      	lod	Y, [S-4]
    a47c:	17dc      	call	0xa436 <_atan2_lookup>
    a47e:	5cc2      	neg	A

0000a480 <.LVL20>:
    a480:	5401      	ret

0000a482 <.L9>:
    a482:	7a03      	lod	Y, [S-4]
    a484:	1d87      	jnn	0xa494 <.L12>

0000a486 <.LBB4>:
    a486:	5cc6      	neg	Y
    a488:	17d6      	call	0xa436 <_atan2_lookup>

0000a48a <.LVL22>:
    a48a:	7eda 8000 	lod	X, #32768
    a48e:	2ae2      	sub	X, A

0000a490 <.LVL23>:
    a490:	72ee      	lod	A, X

0000a492 <.LBE4>:
    a492:	5401      	ret

0000a494 <.L12>:
    a494:	7a03      	lod	Y, [S-4]
    a496:	07cf      	jmp	0xa436 <_atan2_lookup>

0000a498 <_ldt_Tick>:
    a498:	5809      	inc	S, #10

0000a49a <.LCFI35>:
    a49a:	5207      	mov	[S-8], A
    a49c:	620d      	lod	AL, [S-14]

0000a49e <.LVL114>:
    a49e:	5cf2      	usex	A
    a4a0:	5209      	mov	[S-10], A

0000a4a2 <.LBB60>:
    a4a2:	7ad8 1000 	lod	Y, 0x1000 <_ldtMe>
    a4a6:	7ee6      	lod	X, Y
    a4a8:	200c      	add	X, #12
    a4aa:	5e03      	mov	[S-4], X
    a4ac:	62f8      	lod	AL, [X]
    a4ae:	1906      	je	0xa4bc <.L86>

0000a4b0 <.LM190>:
    a4b0:	6064      	lod	AL, #100
    a4b2:	20fd      	add	X, #-3
    a4b4:	42f8      	mov	[X], AL

0000a4b6 <.LM191>:
    a4b6:	6000      	lod	AL, #0
    a4b8:	7e03      	lod	X, [S-4]
    a4ba:	42f8      	mov	[X], AL

0000a4bc <.L86>:
    a4bc:	7ee6      	lod	X, Y
    a4be:	2009      	add	X, #9
    a4c0:	62f8      	lod	AL, [X]
    a4c2:	4203      	mov	[S-4], AL
    a4c4:	5cf2      	usex	A
    a4c6:	5205      	mov	[S-6], A
    a4c8:	7207      	lod	A, [S-8]
    a4ca:	ae05      	cmp	A, [S-6]
    a4cc:	1c17      	jnc	0xa4fc <.L87>

0000a4ce <.LM193>:
    a4ce:	6203      	lod	AL, [S-4]
    a4d0:	8a07      	sub	AL, [S-8]

0000a4d2 <.L98>:
    a4d2:	42f8      	mov	[X], AL

0000a4d4 <.LBB63>:
    a4d4:	7ee6      	lod	X, Y
    a4d6:	200d      	add	X, #13
    a4d8:	e00a      	add	Y, #10
    a4da:	62f8      	lod	AL, [X]
    a4dc:	1904      	je	0xa4e6 <.L89>

0000a4de <.LM196>:
    a4de:	6064      	lod	AL, #100
    a4e0:	42f0      	mov	[Y], AL

0000a4e2 <.LM197>:
    a4e2:	6000      	lod	AL, #0
    a4e4:	42f8      	mov	[X], AL

0000a4e6 <.L89>:
    a4e6:	62f0      	lod	AL, [Y]
    a4e8:	4205      	mov	[S-6], AL
    a4ea:	5cf2      	usex	A
    a4ec:	7ee2      	lod	X, A
    a4ee:	7209      	lod	A, [S-10]
    a4f0:	aeee      	cmp	A, X
    a4f2:	1c06      	jnc	0xa500 <.L90>

0000a4f4 <.LM199>:
    a4f4:	6205      	lod	AL, [S-6]
    a4f6:	8a0d      	sub	AL, [S-14]

0000a4f8 <.L99>:
    a4f8:	42f0      	mov	[Y], AL

0000a4fa <.LBE63>:
    a4fa:	540b      	ret	#12

0000a4fc <.L87>:
    a4fc:	6000      	lod	AL, #0
    a4fe:	07e9      	jmp	0xa4d2 <.L98>

0000a500 <.L90>:
    a500:	6000      	lod	AL, #0
    a502:	07fa      	jmp	0xa4f8 <.L99>

0000a504 <_ml_GetProtectedID>:
    a504:	62d8 0e47 	lod	AL, 0xe47 <_LinProtectedID>
    a508:	5cf2      	usex	A

0000a50a <.LM11>:
    a50a:	5401      	ret

0000a50c <_ml_SetFixedBaudRate>:
    a50c:	5801      	inc	S, #2

0000a50e <.LCFI1>:
    a50e:	7ee2      	lod	X, A

0000a510 <.LM24>:
    a510:	a2da fc18 	add	A, #64536

0000a514 <.LVL18>:
    a514:	aeda 4a38 	cmp	A, #19000
    a518:	1e22      	jug	0xa55e <.L16>

0000a51a <.LM25>:
    a51a:	7205      	lod	A, [S-6]

0000a51c <.LBB36>:
    a51c:	4822 2710 	mulu	YA, A, #10000

0000a520 <.LVL21>:
    a520:	442e      	asl	X

0000a522 <.LBB38>:
    a522:	4c63      	divu	YA, X
    a524:	4c63      	divu	YA, X
    a526:	7ae2      	lod	Y, A

0000a528 <.LBE38>:
    a528:	7000      	lod	A, #0

0000a52a <.LVL24>:
    a52a:	5201      	mov	[S-2], A
    a52c:	7c0c      	lod	X, #12

0000a52e <.L15>:
    a52e:	72e6      	lod	A, Y
    a530:	a2da fc27 	add	A, #64551
    a534:	aeda 03fb 	cmp	A, #1019
    a538:	1e0c      	jug	0xa552 <.L14>

0000a53a <.LM30>:
    a53a:	a2da 03de 	add	A, #990
    a53e:	4cf2      	usex	YA

0000a540 <.LBB40>:
    a540:	7c0a      	lod	X, #10
    a542:	4c63      	divu	YA, X
    a544:	4c63      	divu	YA, X

0000a546 <.LBE40>:
    a546:	5cf2      	usex	A

0000a548 <.LVL28>:
    a548:	52df      	push	A

0000a54a <.LCFI2>:
    a54a:	7203      	lod	A, [S-4]
    a54c:	82db 11e4 	callf	0x23c8 <_ml_SetBaudRate>

0000a550 <.LCFI3>:
    a550:	5405      	ret	#6

0000a552 <.L14>:
    a552:	4436      	lsr	Y

0000a554 <.LM34>:
    a554:	6201      	lod	AL, [S-2]
    a556:	8001      	add	AL, #1
    a558:	5cf2      	usex	A
    a55a:	5201      	mov	[S-2], A

0000a55c <.LVL34>:
    a55c:	1be8      	djnz	X, 0xa52e <.L15>

0000a55e <.L16>:
    a55e:	7001      	lod	A, #1

0000a560 <.LM36>:
    a560:	5403      	ret	#4

0000a562 <_ml_Init>:
    a562:	5801      	inc	S, #2

0000a564 <.LCFI4>:
    a564:	5201      	mov	[S-2], A
    a566:	82db 20bb 	callf	0x4176 <_ml_InitLinModule>

0000a56a <.LM39>:
    a56a:	7a01      	lod	Y, [S-2]
    a56c:	ac00      	cmp	A, #0
    a56e:	1d29      	jne	0xa5c2 <.L18>

0000a570 <.LM40>:
    a570:	7e07      	lod	X, [S-8]

0000a572 <.LM41>:
    a572:	5edf      	push	X

0000a574 <.LCFI5>:
    a574:	52df      	push	A

0000a576 <.LCFI6>:
    a576:	54ca 0001 	pushw	#1

0000a57a <.LCFI7>:
    a57a:	52df      	push	A

0000a57c <.LCFI8>:
    a57c:	7001      	lod	A, #1

0000a57e <.LVL38>:
    a57e:	5a09      	mov	[S-10], Y
    a580:	82db 118d 	callf	0x231a <_ml_SetOptions>

0000a584 <.LM42>:
    a584:	5c07      	dec	S, #8

0000a586 <.LCFI9>:
    a586:	7a01      	lod	Y, [S-2]
    a588:	ac00      	cmp	A, #0
    a58a:	1d1b      	jne	0xa5c2 <.L18>

0000a58c <.LM43>:
    a58c:	ec01      	cmp	Y, #1
    a58e:	1d0c      	jne	0xa5a8 <.L20>

0000a590 <.L26>:
    a590:	82db 11ea 	callf	0x23d4 <_ml_SetAutoBaudRateMode>

0000a594 <.L21>:
    a594:	ac00      	cmp	A, #0
    a596:	1d15      	jne	0xa5c2 <.L18>

0000a598 <.LM46>:
    a598:	7205      	lod	A, [S-6]

0000a59a <.LM47>:
    a59a:	aeda 3a98 	cmp	A, #15000
    a59e:	5c80      	sc	A
    a5a0:	4422      	asl	A
    a5a2:	82db 1181 	callf	0x2302 <_ml_SetSlewRate>

0000a5a6 <.LVL43>:
    a5a6:	5403      	ret	#4

0000a5a8 <.L20>:
    a5a8:	ec02      	cmp	Y, #2
    a5aa:	1d02      	jne	0xa5b0 <.L22>

0000a5ac <.LM49>:
    a5ac:	7001      	lod	A, #1

0000a5ae <.LVL44>:
    a5ae:	07f0      	jmp	0xa590 <.L26>

0000a5b0 <.L22>:
    a5b0:	ec00      	cmp	Y, #0
    a5b2:	1d06      	jne	0xa5c0 <.L24>

0000a5b4 <.LM51>:
    a5b4:	7209      	lod	A, [S-10]

0000a5b6 <.LM52>:
    a5b6:	52df      	push	A

0000a5b8 <.LCFI10>:
    a5b8:	7207      	lod	A, [S-8]
    a5ba:	17a8      	call	0xa50c <_ml_SetFixedBaudRate>

0000a5bc <.LVL47>:
    a5bc:	5c01      	dec	S, #2

0000a5be <.LCFI11>:
    a5be:	07ea      	jmp	0xa594 <.L21>

0000a5c0 <.L24>:
    a5c0:	7001      	lod	A, #1

0000a5c2 <.L18>:
    a5c2:	5403      	ret	#4
